:js
:il

// note: seems we can't use traits yet :|
// using a field to store the effect handler instead
:fixme
:sjs
class Effect[A](perform: Str -> Str)
fun foo(e) = e.perform("hi")
handle h = Effect with
  fun perform(arg, k) = k(arg)
in
  foo(h)
  (() => h.perform("Hello"))()
//│ JS:
//│ let separator, cur, tmp, res, res1;
//│ separator = undefined;
//│ function Cont$(resume1, resumed1, next1) { return new Cont$.class(resume1, resumed1, next1); };
//│ Cont$.class = class Cont$ {
//│   constructor(resume, resumed, next) {
//│     this.resume = resume;
//│     this.resumed = resumed;
//│     this.next = next;
//│     
//│   }
//│   toString() { return "Cont$(" + this.resume + ", " + this.resumed + ", " + this.next + ")"; }
//│ };
//│ this.Effect = function Effect(perform1) { return new Effect.class(perform1); };
//│ this.Effect.class = class Effect {
//│   constructor(perform) {
//│     this.perform = perform;
//│     
//│   }
//│   toString() { return "Effect(" + this.perform + ")"; }
//│ };
//│ function foo(e) {
//│   let res2;
//│   res2 = e.perform("hi");
//│   if (res2 instanceof globalThis.Cont$.class) {
//│     return res2;
//│   }
//│   res2 = separator(0);
//│   return res2;
//│ }
//│ function perform(arg, k) {
//│   let res2;
//│   res2 = k(arg);
//│   if (res2 instanceof globalThis.Cont$.class) {
//│     return res2;
//│   }
//│   res2 = separator(2);
//│   return res2;
//│ }
//│ handlerBody: while (true) {
//│   this.h = new this.Effect((arg) => {
//│     let cont;
//│     cont = new this.Cont$.class((x) => {
//│       return x;
//│     }, false, undefined);
//│     cont.last = cont;
//│     cont.handler = this.h;
//│     cont.handlerFun = perform;
//│     cont.params = [
//│       arg
//│     ];
//│     return cont;
//│   });
//│   res = this.foo(this.h);
//│   if (res instanceof this.Cont$.class) {
//│     cur = res;
//│     break handlerBody;
//│   }
//│   res = separator(3);
//│   res1 = (() => {
//│     let res2;
//│     res2 = this.h.perform("Hello");
//│     if (res2 instanceof this.Cont$.class) {
//│       return res2;
//│     }
//│     res2 = separator(5);
//│     return res2;
//│   })();
//│   if (res1 instanceof this.Cont$.class) {
//│     cur = res1;
//│     break handlerBody;
//│   }
//│   res1 = separator(4);
//│   cur = res1;
//│   break;
//│ }
//│ cur = separator(1);
//│ handler: while (true) {
//│   if (cur instanceof this.Cont$.class) {
//│     if (cur.handler) {
//│       tmp = cur.handler === this.h;
//│       if (tmp) {
//│         cur = cur.handlerFun.apply(null, cur.args);
//│         continue handler;
//│       }
//│     } else {
//│       throw new this.Error("Unhandled effects");
//│     }
//│   }
//│   break;
//│ }
//│ undefined
//│ ═══[RUNTIME ERROR] TypeError: separator is not a function

:fixme
:sjs
class Cell(getVal: () -> Int, setVal: Int -> ())
let x = 0
handle h = Cell with
  fun getVal(k) = k(x)
  fun setVal(value, k) =
    x = value
    k(())
in
  h.getVal()
//│ JS:
//│ let separator, cur, tmp, res;
//│ separator = undefined;
//│ function Cont$(resume1, resumed1, next1) { return new Cont$.class(resume1, resumed1, next1); };
//│ Cont$.class = class Cont$ {
//│   constructor(resume, resumed, next) {
//│     this.resume = resume;
//│     this.resumed = resumed;
//│     this.next = next;
//│     
//│   }
//│   toString() { return "Cont$(" + this.resume + ", " + this.resumed + ", " + this.next + ")"; }
//│ };
//│ this.Cell = function Cell(getVal1, setVal1) { return new Cell.class(getVal1, setVal1); };
//│ this.Cell.class = class Cell {
//│   constructor(getVal, setVal) {
//│     this.getVal = getVal;
//│     this.setVal = setVal;
//│     
//│   }
//│   toString() { return "Cell(" + this.getVal + ", " + this.setVal + ")"; }
//│ };
//│ this.x = 0;
//│ function setVal(value, k) {
//│   let res1;
//│   globalThis.x = value;
//│   res1 = k(undefined);
//│   if (res1 instanceof globalThis.Cont$.class) {
//│     return res1;
//│   }
//│   res1 = separator(1);
//│   return res1;
//│ }
//│ function getVal(k) {
//│   let res1;
//│   res1 = k(globalThis.x);
//│   if (res1 instanceof globalThis.Cont$.class) {
//│     return res1;
//│   }
//│   res1 = separator(2);
//│   return res1;
//│ }
//│ handlerBody: while (true) {
//│   this.h = new this.Cell(() => {
//│     let cont;
//│     cont = new this.Cont$.class((x) => {
//│       return x;
//│     }, false, undefined);
//│     cont.last = cont;
//│     cont.handler = this.h;
//│     cont.handlerFun = getVal;
//│     cont.params = [
//│       
//│     ];
//│     return cont;
//│   }, (value) => {
//│     let cont;
//│     cont = new this.Cont$.class((x) => {
//│       return x;
//│     }, false, undefined);
//│     cont.last = cont;
//│     cont.handler = this.h;
//│     cont.handlerFun = setVal;
//│     cont.params = [
//│       value
//│     ];
//│     return cont;
//│   });
//│   res = this.h.getVal();
//│   if (res instanceof this.Cont$.class) {
//│     cur = res;
//│     break handlerBody;
//│   }
//│   res = separator(3);
//│   cur = res;
//│   break;
//│ }
//│ cur = separator(0);
//│ handler: while (true) {
//│   if (cur instanceof this.Cont$.class) {
//│     if (cur.handler) {
//│       tmp = cur.handler === this.h;
//│       if (tmp) {
//│         cur = cur.handlerFun.apply(null, cur.args);
//│         continue handler;
//│       }
//│     } else {
//│       throw new this.Error("Unhandled effects");
//│     }
//│   }
//│   break;
//│ }
//│ undefined
//│ ═══[RUNTIME ERROR] TypeError: separator is not a function
//│ x = 0

:fixme
:sjs
fun f() =
  val x = 3
  let y = 5 in
    val x = 5
    x + y
//│ JS:
//│ let separator;
//│ separator = undefined;
//│ function Cont$(resume1, resumed1, next1) { return new Cont$.class(resume1, resumed1, next1); };
//│ Cont$.class = class Cont$ {
//│   constructor(resume, resumed, next) {
//│     this.resume = resume;
//│     this.resumed = resumed;
//│     this.next = next;
//│     
//│   }
//│   toString() { return "Cont$(" + this.resume + ", " + this.resumed + ", " + this.next + ")"; }
//│ };
//│ function f() {
//│   let y, res;
//│   const x = 3;
//│   y = 5;
//│   const x = 5;
//│   res = x + y;
//│   if (res instanceof globalThis.Cont$.class) {
//│     return res;
//│   }
//│   res = separator(0);
//│   return res;
//│ }
//│ undefined
//│ ═══[COMPILATION ERROR] [Uncaught SyntaxError] Identifier 'x' has already been declared
