:js
:il

// note: seems we can't use traits yet :|
// using a field to store the effect handler instead

// TODO: put resume$ and Cont$ into a Predef (resume$ should not be instrumented) for correctness, as the same Cont$ should be used for all function code

// TODO: use this syntax
// TODO: prepend or append resumption parameter like fun perform(x)(resume): Str -> Str or fun perform(resume)(x): Str -> Str
// Handle the case where the function is defined like fun perform: Str, then e.perform should also yield an effect?
// handle ... fun perform(resume)(x)(y)(z): A = resume(x)
// Dummy handler: fun dummy_perform(x)(y)(z) = { let result = new EffectSig$(h, perform(x)(y)(z)); result.tail = result; return result; }
// resume: A -> ?
// this simplifies current handler code, no need to Array.push anymore
:sjs
abstract class Effect[A] with
  fun perform(x: A): Str -> Str
//│ JS:
//│ function resume$(cont, tail) {
//│   return (value) => {
//│     let cont1, value1;
//│     cont1 = cont;
//│     value1 = value;
//│     chainLoop: while (true) {
//│       if (cont1) {
//│         value1 = cont1.resume(value1);
//│         if (value1) {
//│           if (value1.isCont$) {
//│             value1.tail = tail;
//│             return value1;
//│           }
//│         }
//│         cont1 = cont1.next;
//│         continue chainLoop;
//│       }
//│       return value1;
//│       break;
//│     }
//│   };
//│ }
//│ this.Cont$ = function Cont$(resume1, resumed1, next1, isCont$1) { return new Cont$.class(resume1, resumed1, next1, isCont$1); };
//│ this.Cont$.class = class Cont$ {
//│   constructor(resume, resumed, next, isCont$) {
//│     this.resume = resume;
//│     this.resumed = resumed;
//│     this.next = next;
//│     this.isCont$ = isCont$;
//│     
//│   }
//│   toString() { return "Cont$(" + this.resume + ", " + this.resumed + ", " + this.next + ", " + this.isCont$ + ")"; }
//│ };
//│ this.Effect = class Effect {
//│   constructor() {
//│     
//│   }
//│   toString() { return "Effect"; }
//│ };
//│ undefined

:expect 'b'
class Effect[A](perform: Str -> Str)
val r = handle h = Effect with
  fun perform(arg, k) = "b"
in
  h.perform("k")
r
//│ r = 'b'

:expect 'k'
class Effect[A](perform: Str -> Str)
val r = handle h = Effect with
  fun perform(arg, k) = arg
in
  h.perform("k")
r
//│ r = 'k'

:expect 'Hello'
class Effect[A](perform: Str -> Str)
fun foo(e) = e.perform("hi")
val r = handle h = Effect with
  fun perform(arg, k) =
    print(arg)
    k(arg)
in
  (() => h.perform("Hello"))()
r
//│ > Hello
//│ r = 'Hello'

:expect 'hi'
class Effect[A](perform: Str -> Str)
fun foo(e) = e.perform("hi")
val r = handle h = Effect with
  fun perform(arg, k) =
    print(arg)
    k(arg)
in
  foo(h)
r
//│ > hi
//│ r = 'hi'

:expect 'hello5'
class Effect[A](perform: Str -> Str)
val r = handle h = Effect with
  fun perform(arg, k) =
    let v = k(arg)
    print(arg)
    v
in
  h.perform("hello1")
  h.perform("hello2")
  h.perform("hello3")
  h.perform("hello4")
  h.perform("hello5")
r
//│ > hello1
//│ > hello2
//│ > hello3
//│ > hello4
//│ > hello5
//│ r = 'hello5'

:expect 'b'
class Effect[A](perform: Str -> Str)
val x =
  handle h = Effect with
    fun perform(arg, k) =
      print(arg)
      "b"
  in
    h.perform("t")
x
//│ > t
//│ x = 'b'

// TODO: val is not working
:expect 'Hello World!'
class Effect[A](perform: Str -> Str)
fun foo(h) =
  print("Entering foo")
  let result = h.perform("Hello")
  h.perform("?")
  print("Exiting foo")
  result
val x = handle h = Effect with
  fun perform(arg, k) =
    print("handler called")
    let result = k(arg)
    print("handler finished")
    result
in
  print("mainbody start")
  let result = foo(h) + " World!"
  print("mainbody end")
  result
x
//│ > mainbody start
//│ > Entering foo
//│ > handler called
//│ > handler called
//│ > Exiting foo
//│ > mainbody end
//│ > handler finished
//│ > handler finished
//│ x = 'Hello World!'

:expect 'Hello World!'
class Effect[A](perform: Str -> Str)
fun foo(h) =
  print("Entering foo")
  let result = h.perform("Hello")
  h.perform("Oops!")
  print("Exiting foo")
  result
fun bar(h) =
  print("Entering bar")
  let result = foo(h) + " World"
  print("Exiting bar")
  result
fun foobar(h) =
  print("Entering foobar")
  let result = bar(h) + "!"
  print("Exiting foobar")
  result
val x = handle h = Effect with
  fun perform(arg, k) =
    print("handler called")
    let result = k(arg)
    print("handler finished")
    result
in
  print("mainbody start")
  let result = foobar(h)
  print("mainbody end")
  result
x
//│ > mainbody start
//│ > Entering foobar
//│ > Entering bar
//│ > Entering foo
//│ > handler called
//│ > handler called
//│ > Exiting foo
//│ > Exiting bar
//│ > Exiting foobar
//│ > mainbody end
//│ > handler finished
//│ > handler finished
//│ x = 'Hello World!'

:fixme
:expect 1
class Cell(getVal: () -> Int, setVal: Int -> ())
let x = 0
let k
let m
let res = handle h = Cell with
  fun getVal(k) = k(x)
  fun setVal(value, k) =
    x = value
    k(())
in
  k = h.getVal()
  h.setVal(1)
  m = h.getVal()
k + m
//│ ═══[RUNTIME ERROR] Expected: 1, got: 0
//│ m = 1
//│ x = 1

// weird...?
:expect 1
k + m

class A(x) with
  fun debug() = print(x)
let x = new A(333)
x.debug()
//│ > 333
//│ x = A { x: 333 }

:fixme
fun f() =
  val x = 3
  let y = 5 in
    val x = 5
    x + y
//│ ═══[COMPILATION ERROR] [Uncaught SyntaxError] Identifier 'x' has already been declared

fun f() =
  let x = 2 
  let y = f()
  let z = 3
  2

:expect 120
class Eff(get: () -> Int)
fun fact(e, factvalue) = 
  if factvalue != 0 then
    factvalue * fact(e, factvalue-1)
  else e.get()
handle h = Eff with
  fun get(k) = k(1)
let result = fact(h, 5)
result
//│ result = 120

// stack safe recursion
:expect 5050
class StackDelay(raise: () -> ())
handle h = StackDelay with
  fun raise(k) =
    // console.trace("Stack unwinded!")
    k(10)
fun sum(depth, x) =
  val new_depth = if depth > 70 then
    // console.trace("Too deep, heapifying the stack")
    h.raise()
  else
    depth + 1
  if x != 0 then
    x + sum(new_depth, x - 1)
  else 0
let result = sum(0, 100)
result
//│ result = 5050

// stack safe recursion
:expect 450015000
class StackDelay(raise: () -> Int)
handle h = StackDelay with
  fun raise(k) = // TODO: This should codegen to a simple return without instrumentation
    k(10)
fun sum(depth, x) =
  val new_depth = if depth > 4000 then h.raise() else depth + 1
  if x != 0 then
    x + sum(new_depth, x - 1)
  else 0
let result = sum(0, 30000)
result
//│ result = 450015000

:re
fun sum(x) =
  if x != 0 then
    x + sum(x - 1)
  else 0
let result = sum(10000)
result
//│ ═══[RUNTIME ERROR] RangeError: Maximum call stack size exceeded
//│ result = 450015000
