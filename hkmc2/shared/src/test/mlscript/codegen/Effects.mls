:js
:il

// note: seems we can't use traits yet :|
// using a field to store the effect handler instead
:fixme
:sjs
class Effect[A](perform: Str -> Str)
fun foo(e) = e.perform("hi")
handle h = Effect with
  fun perform(arg, k) = k(arg)
in
  foo(h)
  (() => h.perform("Hello"))()
//│ JS:
//│ let separator, cur, resume, tmp, res, res1;
//│ class Cont$32$foo {
//│   constructor() {
//│     
//│   }
//│   toString() { return "Cont$32$foo"; }
//│ }
//│ class Cont$36$perform {
//│   constructor() {
//│     
//│   }
//│   toString() { return "Cont$36$perform"; }
//│ }
//│ class Cont$49$ {
//│   constructor() {
//│     
//│   }
//│   toString() { return "Cont$49$"; }
//│ }
//│ class Cont$44$ {
//│   constructor() {
//│     
//│   }
//│   toString() { return "Cont$44$"; }
//│ }
//│ separator = undefined;
//│ function resume$(cont) {
//│   return (value) => {
//│     let cont1, value1;
//│     cont1 = cont;
//│     value1 = value;
//│     chainLoop: while (true) {
//│       if (cont1) {
//│         value1 = cont1.resume(value1);
//│         cont1 = cont1.next;
//│         continue chainLoop;
//│       }
//│       return value1;
//│       break;
//│     }
//│   };
//│ }
//│ function Cont$(resume2, resumed1, next1, isCont$1) { return new Cont$.class(resume2, resumed1, next1, isCont$1); };
//│ Cont$.class = class Cont$ {
//│   constructor(resume1, resumed, next, isCont$) {
//│     this.resume = resume1;
//│     this.resumed = resumed;
//│     this.next = next;
//│     this.isCont$ = isCont$;
//│     
//│   }
//│   toString() { return "Cont$(" + this.resume1 + ", " + this.resumed + ", " + this.next + ", " + this.isCont$ + ")"; }
//│ };
//│ this.Effect = function Effect(perform1) { return new Effect.class(perform1); };
//│ this.Effect.class = class Effect {
//│   constructor(perform) {
//│     this.perform = perform;
//│     
//│   }
//│   toString() { return "Effect(" + this.perform + ")"; }
//│ };
//│ function foo(e) {
//│   let res2;
//│   res2 = e.perform("hi");
//│   if (res2 instanceof globalThis.Cont$.class) {
//│     return new globalThis.Cont$32$foo(0, res2);
//│   }
//│   res2 = separator(0);
//│   return res2;
//│ }
//│ function perform(arg, k) {
//│   let res2;
//│   res2 = k(arg);
//│   if (res2 instanceof globalThis.Cont$.class) {
//│     return new globalThis.Cont$36$perform(2, res2);
//│   }
//│   res2 = separator(2);
//│   return res2;
//│ }
//│ handlerBody: while (true) {
//│   this.h = new this.Effect((arg) => {
//│     let cont;
//│     cont = new this.Cont$.class((x) => {
//│       return x;
//│     }, false, undefined, true);
//│     cont.last = cont;
//│     cont.handler = this.h;
//│     cont.handlerFun = perform;
//│     cont.params = [
//│       arg
//│     ];
//│     return cont;
//│   });
//│   res = this.foo(this.h);
//│   if (res instanceof this.Cont$.class) {
//│     cur = new this.Cont$44$(3, res);
//│     break handlerBody;
//│   }
//│   res = separator(3);
//│   res1 = (() => {
//│     let res2;
//│     res2 = this.h.perform("Hello");
//│     if (res2 instanceof this.Cont$.class) {
//│       return new this.Cont$49$(5, res2);
//│     }
//│     res2 = separator(5);
//│     return res2;
//│   })();
//│   if (res1 instanceof this.Cont$.class) {
//│     cur = new this.Cont$44$(4, res1);
//│     break handlerBody;
//│   }
//│   res1 = separator(4);
//│   cur = res1;
//│   break;
//│ }
//│ cur = separator(1);
//│ handler: while (true) {
//│   if (cur.isCont$) {
//│     if (cur.handler) {
//│       tmp = cur.handler === this.h;
//│       if (tmp) {
//│         resume = resume$(cur);
//│         tmp = cur.args.push(resume);
//│         cur = cur.handlerFun.apply(null, cur.args);
//│         continue handler;
//│       }
//│     } else {
//│       throw new this.Error("Unhandled effects");
//│     }
//│   }
//│   break;
//│ }
//│ undefined
//│ ═══[RUNTIME ERROR] TypeError: globalThis.Cont$32$foo is not a constructor

:fixme
:sjs
class Cell(getVal: () -> Int, setVal: Int -> ())
let x = 0
handle h = Cell with
  fun getVal(k) = k(x)
  fun setVal(value, k) =
    x = value
    k(())
in
  h.getVal()
//│ JS:
//│ let separator, cur, resume, tmp, res;
//│ class Cont$68$setVal {
//│   constructor() {
//│     
//│   }
//│   toString() { return "Cont$68$setVal"; }
//│ }
//│ class Cont$71$getVal {
//│   constructor() {
//│     
//│   }
//│   toString() { return "Cont$71$getVal"; }
//│ }
//│ class Cont$79$ {
//│   constructor() {
//│     
//│   }
//│   toString() { return "Cont$79$"; }
//│ }
//│ separator = undefined;
//│ function resume$(cont) {
//│   return (value) => {
//│     let cont1, value1;
//│     cont1 = cont;
//│     value1 = value;
//│     chainLoop: while (true) {
//│       if (cont1) {
//│         value1 = cont1.resume(value1);
//│         cont1 = cont1.next;
//│         continue chainLoop;
//│       }
//│       return value1;
//│       break;
//│     }
//│   };
//│ }
//│ function Cont$(resume2, resumed1, next1, isCont$1) { return new Cont$.class(resume2, resumed1, next1, isCont$1); };
//│ Cont$.class = class Cont$ {
//│   constructor(resume1, resumed, next, isCont$) {
//│     this.resume = resume1;
//│     this.resumed = resumed;
//│     this.next = next;
//│     this.isCont$ = isCont$;
//│     
//│   }
//│   toString() { return "Cont$(" + this.resume1 + ", " + this.resumed + ", " + this.next + ", " + this.isCont$ + ")"; }
//│ };
//│ this.Cell = function Cell(getVal1, setVal1) { return new Cell.class(getVal1, setVal1); };
//│ this.Cell.class = class Cell {
//│   constructor(getVal, setVal) {
//│     this.getVal = getVal;
//│     this.setVal = setVal;
//│     
//│   }
//│   toString() { return "Cell(" + this.getVal + ", " + this.setVal + ")"; }
//│ };
//│ this.x = 0;
//│ function setVal(value, k) {
//│   let res1;
//│   globalThis.x = value;
//│   res1 = k(undefined);
//│   if (res1 instanceof globalThis.Cont$.class) {
//│     return new globalThis.Cont$68$setVal(1, res1);
//│   }
//│   res1 = separator(1);
//│   return res1;
//│ }
//│ function getVal(k) {
//│   let res1;
//│   res1 = k(globalThis.x);
//│   if (res1 instanceof globalThis.Cont$.class) {
//│     return new globalThis.Cont$71$getVal(2, res1);
//│   }
//│   res1 = separator(2);
//│   return res1;
//│ }
//│ handlerBody: while (true) {
//│   this.h = new this.Cell(() => {
//│     let cont;
//│     cont = new this.Cont$.class((x) => {
//│       return x;
//│     }, false, undefined, true);
//│     cont.last = cont;
//│     cont.handler = this.h;
//│     cont.handlerFun = getVal;
//│     cont.params = [
//│       
//│     ];
//│     return cont;
//│   }, (value) => {
//│     let cont;
//│     cont = new this.Cont$.class((x) => {
//│       return x;
//│     }, false, undefined, true);
//│     cont.last = cont;
//│     cont.handler = this.h;
//│     cont.handlerFun = setVal;
//│     cont.params = [
//│       value
//│     ];
//│     return cont;
//│   });
//│   res = this.h.getVal();
//│   if (res instanceof this.Cont$.class) {
//│     cur = new this.Cont$79$(3, res);
//│     break handlerBody;
//│   }
//│   res = separator(3);
//│   cur = res;
//│   break;
//│ }
//│ cur = separator(0);
//│ handler: while (true) {
//│   if (cur.isCont$) {
//│     if (cur.handler) {
//│       tmp = cur.handler === this.h;
//│       if (tmp) {
//│         resume = resume$(cur);
//│         tmp = cur.args.push(resume);
//│         cur = cur.handlerFun.apply(null, cur.args);
//│         continue handler;
//│       }
//│     } else {
//│       throw new this.Error("Unhandled effects");
//│     }
//│   }
//│   break;
//│ }
//│ undefined
//│ ═══[RUNTIME ERROR] TypeError: this.Cont$79$ is not a constructor
//│ x = 0

:il
:sjs
class A(x) with
  fun debug() = print(x)
let x = new A()
//│ JS:
//│ let separator, tmp;
//│ separator = undefined;
//│ function resume$(cont) {
//│   return (value) => {
//│     let cont1, value1;
//│     cont1 = cont;
//│     value1 = value;
//│     chainLoop: while (true) {
//│       if (cont1) {
//│         value1 = cont1.resume(value1);
//│         cont1 = cont1.next;
//│         continue chainLoop;
//│       }
//│       return value1;
//│       break;
//│     }
//│   };
//│ }
//│ function Cont$(resume1, resumed1, next1, isCont$1) { return new Cont$.class(resume1, resumed1, next1, isCont$1); };
//│ Cont$.class = class Cont$ {
//│   constructor(resume, resumed, next, isCont$) {
//│     this.resume = resume;
//│     this.resumed = resumed;
//│     this.next = next;
//│     this.isCont$ = isCont$;
//│     
//│   }
//│   toString() { return "Cont$(" + this.resume + ", " + this.resumed + ", " + this.next + ", " + this.isCont$ + ")"; }
//│ };
//│ this.A = function A(x1) { return new A.class(x1); };
//│ this.A.class = class A {
//│   constructor(x) {
//│     this.x = x;
//│     
//│   }
//│   debug() {
//│     let res;
//│     res = Predef.print(this.x);
//│     if (res instanceof globalThis.Cont$.class) {
//│       throw new globalThis.Error("Unhandled effects");
//│     }
//│     res = separator(0);
//│     return res;
//│   }
//│   toString() { return "A(" + this.x + ")"; }
//│ };
//│ tmp = new this.A.class();
//│ this.x = tmp;
//│ undefined
//│ x = A { x: undefined }

:fixme
:sjs
:il
fun f() =
  val x = 3
  let y = 5 in
    val x = 5
    x + y
//│ JS:
//│ let separator;
//│ class Cont$104$f {
//│   constructor() {
//│     
//│   }
//│   toString() { return "Cont$104$f"; }
//│ }
//│ separator = undefined;
//│ function resume$(cont) {
//│   return (value) => {
//│     let cont1, value1;
//│     cont1 = cont;
//│     value1 = value;
//│     chainLoop: while (true) {
//│       if (cont1) {
//│         value1 = cont1.resume(value1);
//│         cont1 = cont1.next;
//│         continue chainLoop;
//│       }
//│       return value1;
//│       break;
//│     }
//│   };
//│ }
//│ function Cont$(resume1, resumed1, next1, isCont$1) { return new Cont$.class(resume1, resumed1, next1, isCont$1); };
//│ Cont$.class = class Cont$ {
//│   constructor(resume, resumed, next, isCont$) {
//│     this.resume = resume;
//│     this.resumed = resumed;
//│     this.next = next;
//│     this.isCont$ = isCont$;
//│     
//│   }
//│   toString() { return "Cont$(" + this.resume + ", " + this.resumed + ", " + this.next + ", " + this.isCont$ + ")"; }
//│ };
//│ function f() {
//│   let y, res;
//│   const x = 3;
//│   y = 5;
//│   const x = 5;
//│   res = x + y;
//│   if (res instanceof globalThis.Cont$.class) {
//│     return new globalThis.Cont$104$f(0, res);
//│   }
//│   res = separator(0);
//│   return res;
//│ }
//│ undefined
//│ ═══[COMPILATION ERROR] [Uncaught SyntaxError] Identifier 'x' has already been declared
