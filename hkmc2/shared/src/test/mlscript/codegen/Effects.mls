:js

// note: seems we can't use traits yet :|
// using a field to store the effect handler instead
:fixme
:il
:sjs
:d
class Effect[A](perform: Str -> Str)
fun foo(e) = e.perform("hi")
handle h = Effect with
  fun perform(arg, k) = k(arg)
in
  foo(h)
  (() => h.perform("Hello"))()
//│ Elab: { Cls Effect[A@11](class:Effect.perform: globalThis:import#Prelude#666.Str‹member:Str› -> globalThis:import#Prelude#666.Str‹member:Str›) { }; fun member:foo(Param(‹›,e@12,None)) = e@12#666.perform("hi"); { handle globalThis:block#1.h = Sel(Ref(globalThis:block#1),Ident(Effect)) List(TermDefinition(Some(globalThis:block#1),Fun,member:perform,List(ParamList(‹›,List(Param(‹›,arg@15,None), Param(‹›,k@16,None)))),None,Some(App(Ref(k@16),Tup(List(Fld(‹›,Ref(arg@15),None))))),‹result of member:perform›@18)); { globalThis:block#1#666.foo‹member:foo›(globalThis:block#1.h#666); λ. globalThis:block#1.h#666.perform("Hello")() } } }
//│ JS:
//│ let separator, cur, tmp, res, res1;
//│ separator = undefined;
//│ function Cont$(resume1, resumed1, next1) { return new Cont$.class(resume1, resumed1, next1); };
//│ Cont$.class = class Cont$ {
//│   constructor(resume, resumed, next) {
//│     this.resume = resume;
//│     this.resumed = resumed;
//│     this.next = next;
//│     
//│   }
//│   toString() { return "Cont$(" + this.resume + ", " + this.resumed + ", " + this.next + ")"; }
//│ };
//│ this.Effect = function Effect(perform1) { return new Effect.class(perform1); };
//│ this.Effect.class = class Effect {
//│   constructor(perform) {
//│     this.perform = perform;
//│     
//│   }
//│   toString() { return "Effect(" + this.perform + ")"; }
//│ };
//│ function foo(e) {
//│   let res2;
//│   res2 = e.perform("hi");
//│   if (res2 instanceof globalThis.Cont$.class) {
//│     return res2;
//│   }
//│   res2 = separator(0);
//│   return res2;
//│ }
//│ function perform(arg, k) {
//│   let res2;
//│   res2 = k(arg);
//│   if (res2 instanceof globalThis.Cont$.class) {
//│     return res2;
//│   }
//│   res2 = separator(2);
//│   return res2;
//│ }
//│ handlerBody: while (true) {
//│   this.h = new this.Effect((arg) => {
//│     let cont;
//│     cont = new this.Cont$.class((x) => {
//│       return x;
//│     }, false, undefined);
//│     cont.last = cont;
//│     cont.handler = this.h;
//│     cont.handlerFun = perform;
//│     cont.params = [
//│       arg
//│     ];
//│     return cont;
//│   });
//│   res = this.foo(this.h);
//│   if (res instanceof this.Cont$.class) {
//│     cur = res;
//│     break handlerBody;
//│   }
//│   res = separator(3);
//│   res1 = (() => {
//│     let res2;
//│     res2 = this.h.perform("Hello");
//│     if (res2 instanceof this.Cont$.class) {
//│       return res2;
//│     }
//│     res2 = separator(5);
//│     return res2;
//│   })();
//│   if (res1 instanceof this.Cont$.class) {
//│     cur = res1;
//│     break handlerBody;
//│   }
//│   res1 = separator(4);
//│   cur = res1;
//│   break;
//│ }
//│ cur = separator(1);
//│ handler: while (true) {
//│   if (cur instanceof this.Cont$.class) {
//│     if (cur.handler === undefined) {
//│       tmp = cur.handler === this.h;
//│       if (tmp === undefined) {
//│         cur = cur.handlerFun.apply(null, cur.args);
//│         continue handler;
//│       }
//│     } else {
//│       throw new this.Error("Unhandled effects");
//│     }
//│   }
//│   break;
//│ }
//│ undefined
//│ ═══[RUNTIME ERROR] TypeError: separator is not a function

:sjs
:fixme
fun f() =
  val x = 3
  let y = 5 in
    val x = 5
    x + y
//│ JS:
//│ function f() { let y; const x = 3; y = 5; const x = 5; return x + y; } undefined
//│ ═══[COMPILATION ERROR] [Uncaught SyntaxError] Identifier 'x' has already been declared
