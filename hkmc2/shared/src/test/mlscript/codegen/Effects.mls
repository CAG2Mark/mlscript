:js
:il

// note: seems we can't use traits yet :|
// using a field to store the effect handler instead

// TODO: put resume$ and Cont$ into a Predef (resume$ should not be instrumented) for correctness, as the same Cont$ should be used for all function code

// TODO: use this syntax
// TODO: prepend or append resumption parameter like fun perform(x)(resume): Str -> Str or fun perform(resume)(x): Str -> Str
// Handle the case where the function is defined like fun perform: Str, then e.perform should also yield an effect?
// handle ... fun perform(resume)(x)(y)(z): A = resume(x)
// Dummy handler: fun dummy_perform(x)(y)(z) = { let result = new EffectSig$(h, perform(x)(y)(z)); result.tail = result; return result; }
// resume: A -> ?
// this simplifies current handler code, no need to Array.push anymore
:sjs
abstract class Effect[A] with
  fun perform(x: A): Str -> Str
//│ JS:
//│ function resume$(cont) {
//│   return (value) => {
//│     let cont1, value1;
//│     cont1 = cont;
//│     value1 = value;
//│     chainLoop: while (true) {
//│       if (cont1) {
//│         value1 = cont1.resume(value1);
//│         cont1 = cont1.next;
//│         continue chainLoop;
//│       }
//│       return value1;
//│       break;
//│     }
//│   };
//│ }
//│ this.Cont$ = function Cont$(resume1, resumed1, next1, isCont$1) { return new Cont$.class(resume1, resumed1, next1, isCont$1); };
//│ this.Cont$.class = class Cont$ {
//│   constructor(resume, resumed, next, isCont$) {
//│     this.resume = resume;
//│     this.resumed = resumed;
//│     this.next = next;
//│     this.isCont$ = isCont$;
//│     
//│   }
//│   toString() { return "Cont$(" + this.resume + ", " + this.resumed + ", " + this.next + ", " + this.isCont$ + ")"; }
//│ };
//│ this.Effect = class Effect {
//│   constructor() {
//│     
//│   }
//│   toString() { return "Effect"; }
//│ };
//│ undefined

:expect 'b'
class Effect[A](perform: Str -> Str)
val r = handle h = Effect with
  fun perform(arg, k) = "b"
in
  h.perform("k")
r
//│ r = 'b'

:expect 'k'
class Effect[A](perform: Str -> Str)
val r = handle h = Effect with
  fun perform(arg, k) = arg
in
  h.perform("k")
r
//│ r = 'k'

:expect 'Hello'
class Effect[A](perform: Str -> Str)
fun foo(e) = e.perform("hi")
val r = handle h = Effect with
  fun perform(arg, k) =
    print(arg)
    k(arg)
in
  (() => h.perform("Hello"))()
r
//│ > Hello
//│ r = 'Hello'

:expect 'hi'
class Effect[A](perform: Str -> Str)
fun foo(e) = e.perform("hi")
val r = handle h = Effect with
  fun perform(arg, k) =
    print(arg)
    k(arg)
in
  foo(h)
r
//│ > hi
//│ r = 'hi'

:expect 'hello'
class Effect[A](perform: Str -> Str)
val r = handle h = Effect with
  fun perform(arg, k) =
    print(arg)
    k(arg)
in
  h.perform("hi")
  h.perform("hello")
r
//│ > hi
//│ > hello
//│ r = 'hello'

:expect 'b'
class Effect[A](perform: Str -> Str)
val x =
  handle h = Effect with
    fun perform(arg, k) =
      print(arg)
      "b"
  in
    h.perform("t")
x
//│ > t
//│ x = 'b'

// TODO: val is not working
:expect 'Hello World!'
class Effect[A](perform: Str -> Str)
fun foo(h) =
  print("Entering foo")
  let result = h.perform("Hello")
  print("Exiting foo")
  result
fun bar(h) =
  print("Entering bar")
  let result = foo(h) + " World"
  print("Exiting bar")
  result
fun foobar(h) =
  print("Entering foobar")
  let result = bar(h) + "!"
  print("Exiting foobar")
  result
val x = handle h = Effect with
  fun perform(arg, k) =
    print("handler called")
    let result = k(arg)
    print("handler finished")
    result
in
  print("mainbody start")
  let result = foobar(h)
  print("mainbody end")
  result
x
//│ > mainbody start
//│ > Entering foobar
//│ > Entering bar
//│ > Entering foo
//│ > handler called
//│ > Exiting foo
//│ > Exiting bar
//│ > Exiting foobar
//│ > mainbody end
//│ > handler finished
//│ x = 'Hello World!'

:fixme
:expect 'Hello World!'
class Effect[A](perform: Str -> Str)
fun foo(h) =
  print("Entering foo")
  let result = h.perform("Hello")
  h.perform("Oops!")
  print("Exiting foo")
  result
fun bar(h) =
  print("Entering bar")
  let result = foo(h) + " World"
  print("Exiting bar")
  result
fun foobar(h) =
  print("Entering foobar")
  let result = bar(h) + "!"
  print("Exiting foobar")
  result
val x = handle h = Effect with
  fun perform(arg, k) =
    print("handler called")
    let result = k(arg)
    print("handler finished")
    result
in
  print("mainbody start")
  let result = foobar(h)
  print("mainbody end")
  result
x
//│ > mainbody start
//│ > Entering foobar
//│ > Entering bar
//│ > Entering foo
//│ > handler called
//│ > Exiting bar
//│ > Exiting foobar
//│ > mainbody end
//│ > handler finished
//│ ═══[RUNTIME ERROR] Expected: 'Hello World!', got: 'Cont$(undefined, false, Cont$409$foo, true) World!'

:fixme
:expect 1
class Cell(getVal: () -> Int, setVal: Int -> ())
let x = 0
let k
let m
let res = handle h = Cell with
  fun getVal(k) = k(x)
  fun setVal(value, k) =
    x = value
    k(())
in
  k = h.getVal()
  h.setVal(1)
  m = h.getVal()
k + m
//│ ═══[RUNTIME ERROR] Expected: 1, got: 0
//│ m = 1
//│ x = 1

// weird...?
:expect 1
k + m

class A(x) with
  fun debug() = print(x)
let x = new A(333)
x.debug()
//│ > 333
//│ x = A { x: 333 }

:fixme
fun f() =
  val x = 3
  let y = 5 in
    val x = 5
    x + y
//│ ═══[COMPILATION ERROR] [Uncaught SyntaxError] Identifier 'x' has already been declared

fun f() =
  let x = 2
  let y = f()
  let z = 3
  2

:expect 120
:sjs
fun fact(factvalue) = 
  if factvalue != 0 then
    factvalue * fact(factvalue-1)
  else 1
let result = fact(5)
result
//│ JS:
//│ let res;
//│ function resume$(cont) {
//│   return (value) => {
//│     let cont1, value1;
//│     cont1 = cont;
//│     value1 = value;
//│     chainLoop: while (true) {
//│       if (cont1) {
//│         value1 = cont1.resume(value1);
//│         cont1 = cont1.next;
//│         continue chainLoop;
//│       }
//│       return value1;
//│       break;
//│     }
//│   };
//│ }
//│ this.Cont$ = function Cont$(resume1, resumed1, next1, isCont$1) { return new Cont$.class(resume1, resumed1, next1, isCont$1); };
//│ this.Cont$.class = class Cont$ {
//│   constructor(resume, resumed, next, isCont$) {
//│     this.resume = resume;
//│     this.resumed = resumed;
//│     this.next = next;
//│     this.isCont$ = isCont$;
//│     
//│   }
//│   toString() { return "Cont$(" + this.resume + ", " + this.resumed + ", " + this.next + ", " + this.isCont$ + ")"; }
//│ };
//│ function fact(factvalue) {
//│   let scrut, res1, tmp, tmp1;
//│   class Cont$613$fact {
//│     constructor() {
//│       
//│     }
//│     resume(value$) {
//│       let tmp2;
//│       if (this.pc$0 === 1) {
//│         this.res$0 = value$;
//│       } else {
//│       }
//│       contLoop: while (true) {
//│         if (this.pc$0 === 2) {
//│           this.scrut$0 = factvalue != 0;
//│           if (this.scrut$0) {
//│             this.tmp$0 = factvalue - 1;
//│             this.res$0 = globalThis.fact(this.tmp$0);
//│             if (this.res$0) {
//│               if (this.res$0.isCont$) {
//│                 this.tmp$0 = new Cont$613$fact(1, undefined);
//│                 this.tmp$0.pc$0 = 1;
//│                 this.tmp$0.isCont$ = true;
//│                 this.res$0.tail.next = this.tmp$0;
//│                 this.res$0.tail = this.tmp$0;
//│                 return this.res$0;
//│               }
//│               this.pc$0 = 1;
//│               continue contLoop;
//│             }
//│             this.pc$0 = 1;
//│             continue contLoop;
//│           } else {
//│             return 1;
//│           }
//│           break contLoop;
//│         } else {
//│           if (this.pc$0 === 1) {
//│             tmp2 = factvalue * this.res$0;
//│             this.pc$0 = 3;
//│             continue contLoop;
//│           } else {
//│             if (this.pc$0 === 3) {
//│               return tmp2;
//│             }
//│           }
//│         }
//│         break;
//│       }
//│     }
//│     toString() { return "Cont$613$fact"; }
//│   }
//│   scrut = factvalue != 0;
//│   if (scrut) {
//│     tmp1 = factvalue - 1;
//│     res1 = globalThis.fact(tmp1);
//│     if (res1) {
//│       if (res1.isCont$) {
//│         tmp = new Cont$613$fact(1, undefined);
//│         tmp.pc$0 = 1;
//│         tmp.isCont$ = true;
//│         res1.tail.next = tmp;
//│         res1.tail = tmp;
//│         return res1;
//│       }
//│     }
//│     return factvalue * res1;
//│   } else {
//│     return 1;
//│   }
//│ }
//│ res = this.fact(5);
//│ if (res) {
//│   if (res.isCont$) {
//│     throw new this.Error("Unhandled effects");
//│   }
//│ }
//│ this.result = res;
//│ undefined
//│ result = 120

// stack safe recursion
:expect 5050
class StackDelay(raise: () -> ())
handle h = StackDelay with
  fun raise(k) =
    print("stack unwinded")
    k(10)
fun sum(depth, x) =
  val new_depth = if depth > 70 then h.raise() else depth + 1
  if x != 0 then
    x + sum(new_depth, x - 1)
  else 0
let result = sum(0, 100)
result
//│ > stack unwinded
//│ result = 5050

// stack safe recursion
:fixme
:expect 5050
class StackDelay(raise: () -> ())
handle h = StackDelay with
  fun raise(k) =
    print("stack unwinded")
    k(10)
fun sum(depth, x) =
  val new_depth = if depth > 30 then h.raise() else depth + 1
  if x != 0 then
    x + sum(new_depth, x - 1)
  else 0
let result = sum(0, 100)
result
//│ > stack unwinded
//│ ═══[RUNTIME ERROR] Expected: 5050, got: '100999897969594939291908988878685848382818079787776757473727170Cont$(undefined, false, Cont$732$sum, true)'
