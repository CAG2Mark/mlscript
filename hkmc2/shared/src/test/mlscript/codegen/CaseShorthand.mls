:js


:fixme
case x then x
//│ ╔══[PARSE ERROR] Expected block after `case` keyword; found identifier instead
//│ ║  l.5: 	case x then x
//│ ╙──     	     ^
//│ /!!!\ Uncaught error: scala.MatchError: InfixApp(Jux(Error(),Ident(x)),keyword 'then',Ident(x)) (of class hkmc2.syntax.Tree$InfixApp)

:sjs
case { x then x }
//│ JS:
//│ (...args) => {
//│   globalThis.Predef.checkArgs("", 1, true, args.length);
//│   let caseScrut = args[0];
//│   let x;
//│   x = caseScrut;
//│   return x;
//│ }
//│ = [Function (anonymous)]

:sjs
x => if x is
  0 then true
//│ JS:
//│ (...args) => {
//│   globalThis.Predef.checkArgs("", 1, true, args.length);
//│   let x = args[0];
//│   if (x === 0) {
//│     return true;
//│   } else {
//│     throw new this.Error("match error");
//│   }
//│ }
//│ = [Function (anonymous)]

:sjs
case
  0 then true
//│ JS:
//│ (...args) => {
//│   globalThis.Predef.checkArgs("", 1, true, args.length);
//│   let caseScrut = args[0];
//│   if (caseScrut === 0) {
//│     return true;
//│   } else {
//│     throw new this.Error("match error");
//│   }
//│ }
//│ = [Function (anonymous)]

:sjs
case
  0 then true
  _ then false
//│ JS:
//│ (...args) => {
//│   globalThis.Predef.checkArgs("", 1, true, args.length);
//│   let caseScrut = args[0];
//│   if (caseScrut === 0) {
//│     return true;
//│   } else {
//│     return false;
//│   }
//│ }
//│ = [Function (anonymous)]

class Some(value)
module None

:sjs
val isDefined = case
  Some then true
  None then false
//│ JS:
//│ this.isDefined = (...args) => {
//│   globalThis.Predef.checkArgs("", 1, true, args.length);
//│   let caseScrut = args[0];
//│   if (caseScrut instanceof this.Some.class) {
//│     return true;
//│   } else {
//│     if (caseScrut instanceof this.None.class) {
//│       return false;
//│     } else {
//│       throw new this.Error("match error");
//│     }
//│   }
//│ };
//│ undefined
//│ isDefined = [Function (anonymous)]

