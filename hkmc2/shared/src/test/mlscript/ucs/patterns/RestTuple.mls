:js

// Drop the first and last elements.
tupleSlice([1, 2, 3, 4], 1, -1)
//│ = [ 2, 3, 4 ]

// Get the first element.
tupleGet([1, 2, 3, 4], 0)
//│ = 1

// Get the last element.
tupleGet([1, 2, 3, 4], -1)
//│ = 4

:sjs
fun nonsense(xs) = if xs is
  [..ys] then ys
  [] then "empty"
//│ JS:
//│ function nonsense(...args) {
//│   globalThis.Predef.checkArgs("nonsense", 1, args.length);
//│   let xs = args[0];
//│   let rest, ys;
//│   if (globalThis.Array.isArray(xs) && xs.length >= 0) {
//│     rest = globalThis.Predef.tupleSlice(xs, 0, 0);
//│     ys = rest;
//│     return ys;
//│   } else {
//│     throw new globalThis.Error("match error");
//│   }
//│ }
//│ undefined

nonsense([])
//│ = []

nonsense([1, 2, 3, 4])
//│ = [ 1, 2, 3, 4 ]

:sjs
fun lead_and_last(xs) = if xs is
  [x, ..ys, y] then x + y
  [] then 0
//│ JS:
//│ function lead_and_last(...args) {
//│   globalThis.Predef.checkArgs("lead_and_last", 1, args.length);
//│   let xs = args[0];
//│   let last0, rest, first0, x, ys, y;
//│   if (globalThis.Array.isArray(xs) && xs.length >= 2) {
//│     first0 = xs[0];
//│     rest = globalThis.Predef.tupleSlice(xs, 1, 1);
//│     last0 = globalThis.Predef.tupleGet(xs, -1);
//│     x = first0;
//│     ys = rest;
//│     y = last0;
//│     return x + y;
//│   } else {
//│     if (globalThis.Array.isArray(xs) && xs.length === 0) {
//│       return 0;
//│     } else {
//│       throw new globalThis.Error("match error");
//│     }
//│   }
//│ }
//│ undefined

lead_and_last(["foo", "bar"])
//│ = 'foobar'

lead_and_last([1, 2, 3, 4])
//│ = 5

lead_and_last([])
//│ = 0

:re
lead_and_last(["boom"])
//│ ═══[RUNTIME ERROR] Error: match error

:sjs
fun nested_tuple_patterns(xs) = if xs is
  [x, ..[y, z], w] then x + y + z + w
  [] then 0
//│ JS:
//│ function nested_tuple_patterns(...args) {
//│   globalThis.Predef.checkArgs("nested_tuple_patterns", 1, args.length);
//│   let xs = args[0];
//│   let last0, rest, first0, x, first1, first01, y, z, w, tmp, tmp1;
//│   if (globalThis.Array.isArray(xs) && xs.length >= 2) {
//│     first0 = xs[0];
//│     rest = globalThis.Predef.tupleSlice(xs, 1, 1);
//│     last0 = globalThis.Predef.tupleGet(xs, -1);
//│     x = first0;
//│     if (globalThis.Array.isArray(rest) && rest.length === 2) {
//│       first01 = rest[0];
//│       first1 = rest[1];
//│       y = first01;
//│       z = first1;
//│       w = last0;
//│       tmp = x + y;
//│       tmp1 = tmp + z;
//│       return tmp1 + w;
//│     } else {
//│       throw new globalThis.Error("match error");
//│     }
//│   } else {
//│     if (globalThis.Array.isArray(xs) && xs.length === 0) {
//│       return 0;
//│     } else {
//│       throw new globalThis.Error("match error");
//│     }
//│   }
//│ }
//│ undefined

fun hack(tupleSlice) = if tupleSlice is
  [..tupleGet, x] then x

:expect 4
hack([1, 2, 3, 4])
//│ = 4
