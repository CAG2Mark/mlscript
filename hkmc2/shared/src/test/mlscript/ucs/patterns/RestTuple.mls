:js
:ucs desugared

// Drop the first and last elements.
tupleSlice([1, 2, 3, 4], 1, -1)
//│ = [ 2, 3, 4 ]

// Get the first element.
tupleGet([1, 2, 3, 4], 0)
//│ = 1

// Get the last element.
tupleGet([1, 2, 3, 4], -1)
//│ = 4

:sjs
fun nonsense(xs) = if xs is
  [..ys] then ys
  [] then "empty"
//│ Desugared:
//│ >  if
//│ >    xs@26 is []>=0 and
//│ >      let $rest@27 = globalThis:globalThis#666.Predef.tupleSlice(xs@26#2, 0, 0)
//│ >      let ys@28 = $rest@27#0
//│ >      else ys@28#666
//│ >    xs@26 is []=0 then "empty"
//│ JS:
//│ function nonsense(xs) {
//│   let rest, ys;
//│   if (globalThis.Array.isArray(xs) && xs.length >= 0) {
//│     rest = globalThis.Predef.tupleSlice(xs, 0, 0);
//│     ys = rest;
//│     return ys;
//│   } else {
//│     throw new globalThis.Error("match error");
//│   }
//│ }
//│ undefined

nonsense([])
//│ = []

nonsense([1, 2, 3, 4])
//│ = [ 1, 2, 3, 4 ]

:sjs
fun lead_and_last(xs) = if xs is
  [x, ..ys, y] then x + y
  [] then 0
//│ Desugared:
//│ >  if
//│ >    xs@38 is []>=2 and
//│ >      let $first0@41 = xs@38#2.0
//│ >      let $rest@40 = globalThis:globalThis#666.Predef.tupleSlice(xs@38#3, 1, 1)
//│ >      let $last0@39 = globalThis:globalThis#666.Predef.tupleGet(xs@38#4, -1)
//│ >      let x@42 = $first0@41#0
//│ >      let ys@43 = $rest@40#0
//│ >      let y@44 = $last0@39#0
//│ >      else builtin:+#0(x@42#666, y@44#666)
//│ >    xs@38 is []=0 then 0
//│ JS:
//│ function lead_and_last(xs) {
//│   let last0, rest, first0, x, ys, y;
//│   if (globalThis.Array.isArray(xs) && xs.length >= 2) {
//│     first0 = xs[0];
//│     rest = globalThis.Predef.tupleSlice(xs, 1, 1);
//│     last0 = globalThis.Predef.tupleGet(xs, -1);
//│     x = first0;
//│     ys = rest;
//│     y = last0;
//│     return x + y;
//│   } else {
//│     if (globalThis.Array.isArray(xs) && xs.length === 0) {
//│       return 0;
//│     } else {
//│       throw new globalThis.Error("match error");
//│     }
//│   }
//│ }
//│ undefined

lead_and_last(["foo", "bar"])
//│ = 'foobar'

lead_and_last([1, 2, 3, 4])
//│ = 5

lead_and_last([])
//│ = 0

:re
lead_and_last(["boom"])
//│ ═══[RUNTIME ERROR] Error: match error

:sjs
fun nested_tuple_patterns(xs) = if xs is
  [x, ..[y, z], w] then x + y + z + w
  [] then 0
//│ Desugared:
//│ >  if
//│ >    xs@63 is []>=2 and
//│ >      let $first0@66 = xs@63#2.0
//│ >      let $rest@65 = globalThis:globalThis#666.Predef.tupleSlice(xs@63#3, 1, 1)
//│ >      let $last0@64 = globalThis:globalThis#666.Predef.tupleGet(xs@63#4, -1)
//│ >      let x@67 = $first0@66#0
//│ >      $rest@65 is []=2 and
//│ >        let $first0@69 = $rest@65#1.0
//│ >        let $first1@68 = $rest@65#2.1
//│ >        let y@70 = $first0@69#0
//│ >        let z@71 = $first1@68#0
//│ >        let w@72 = $last0@64#0
//│ >        else builtin:+#0(builtin:+#1(builtin:+#2(x@67#666, y@70#666), z@71#666), w@72#666)
//│ >    xs@63 is []=0 then 0
//│ JS:
//│ function nested_tuple_patterns(xs) {
//│   let last0, rest, first0, x, first1, first01, y, z, w, tmp, tmp1;
//│   if (globalThis.Array.isArray(xs) && xs.length >= 2) {
//│     first0 = xs[0];
//│     rest = globalThis.Predef.tupleSlice(xs, 1, 1);
//│     last0 = globalThis.Predef.tupleGet(xs, -1);
//│     x = first0;
//│     if (globalThis.Array.isArray(rest) && rest.length === 2) {
//│       first01 = rest[0];
//│       first1 = rest[1];
//│       y = first01;
//│       z = first1;
//│       w = last0;
//│       tmp = x + y;
//│       tmp1 = tmp + z;
//│       return tmp1 + w;
//│     } else {
//│       throw new globalThis.Error("match error");
//│     }
//│   } else {
//│     if (globalThis.Array.isArray(xs) && xs.length === 0) {
//│       return 0;
//│     } else {
//│       throw new globalThis.Error("match error");
//│     }
//│   }
//│ }
//│ undefined

fun hack(tupleSlice) = if tupleSlice is
  [..tupleGet, x] then x
//│ Desugared:
//│ >  if tupleSlice@85 is []>=1 and
//│ >    let $rest@87 = globalThis:globalThis#666.Predef.tupleSlice(tupleSlice@85#1, 0, 1)
//│ >    let $last0@86 = globalThis:globalThis#666.Predef.tupleGet(tupleSlice@85#2, -1)
//│ >    let tupleGet@88 = $rest@87#0
//│ >    let x@89 = $last0@86#0
//│ >    else x@89#666

:expect 4
hack([1, 2, 3, 4])
//│ = 4
