:js

// We test the support for simple tuple patterns in this file.
// Splice tuple patterns will be implement in the future.

fun sum(x, y) = x + y
sum(1, 2)
//│ = 3

:fixme
fun sum([x, y]) = x + y
sum([1, 2])
//│ /!!!\ Uncaught error: scala.MatchError: Tup(List(Ident(x), Ident(y))) (of class hkmc2.syntax.Tree$Tup)

:ucs desugared
fun sum(pair) =
  if pair is [x, y] then x + y
sum([1, 2])
//│ Desugared:
//│ >  if pair@20 is []=2 and
//│ >    let $first0@22 = pair@20#1.0
//│ >    let $first1@21 = pair@20#2.1
//│ >    let x@23 = $first0@22#0
//│ >    let y@24 = $first1@21#0
//│ >    else builtin:+#0(x@23#666, y@24#666)
//│ = 3

:ucs desugared
fun test(thing) =
  if thing is [] then 0
//│ Desugared:
//│ >  if thing@31 is []=0 then 0

:re
test("")
//│ ═══[RUNTIME ERROR] Error: match error

:re
test(12)
//│ ═══[RUNTIME ERROR] Error: match error

class Point(x: Int, y: Int)

:ucs desugared
fun with_other_constructors(thing) =
  if thing is
    [x, y] then x * y
    Point(x, y) then x + y
//│ Desugared:
//│ >  if
//│ >    thing@41 is []=2 and
//│ >      let $first0@48 = thing@41#2.0
//│ >      let $first1@47 = thing@41#3.1
//│ >      let x@49 = $first0@48#0
//│ >      let y@50 = $first1@47#0
//│ >      else builtin:*#0(x@49#666, y@50#666)
//│ >    thing@41 is Point($param0@42, $param1@43) and
//│ >      let x@44 = $param0@42#0
//│ >      let y@45 = $param1@43#0
//│ >      else builtin:+#0(x@44#666, y@45#666)

:expect 7
with_other_constructors(Point(3, 4))
//│ = 7

:expect 12
with_other_constructors([3, 4])
//│ = 12

// A workaround is to move the tuple pattern to the last case.
:ucs desugared
fun with_other_constructors(thing) =
  if thing is
    Point(x, y) then x + y
    [x, y] then x * y
//│ Desugared:
//│ >  if
//│ >    thing@65 is Point($param0@71, $param1@72) and
//│ >      let x@73 = $param0@71#0
//│ >      let y@74 = $param1@72#0
//│ >      else builtin:+#0(x@73#666, y@74#666)
//│ >    thing@65 is []=2 and
//│ >      let $first0@67 = thing@65#1.0
//│ >      let $first1@66 = thing@65#2.1
//│ >      let x@68 = $first0@67#0
//│ >      let y@69 = $first1@66#0
//│ >      else builtin:*#0(x@68#666, y@69#666)

:expect 7
with_other_constructors(Point(3, 4))
//│ = 7

:expect 12
with_other_constructors([3, 4])
//│ = 12


fun with_else(x) =
  if x is
    [a, b, c] then
      a + b + c
    else
      0

with_else([1, 2, 3])
//│ = 6

with_else([1, 2])
//│ = 0

:ucs desugared
fun match_against_different_length(xs) =
  if xs is
    [] then 0
    [x] then x + 1
    [x, y] then x + y + 2
    [x, y, z] then x + y + z + 3
//│ Desugared:
//│ >  if
//│ >    xs@109 is []=0 then 0
//│ >    xs@109 is []=1 and
//│ >      let $first0@112 = xs@109#8.0
//│ >      let x@123 = $first0@112#2
//│ >      else builtin:+#5(x@123#666, 1)
//│ >    xs@109 is []=2 and
//│ >      let $first0@112 = xs@109#5.0
//│ >      let $first1@111 = xs@109#6.1
//│ >      let x@119 = $first0@112#1
//│ >      let y@120 = $first1@111#1
//│ >      else builtin:+#3(builtin:+#4(x@119#666, y@120#666), 2)
//│ >    xs@109 is []=3 and
//│ >      let $first0@112 = xs@109#1.0
//│ >      let $first1@111 = xs@109#2.1
//│ >      let $first2@110 = xs@109#3.2
//│ >      let x@113 = $first0@112#0
//│ >      let y@114 = $first1@111#0
//│ >      let z@115 = $first2@110#0
//│ >      else builtin:+#0(builtin:+#1(builtin:+#2(x@113#666, y@114#666), z@115#666), 3)

:expect 0
match_against_different_length([])
//│ = 0

:expect 18
match_against_different_length([17])
//│ = 18

:expect 22
match_against_different_length([9, 11])
//│ = 22

:expect 42
match_against_different_length([13, 13, 13])
//│ = 42

import "../../../mlscript-compile/Option.mls"

open Option

:ucs desugared normalized
:todo // Sub-scrutinees are not memorized thus the normalization is not correct.
fun with_the_common_prefix(xs) =
  if xs is
    [Some(x)] then x + 1
    [None] then 0
//│ Desugared:
//│ >  if
//│ >    xs@150 is []=1 and
//│ >      let $first0@151 = xs@150#3.0
//│ >      $first0@151 is Some($param0@152) and
//│ >        let x@153 = $param0@152#0
//│ >        else builtin:+#0(x@153#666, 1)
//│ >    xs@150 is []=1 and
//│ >      let $first0@151 = xs@150#1.0
//│ >      $first0@151 is None then 0
//│ Normalized:
//│ >  if xs@150 is []=1 and
//│ >    let $first0@151 = xs@150#3.0
//│ >    $first0@151 is Some($param0@152) and
//│ >      let x@153 = $param0@152#0
//│ >      else builtin:+#0(x@153#666, 1)
//│ >    $first0@151 is None then 0
