:js
:ucs desugared normalized

import "../../../mlscript-compile/Option.mls"

open Option

// Normalization should unify fixed-length tuple patterns.
fun sum_options(x, y) =
  if [x, y] is
    [Some(xv), Some(yv)] then xv + yv
    [Some(xv), None]     then xv
    [None,     Some(yv)] then yv
    [None,     None]     then 0
//│ Desugared:
//│ >  if
//│ >    let $scrut@15 = [x@13#666, y@14#666]
//│ >    $scrut@15 is []=2 and
//│ >      let $first0@17 = $scrut@15#10.0
//│ >      let $first1@16 = $scrut@15#11.1
//│ >      $first0@17 is Some($param0@20) and
//│ >        let xv@22 = $param0@20#1
//│ >        $first1@16 is Some($param0@18) and
//│ >          let yv@23 = $param0@18#1
//│ >          else builtin:+#0(xv@22#666, yv@23#666)
//│ >    $scrut@15 is []=2 and
//│ >      let $first0@17 = $scrut@15#7.0
//│ >      let $first1@16 = $scrut@15#8.1
//│ >      $first0@17 is Some($param0@20) and
//│ >        let xv@21 = $param0@20#0
//│ >        $first1@16 is None then xv@21#666
//│ >    $scrut@15 is []=2 and
//│ >      let $first0@17 = $scrut@15#4.0
//│ >      let $first1@16 = $scrut@15#5.1
//│ >      $first0@17 is None and $first1@16 is Some($param0@18) and
//│ >        let yv@19 = $param0@18#0
//│ >        else yv@19#666
//│ >    $scrut@15 is []=2 and
//│ >      let $first0@17 = $scrut@15#1.0
//│ >      let $first1@16 = $scrut@15#2.1
//│ >      $first0@17 is None $first1@16 is None then 0
//│ Normalized:
//│ >  if
//│ >    let $scrut@15 = [x@13#666, y@14#666]
//│ >    $scrut@15 is []=2 and
//│ >      let $first0@17 = $scrut@15#10.0
//│ >      let $first1@16 = $scrut@15#11.1
//│ >      $first0@17 is Some($param0@20) and
//│ >        let xv@22 = $param0@20#1
//│ >        $first1@16 is Some($param0@18) and
//│ >          let yv@23 = $param0@18#1
//│ >          else builtin:+#0(xv@22#666, yv@23#666)
//│ >        let xv@21 = $param0@20#0
//│ >        $first1@16 is None then xv@21#666
//│ >      $first0@17 is None and
//│ >        $first1@16 is Some($param0@18) and
//│ >          let yv@19 = $param0@18#0
//│ >          else yv@19#666
//│ >        $first1@16 is None then 0




// ========================================================================== //


// Normalization should also unify the sub-scrutinees at the same position of
// tuple patterns of different lengths.


fun foo(xs) = if xs is
  [Some(x)] then x
  [Some(y), ..rest] then y
//│ Desugared:
//│ >  if
//│ >    xs@28 is []=1 and
//│ >      let $first0@30 = xs@28#4.0
//│ >      $first0@30 is Some($param0@31) and
//│ >        let x@34 = $param0@31#1
//│ >        else x@34#666
//│ >    xs@28 is []>=1 and
//│ >      let $first0@30 = xs@28#1.0
//│ >      let $rest@29 = member:Predef#666.tupleSlice‹member:tupleSlice›(xs@28#2, 1, 0)
//│ >      $first0@30 is Some($param0@31) and
//│ >        let y@32 = $param0@31#0
//│ >        let rest@33 = $rest@29#0
//│ >        else y@32#666
//│ Normalized:
//│ >  if
//│ >    xs@28 is []=1 and
//│ >      let $first0@30 = xs@28#4.0
//│ >      $first0@30 is Some($param0@31) and
//│ >        let x@34 = $param0@31#1
//│ >        else x@34#666
//│ >      let $rest@29 = member:Predef#666.tupleSlice‹member:tupleSlice›(xs@28#2, 1, 0)
//│ >    xs@28 is []>=1 and
//│ >      let $first0@30 = xs@28#1.0
//│ >      let $rest@29 = member:Predef#666.tupleSlice‹member:tupleSlice›(xs@28#2, 1, 0)
//│ >      $first0@30 is Some($param0@31) and
//│ >        let y@32 = $param0@31#0
//│ >        let rest@33 = $rest@29#0
//│ >        else y@32#666

fun do_something(x) = "done"


fun foo(zs) = if zs is
  [Some(x), Some(y)] then x + y
  [None, ..rest] then do_something(rest)
//│ Desugared:
//│ >  if
//│ >    zs@42 is []=2 and
//│ >      let $first0@44 = zs@42#4.0
//│ >      let $first1@47 = zs@42#5.1
//│ >      $first0@44 is Some($param0@48) and
//│ >        let x@49 = $param0@48#0
//│ >        $first1@47 is Some($param0@50) and
//│ >          let y@51 = $param0@50#0
//│ >          else builtin:+#0(x@49#666, y@51#666)
//│ >    zs@42 is []>=1 and
//│ >      let $first0@44 = zs@42#1.0
//│ >      let $rest@43 = member:Predef#666.tupleSlice‹member:tupleSlice›(zs@42#2, 1, 0)
//│ >      $first0@44 is None and
//│ >        let rest@45 = $rest@43#0
//│ >        else globalThis:block#5#666.do_something‹member:do_something›(rest@45#666)
//│ Normalized:
//│ >  if
//│ >    zs@42 is []=2 and
//│ >      let $first0@44 = zs@42#4.0
//│ >      let $first1@47 = zs@42#5.1
//│ >      $first0@44 is Some($param0@48) and
//│ >        let x@49 = $param0@48#0
//│ >        $first1@47 is Some($param0@50) and
//│ >          let y@51 = $param0@50#0
//│ >          else builtin:+#0(x@49#666, y@51#666)
//│ >        let $rest@43 = member:Predef#666.tupleSlice‹member:tupleSlice›(zs@42#2, 1, 0)
//│ >      let $rest@43 = member:Predef#666.tupleSlice‹member:tupleSlice›(zs@42#2, 1, 0)
//│ >      $first0@44 is None and
//│ >        let rest@45 = $rest@43#0
//│ >        else globalThis:block#5#666.do_something‹member:do_something›(rest@45#666)
//│ >    zs@42 is []>=1 and
//│ >      let $first0@44 = zs@42#1.0
//│ >      let $rest@43 = member:Predef#666.tupleSlice‹member:tupleSlice›(zs@42#2, 1, 0)
//│ >      $first0@44 is None and
//│ >        let rest@45 = $rest@43#0
//│ >        else globalThis:block#5#666.do_something‹member:do_something›(rest@45#666)

:expect 4
foo([Some(1), Some(3)])
//│ = 4

:expect 'done'
foo([None, Some(1), Some(2)])
//│ = 'done'

:re
foo([Some(0)])
//│ ═══[RUNTIME ERROR] Error: match error

:re
foo([Some(0), Some(1), Some(2)])
//│ ═══[RUNTIME ERROR] Error: match error

:re
foo([])
//│ ═══[RUNTIME ERROR] Error: match error
