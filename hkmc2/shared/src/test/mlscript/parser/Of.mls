:parseOnly


f of ()
//│ Parsed:
//│ 	App(Ident(f),Tup(List(UnitLit(true))))

f of 1
//│ Parsed:
//│ 	App(Ident(f),Tup(List(IntLit(1))))

f of (1)
//│ Parsed:
//│ 	App(Ident(f),Tup(List(IntLit(1))))

f of 1, 2
//│ Parsed:
//│ 	App(Ident(f),Tup(List(IntLit(1), IntLit(2))))

f of 1, 2, 3
//│ Parsed:
//│ 	App(Ident(f),Tup(List(IntLit(1), IntLit(2), IntLit(3))))

f of (1, 2, 3)
//│ Parsed:
//│ 	App(Ident(f),Tup(List(Block(List(IntLit(1), IntLit(2), IntLit(3))))))

f of g(1)
//│ Parsed:
//│ 	App(Ident(f),Tup(List(App(Ident(g),Tup(List(IntLit(1)))))))

f of g of 1
//│ Parsed:
//│ 	App(Ident(f),Tup(List(App(Ident(g),Tup(List(IntLit(1)))))))

(f of g) of 1
//│ Parsed:
//│ 	App(App(Ident(f),Tup(List(Ident(g)))),Tup(List(IntLit(1))))

(f of g)(1)
//│ Parsed:
//│ 	App(App(Ident(f),Tup(List(Ident(g)))),Tup(List(IntLit(1))))

f of (g)(1)
//│ Parsed:
//│ 	App(Ident(f),Tup(List(App(Ident(g),Tup(List(IntLit(1)))))))


f of
  1,
  2,
  3
//│ Parsed:
//│ 	App(Ident(f),Tup(List(IntLit(1), IntLit(2), IntLit(3))))

f of
  1
  2
  3
//│ Parsed:
//│ 	App(Ident(f),Tup(List(IntLit(1), IntLit(2), IntLit(3))))


:pe
log
of 1
//│ ╔══[PARSE ERROR] Expected 'let' keyword, 'set' keyword, 'new' keyword, 'in' keyword, 'if' keyword, 'else' keyword, 'case' keyword, 'region' keyword, 'fun' keyword, 'val' keyword, 'type' keyword, 'class' keyword, 'trait' keyword, 'module' keyword, 'open' keyword, 'abstract' keyword, 'mut' keyword, 'virtual' keyword, 'override' keyword, 'declare' keyword, 'public' keyword, 'private' keyword, 'out' keyword, 'return' keyword, 'import' keyword, expression, 'true' keyword, or 'false' keyword after start of statement; found 'of' keyword instead
//│ ║  l.66: 	of 1
//│ ╙──      	^^
//│ ╔══[PARSE ERROR] Expected end of input; found literal instead
//│ ║  l.66: 	of 1
//│ ╙──      	   ^
//│ Parsed:
//│ 	Ident(log)
//│ 	Error()


