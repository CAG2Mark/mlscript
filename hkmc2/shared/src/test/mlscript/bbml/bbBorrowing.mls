:global
:bbml


class Reg[Rg, Br]
//│ Type: ⊤

// fun letreg: [E,Outer,Res] -> ([R] -> Reg[R, Out] ->{E | R} Res) ->{E} Res

fun letreg: [E, Res] -> ([Rg] -> Reg[Rg, E] ->{E | Rg} Res) ->{E} Res
//│ Type: ⊤

letreg
//│ Type: forall α1_2, α2_2: (forall α3_3: (Reg[α3_3, α1_2]) ->{α1_2 ∨ α3_3} α2_2) ->{α1_2} α2_2

fun use: [Rg, Br] -> Reg[Rg, Br] ->{Rg} Int
//│ Type: ⊤


class MutVec[A, Rg, Br]
//│ Type: ⊤

fun mkVec: [A, Rg, Br] -> Reg[Rg, Br] -> MutVec[A, Rg, Br]
//│ Type: ⊤

fun clear: [A, Rg, Br] -> MutVec[A, Rg, Br] ->{Rg} Int
//│ Type: ⊤

clear
//│ Type: forall α9_2, α10_2, α11_2: (MutVec[α9_2, α10_2, α11_2]) ->{α10_2} Int

class Iter[A, Rg]
//│ Type: ⊤

fun iterate: [A, Rg, Br, Res] -> MutVec[A, Rg, Br] -> (Iter[A, Br] ->{Br} Res) ->{Br} Res
//│ Type: ⊤

fun integers: [Rg, Br, Res] -> Reg[Rg, Br] ->{Rg} (Iter[Int, Br] ->{Br} Res) ->{Br} Res
//│ Type: ⊤


fun next: [A, Br] -> Iter[A, Br] ->{Br} A
//│ Type: ⊤

letreg(r => r)
//│ Type: Reg[?, α21_1]
//│ Where:
//│   α21_1 <: <α>0_0

letreg of r =>
  let b = mkVec(r)
  clear(b)
  iterate(b) of it =>
    next(it)
    123
  clear(b)
  r
//│ Type: Reg[?, α23_1]
//│ Where:
//│   α23_1 <: <α>0_0

:e
letreg of r =>
  let b = mkVec(r)
  clear(b)
  iterate(b) of it =>
    next(it)
    clear(b)
    123
  clear(b)
  r
//│ ╔══[ERROR] Type error in term { letreg#3(λr@85. { let b@86 = mkVec#1(r@85#0); clear#3(b@86#0); iterate#1(b@86#1)(λit@91. { next#1(it@91#0); clear#4(b@86#2); 123 }); clear#5(b@86#3); r@85#1 }) }
//│ ╟── because: cannot constrain  α40_1  <:  <α>0_0
//│ ╙── because: cannot constrain  ⊤  <:  <α>0_0
//│ Type: Reg[?, α40_1]
//│ Where:
//│   ⊤ <: α40_1
//│   α40_1 <: <α>0_0


letreg of r =>
  use(r)
  integers(r) of it =>
    next(it)
  use(r)
  r
//│ Type: Reg[?, α60_1]
//│ Where:
//│   α60_1 <: <α>0_0

:e
letreg of r =>
  use(r)
  integers(r) of it =>
    use(r)
    next(it)
  use(r)
  r
//│ ╔══[ERROR] Type error in term { letreg#5(λr@106. { use#2(r@106#0); integers#1(r@106#1)(λit@110. { use#3(r@106#2); next#3(it@110#0) }); use#4(r@106#3); r@106#4 }) }
//│ ╟── because: cannot constrain  α71_1  <:  <α>0_0
//│ ╙── because: cannot constrain  ⊤  <:  <α>0_0
//│ Type: Reg[?, α71_1]
//│ Where:
//│   ⊤ <: α71_1
//│   α71_1 <: <α>0_0

letreg of r0 =>
  letreg of r1 =>
    integers(r1) of it =>
      use(r0)
      next(it)
    use(r1)
    r1
//│ Type: Reg[?, in α97_1]
//│ Where:
//│   α97_1 <: <α>0_0

