:bbml
//│ Type: ⊤


class Reg[Rg, Br]
//│ Type: ⊤

fun letreg: [E, Res] -> ([Rg] -> Reg[Rg, E] ->{E | Rg} Res) ->{E} Res
//│ Type: ⊤

fun use: [Rg, Br] -> Reg[Rg, Br] ->{Rg} Int
//│ Type: ⊤


class MutVec[A, Rg, Br]
//│ Type: ⊤

fun mkVec: [A, Rg, Br] -> Reg[Rg, Br] -> MutVec[A, Rg, Br]
//│ Type: ⊤

fun clear: [A, Rg, Br] -> MutVec[A, Rg, Br] ->{Rg} Int
//│ Type: ⊤

class Iter[A, Rg]
//│ Type: ⊤

fun iterate: [A, Rg, Br, Res] -> MutVec[A, Rg, Br] -> ([L] -> Iter[A, Br | L] ->{Br | L} Res) ->{Br} Res
//│ Type: ⊤

fun integers: [Rg, Br, Res] -> Reg[Rg, Br] ->{Rg} (Iter[Int, Br] ->{Br} Res) ->{Br} Res
//│ Type: ⊤


fun next: [A, Br] -> Iter[A, Br] ->{Br} A
//│ Type: ⊤

letreg(r => r)
//│ Type: Reg[?, E23_1]
//│ Where:
//│   E23_1 <: Alloc

letreg of r =>
  let b = mkVec(r)
  clear(b)
  iterate(b) of it =>
    next(it)
    123
  clear(b)
  r
//│ Type: Reg[?, E28_1]
//│ Where:
//│   E28_1 <: Alloc


// * Non-lexical borrowing pattern encoded with a thunk
letreg of r =>
  let b = mkVec(r)
  clear(b)
  let k = iterate(b) of it =>
    next(it)
    123
    if next(it) > 0 then () => 0 else () => clear(b)
  k()
//│ Type: Int

:e
letreg of r =>
  let b = mkVec(r)
  clear(b)
  let k = iterate(b) of it =>
    next(it)
    123
    () => next(it)
  k()
//│ ╔══[ERROR] Type error in block
//│ ║  l.67: 	letreg of r =>
//│ ║        	^^^^^^^^^^^^^^
//│ ║  l.68: 	  let b = mkVec(r)
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ║  l.69: 	  clear(b)
//│ ║        	^^^^^^^^^^
//│ ║  l.70: 	  let k = iterate(b) of it =>
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.71: 	    next(it)
//│ ║        	^^^^^^^^^^^^
//│ ║  l.72: 	    123
//│ ║        	^^^^^^^
//│ ║  l.73: 	    () => next(it)
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ║  l.74: 	  k()
//│ ║        	^^^^^
//│ ╟── because: cannot constrain  E73_1  <:  Alloc
//│ ╟── because: cannot constrain  E73_1  <:  ¬(~{Alloc})
//│ ╟── because: cannot constrain  ¬⊥ ∧ ¬Rg96_1  <:  ¬(~{Alloc})
//│ ╟── because: cannot constrain  ~{Alloc}  <:  Rg96_1
//│ ╙── because: cannot constrain  ~{Alloc}  <:  ¬()
//│ Type: ⊥

:e
letreg of r =>
  let b = mkVec(r)
  clear(b)
  iterate(b) of it =>
    next(it)
    clear(b)
    123
  clear(b)
  r
//│ ╔══[ERROR] Type error in block
//│ ║  l.100: 	letreg of r =>
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.101: 	  let b = mkVec(r)
//│ ║         	^^^^^^^^^^^^^^^^^^
//│ ║  l.102: 	  clear(b)
//│ ║         	^^^^^^^^^^
//│ ║  l.103: 	  iterate(b) of it =>
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.104: 	    next(it)
//│ ║         	^^^^^^^^^^^^
//│ ║  l.105: 	    clear(b)
//│ ║         	^^^^^^^^^^^^
//│ ║  l.106: 	    123
//│ ║         	^^^^^^^
//│ ║  l.107: 	  clear(b)
//│ ║         	^^^^^^^^^^
//│ ║  l.108: 	  r
//│ ║         	^^^
//│ ╟── because: cannot constrain  E97_1  <:  Alloc
//│ ╟── because: cannot constrain  E97_1  <:  ¬(~{Alloc})
//│ ╟── because: cannot constrain  ¬⊥ ∧ Rg117_1  <:  ¬(~{Alloc})
//│ ╟── because: cannot constrain  Rg117_1  <:  ¬(~{Alloc})
//│ ╙── because: cannot constrain    <:  ¬(~{Alloc})
//│ Type: Reg[?, E97_1]
//│ Where:
//│   ⊤ <: E97_1
//│   E97_1 <: Alloc


letreg of r =>
  use(r)
  integers(r) of it =>
    next(it)
  use(r)
  r
//│ Type: Reg[?, E123_1]
//│ Where:
//│   E123_1 <: Alloc

:e
letreg of r =>
  use(r)
  integers(r) of it =>
    use(r)
    next(it)
  use(r)
  r
//│ ╔══[ERROR] Type error in block
//│ ║  l.150: 	letreg of r =>
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.151: 	  use(r)
//│ ║         	^^^^^^^^
//│ ║  l.152: 	  integers(r) of it =>
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.153: 	    use(r)
//│ ║         	^^^^^^^^^^
//│ ║  l.154: 	    next(it)
//│ ║         	^^^^^^^^^^^^
//│ ║  l.155: 	  use(r)
//│ ║         	^^^^^^^^
//│ ║  l.156: 	  r
//│ ║         	^^^
//│ ╟── because: cannot constrain  E137_1  <:  Alloc
//│ ╟── because: cannot constrain  E137_1  <:  ¬(~{Alloc})
//│ ╟── because: cannot constrain  ¬⊥ ∧ Rg149_1  <:  ¬(~{Alloc})
//│ ╟── because: cannot constrain  Rg149_1  <:  ¬(~{Alloc})
//│ ╙── because: cannot constrain    <:  ¬(~{Alloc})
//│ Type: Reg[?, E137_1]
//│ Where:
//│   ⊤ <: E137_1
//│   E137_1 <: Alloc

letreg of r0 =>
  letreg of r1 =>
    integers(r1) of it =>
      use(r0)
      next(it)
    use(r1)
    r1
//│ Type: Reg[?, in E174_1]
//│ Where:
//│   E174_1 <: Alloc


// * Can leak the iterator
fun iterate_unsafe: [A, Rg, Br, Res] -> MutVec[A, Rg, Br] -> (Iter[A, Br] ->{Br} Res) ->{Br} Res
//│ Type: ⊤
// * Eg:
letreg of r =>
  let b = mkVec(r)
  clear(b)
  let k = iterate_unsafe(b) of it =>
    next(it)
    123
    () => next(it)
  clear(b)
  k()
//│ Type: ⊥


