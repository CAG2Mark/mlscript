:global
:bbml


class Reg[Rg, Br]
//│ Type: ⊤

fun letreg: [E, Res] -> ([Rg] -> Reg[Rg, E] ->{E | Rg} Res) ->{E} Res
//│ Type: ⊤

fun use: [Rg, Br] -> Reg[Rg, Br] ->{Rg} Int
//│ Type: ⊤


class MutVec[A, Rg, Br]
//│ Type: ⊤

fun mkVec: [A, Rg, Br] -> Reg[Rg, Br] -> MutVec[A, Rg, Br]
//│ Type: ⊤

fun clear: [A, Rg, Br] -> MutVec[A, Rg, Br] ->{Rg} Int
//│ Type: ⊤

class Iter[A, Rg]
//│ Type: ⊤

fun iterate: [A, Rg, Br, Res] -> MutVec[A, Rg, Br] -> ([L] -> Iter[A, Br | L] ->{Br | L} Res) ->{Br} Res
//│ Type: ⊤

fun integers: [Rg, Br, Res] -> Reg[Rg, Br] ->{Rg} (Iter[Int, Br] ->{Br} Res) ->{Br} Res
//│ Type: ⊤


fun next: [A, Br] -> Iter[A, Br] ->{Br} A
//│ Type: ⊤

letreg(r => r)
//│ Type: Reg[?, α21_1]
//│ Where:
//│   α21_1 <: Alloc

letreg of r =>
  let b = mkVec(r)
  clear(b)
  iterate(b) of it =>
    next(it)
    123
  clear(b)
  r
//│ Type: Reg[?, α23_1]
//│ Where:
//│   α23_1 <: Alloc

// * Non-lexical borrowing pattern encoded with a thunk
letreg of r =>
  let b = mkVec(r)
  clear(b)
  let k = iterate(b) of it =>
    next(it)
    123
    if next(it) > 0 then () => 0 else () => clear(b)
  k()
//│ Type: Int

:e
letreg of r =>
  let b = mkVec(r)
  clear(b)
  let k = iterate(b) of it =>
    next(it)
    123
    () => next(it)
  k()
//│ ╔══[ERROR] Type error in block
//│ ║  l.66: 	letreg of r =>
//│ ║        	^^^^^^^^^^^^^^
//│ ║  l.67: 	  let b = mkVec(r)
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ║  l.68: 	  clear(b)
//│ ║        	^^^^^^^^^^
//│ ║  l.69: 	  let k = iterate(b) of it =>
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.70: 	    next(it)
//│ ║        	^^^^^^^^^^^^
//│ ║  l.71: 	    123
//│ ║        	^^^^^^^
//│ ║  l.72: 	    () => next(it)
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ║  l.73: 	  k()
//│ ║        	^^^^^
//│ ╟── because: cannot constrain  α62_1  <:  Alloc
//│ ╟── because: cannot constrain  α62_1  <:  ¬(~{Alloc})
//│ ╙── because: cannot constrain  ¬⊥  <:  ¬(~{Alloc})
//│ Type: ⊥

:e
letreg of r =>
  let b = mkVec(r)
  clear(b)
  iterate(b) of it =>
    next(it)
    clear(b)
    123
  clear(b)
  r
//│ ╔══[ERROR] Type error in block
//│ ║  l.97: 	letreg of r =>
//│ ║        	^^^^^^^^^^^^^^
//│ ║  l.98: 	  let b = mkVec(r)
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ║  l.99: 	  clear(b)
//│ ║        	^^^^^^^^^^
//│ ║  l.100: 	  iterate(b) of it =>
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.101: 	    next(it)
//│ ║         	^^^^^^^^^^^^
//│ ║  l.102: 	    clear(b)
//│ ║         	^^^^^^^^^^^^
//│ ║  l.103: 	    123
//│ ║         	^^^^^^^
//│ ║  l.104: 	  clear(b)
//│ ║         	^^^^^^^^^^
//│ ║  l.105: 	  r
//│ ║         	^^^
//│ ╟── because: cannot constrain  α82_1  <:  Alloc
//│ ╟── because: cannot constrain  α82_1  <:  ¬(~{Alloc})
//│ ╙── because: cannot constrain  ¬⊥  <:  ¬(~{Alloc})
//│ Type: Reg[?, α82_1]
//│ Where:
//│   ⊤ <: α82_1
//│   α82_1 <: Alloc


letreg of r =>
  use(r)
  integers(r) of it =>
    next(it)
  use(r)
  r
//│ Type: Reg[?, α102_1]
//│ Where:
//│   α102_1 <: Alloc

:e
letreg of r =>
  use(r)
  integers(r) of it =>
    use(r)
    next(it)
  use(r)
  r
//│ ╔══[ERROR] Type error in block
//│ ║  l.145: 	letreg of r =>
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.146: 	  use(r)
//│ ║         	^^^^^^^^
//│ ║  l.147: 	  integers(r) of it =>
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.148: 	    use(r)
//│ ║         	^^^^^^^^^^
//│ ║  l.149: 	    next(it)
//│ ║         	^^^^^^^^^^^^
//│ ║  l.150: 	  use(r)
//│ ║         	^^^^^^^^
//│ ║  l.151: 	  r
//│ ║         	^^^
//│ ╟── because: cannot constrain  α113_1  <:  Alloc
//│ ╟── because: cannot constrain  α113_1  <:  ¬(~{Alloc})
//│ ╙── because: cannot constrain  ¬⊥  <:  ¬(~{Alloc})
//│ Type: Reg[?, α113_1]
//│ Where:
//│   ⊤ <: α113_1
//│   α113_1 <: Alloc

letreg of r0 =>
  letreg of r1 =>
    integers(r1) of it =>
      use(r0)
      next(it)
    use(r1)
    r1
//│ Type: Reg[?, in α139_1]
//│ Where:
//│   α139_1 <: Alloc


// * Can leak the iterator
fun iterate_unsafe: [A, Rg, Br, Res] -> MutVec[A, Rg, Br] -> (Iter[A, Br] ->{Br} Res) ->{Br} Res
//│ Type: ⊤
// * Eg:
letreg of r =>
  let b = mkVec(r)
  clear(b)
  let k = iterate_unsafe(b) of it =>
    next(it)
    123
    () => next(it)
  clear(b)
  k()
//│ Type: ⊥


