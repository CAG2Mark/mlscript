:bbml
//│ Type: ⊤

//│ Type: ⊤

class Reg[Rg, Br]
//│ Type: ⊤

fun letreg: [E, Res] -> ([Rg] -> Reg[Rg, E] ->{E | Rg} Res) ->{E} Res
//│ Type: ⊤

fun use: [Rg, Br] -> Reg[Rg, Br] ->{Rg} Int
//│ Type: ⊤


class MutVec[A, Rg, Br]
//│ Type: ⊤

fun mkVec: [A, Rg, Br] -> Reg[Rg, Br] -> MutVec[A, Rg, Br]
//│ Type: ⊤

fun clear: [A, Rg, Br] -> MutVec[A, Rg, Br] ->{Rg} Int
//│ Type: ⊤

class Iter[A, Rg]
//│ Type: ⊤

fun iterate: [A, Rg, Br, Res] -> MutVec[A, Rg, Br] -> ([L] -> Iter[A, Br | L] ->{Br | L} Res) ->{Br} Res
//│ Type: ⊤

fun integers: [Rg, Br, Res] -> Reg[Rg, Br] ->{Rg} (Iter[Int, Br] ->{Br} Res) ->{Br} Res
//│ Type: ⊤


fun next: [A, Br] -> Iter[A, Br] ->{Br} A
//│ Type: ⊤

letreg(r => r)
//│ Type: Reg[?, 'E]
//│ Where:
//│   'E <: ⊥

letreg of r =>
  let b = mkVec(r)
  clear(b)
  iterate(b) of it =>
    next(it)
    123
  clear(b)
  r
//│ Type: Reg[?, 'E]
//│ Where:
//│   'E <: ⊥


// * Non-lexical borrowing pattern encoded with a thunk
letreg of r =>
  let b = mkVec(r)
  clear(b)
  let k = iterate(b) of it =>
    next(it)
    123
    if next(it) > 0 then () => 0 else () => clear(b)
  k()
//│ Type: Int

:e
letreg of r =>
  let b = mkVec(r)
  clear(b)
  let k = iterate(b) of it =>
    next(it)
    123
    () => next(it)
  k()
//│ ╔══[ERROR] Type error in block
//│ ║  l.49: 	letreg of r =>
//│ ║        	^^^^^^^^^^^^^^
//│ ║  l.50: 	  let b = mkVec(r)
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ║  l.51: 	  clear(b)
//│ ║        	^^^^^^^^^^
//│ ║  l.52: 	  let k = iterate(b) of it =>
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.53: 	    next(it)
//│ ║        	^^^^^^^^^^^^
//│ ║  l.54: 	    123
//│ ║        	^^^^^^^
//│ ║  l.55: 	    () => next(it)
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ║  l.56: 	  k()
//│ ║        	^^^^^
//│ ╟── because: cannot constrain  'E  <:  ⊥
//│ ╟── because: cannot constrain  'E  <:  ¬()
//│ ╟── because: cannot constrain  ¬⊥ ∧ ¬'Rg  <:  ¬()
//│ ╟── because: cannot constrain    <:  'Rg
//│ ╙── because: cannot constrain    <:  ¬()
//│ Type: ⊥

:e
letreg of r =>
  let b = mkVec(r)
  clear(b)
  iterate(b) of it =>
    next(it)
    clear(b)
    123
  clear(b)
  r
//│ ╔══[ERROR] Type error in block
//│ ║  l.60: 	letreg of r =>
//│ ║        	^^^^^^^^^^^^^^
//│ ║  l.61: 	  let b = mkVec(r)
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ║  l.62: 	  clear(b)
//│ ║        	^^^^^^^^^^
//│ ║  l.63: 	  iterate(b) of it =>
//│ ║        	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.64: 	    next(it)
//│ ║        	^^^^^^^^^^^^
//│ ║  l.65: 	    clear(b)
//│ ║        	^^^^^^^^^^^^
//│ ║  l.66: 	    123
//│ ║        	^^^^^^^
//│ ║  l.67: 	  clear(b)
//│ ║        	^^^^^^^^^^
//│ ║  l.68: 	  r
//│ ║        	^^^
//│ ╟── because: cannot constrain  'E  <:  ⊥
//│ ╟── because: cannot constrain  'E  <:  ¬()
//│ ╟── because: cannot constrain  ¬⊥ ∧ 'Rg  <:  ¬()
//│ ╟── because: cannot constrain  'Rg  <:  ¬()
//│ ╙── because: cannot constrain    <:  ¬()
//│ Type: Reg[?, 'E]
//│ Where:
//│   ⊤ <: 'E
//│   'E <: ⊥


letreg of r =>
  use(r)
  integers(r) of it =>
    next(it)
  use(r)
  r
//│ Type: Reg[?, 'E]
//│ Where:
//│   'E <: ⊥

:e
letreg of r =>
  use(r)
  integers(r) of it =>
    use(r)
    next(it)
  use(r)
  r
//│ ╔══[ERROR] Type error in block
//│ ║  l.80: 	letreg of r =>
//│ ║        	^^^^^^^^^^^^^^
//│ ║  l.81: 	  use(r)
//│ ║        	^^^^^^^^
//│ ║  l.82: 	  integers(r) of it =>
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.83: 	    use(r)
//│ ║        	^^^^^^^^^^
//│ ║  l.84: 	    next(it)
//│ ║        	^^^^^^^^^^^^
//│ ║  l.85: 	  use(r)
//│ ║        	^^^^^^^^
//│ ║  l.86: 	  r
//│ ║        	^^^
//│ ╟── because: cannot constrain  'E  <:  ⊥
//│ ╟── because: cannot constrain  'E  <:  ¬()
//│ ╟── because: cannot constrain  ¬⊥ ∧ 'Rg  <:  ¬()
//│ ╟── because: cannot constrain  'Rg  <:  ¬()
//│ ╙── because: cannot constrain    <:  ¬()
//│ Type: Reg[?, 'E]
//│ Where:
//│   ⊤ <: 'E
//│   'E <: ⊥

letreg of r0 =>
  letreg of r1 =>
    integers(r1) of it =>
      use(r0)
      next(it)
    use(r1)
    r1
//│ Type: Reg[?, in 'E]
//│ Where:
//│   'E <: ⊥


// * Can leak the iterator
fun iterate_unsafe: [A, Rg, Br, Res] -> MutVec[A, Rg, Br] -> (Iter[A, Br] ->{Br} Res) ->{Br} Res
// * Eg:
letreg of r =>
  let b = mkVec(r)
  clear(b)
  let k = iterate_unsafe(b) of it =>
    next(it)
    123
    () => next(it)
  clear(b)
  k()
//│ Type: ⊥


