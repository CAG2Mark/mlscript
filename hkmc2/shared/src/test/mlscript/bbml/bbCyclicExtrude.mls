:global
:bbml



let f = (x => (x : [A] -> A -> A)) in f
//│ Type: (⊤ ->{⊥} ⊥) ->{⊥} forall α2_2: (α2_2) ->{⊥} α2_2

let f = ((x => x) : [A] -> A -> A) in f
//│ Type: forall α3_2: (α3_2) ->{⊥} α3_2

let foo = f => (x => f(x(x)) : [A] -> A -> A) in foo
//│ Type: (α9_1 ->{⊥} (⊤ ->{⊥} ⊥)) ->{⊥} (α5_1 ->{⊥} α9_1) ->{⊥} forall α6_2: (α6_2) ->{⊥} α6_2
//│ Where:
//│   α5_1 <: α5_1 ->{⊥} α9_1

:fixme // extrusion of cyclic bounds
f => (let g = x => x(x) in let tmp = g(g) in f(g)) : [A] -> A -> A
//│ /!!!\ Uncaught error: java.lang.StackOverflowError

f => (let g = x => x(x) in f(g(g))) : [A] -> A -> A
//│ Type: (⊥ ->{⊥} (⊤ ->{⊥} ⊥)) ->{⊥} forall α1184_2: (α1184_2) ->{⊥} α1184_2

:e
f => (let g = x => f(x(x)) in g) : [A] -> A -> A
//│ ╔══[ERROR] Type error in term g@3#0 with expected type (<α>1194_2) ->{⊥} <α>1194_2
//│ ╟── because: cannot constrain  α1195_2 ->{α1198_2 ∨ α1196_2} α1199_2  <:  <α>1194_2 ->{⊥} <α>1194_2
//│ ╟── because: cannot constrain  ((⊤ ∧ ⊤) ∧ <α>1194_2) ∨ ⊥  <:  ((⊤ ∧ ⊤) ∧ α1195_2) ∨ ⊥
//│ ╟── because: cannot constrain  <α>1194_2  <:  α1195_2
//│ ╙── because: cannot constrain  <α>1194_2  <:  (((⊤ ∧ ⊤) ∧ α1195_2) ∨ ⊥) ->{((⊤ ∧ ⊤) ∧ α1196_2) ∨ ⊥} (((⊤ ∧ ⊤) ∧ α1197_2) ∨ ⊥)
//│ Type: (⊥ ->{⊥} ⊥) ->{⊥} forall α1194_2: (α1194_2) ->{⊥} α1194_2

f => (x => f(x(x)) : [A] -> A -> A)
//│ Type: (α1208_1 ->{⊥} (⊤ ->{⊥} ⊥)) ->{⊥} (α1204_1 ->{⊥} α1208_1) ->{⊥} forall α1205_2: (α1205_2) ->{⊥} α1205_2
//│ Where:
//│   α1204_1 <: α1204_1 ->{⊥} α1208_1

let foo = f => (f(x => x(x)) : [A] -> A -> A) in foo
//│ Type: (((α1222_1 ->{α1225_1} α1224_1) ->{α1225_1} α1224_1) ->{⊥} (⊤ ->{⊥} ⊥)) ->{⊥} forall α1216_2: (α1216_2) ->{⊥} α1216_2
//│ Where:
//│   α1222_1 <: α1222_1 ->{α1225_1} α1224_1

:todo
let foo(f) = (f(x => x(x)) : [A] -> A -> A) in foo
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing

:todo
fun foo(f) = (f(x => x(x)) : [A] -> A -> A)
//│ ╔══[ERROR] General type is not allowed here.
//│ ╙──
//│ Type: ⊤



