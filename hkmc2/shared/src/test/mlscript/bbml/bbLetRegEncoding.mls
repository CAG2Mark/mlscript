:bbml
//│ Type: ⊤

//│ Type: ⊤


fun letreg: [E,Res] -> ([R] -> Region[R] ->{E | R} Res) ->{E} Res
//│ Type: ⊤

letreg
//│ Type: forall E3_2, Res4_2: (forall R5_3: (Region[R5_3]) ->{E3_2 ∨ R5_3} Res4_2) ->{E3_2} Res4_2

letreg(r => r)
//│ Type: Region[?]

:e
letreg(r => r).ref 1
//│ ╔══[ERROR] Type error in reference creation
//│ ║  l.17: 	letreg(r => r).ref 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  Res12_1  <:  Region[α16_1]
//│ ╟── because: cannot constrain  Res12_1  <:  ¬(~{Region[α16_1]})
//│ ╟── because: cannot constrain  Region[in ¬⊥ ∧ R14_1 out ¬⊥ ∧ R15_1] ∧ ¬⊥  <:  ¬(~{Region[α16_1]})
//│ ╟── because: cannot constrain  D( R15_1 )  <:  α16_1
//│ ╟── because: cannot constrain  R15_1  <:  α16_1
//│ ╟── because: cannot constrain  R15_1  <:  ¬(~R14_1)
//│ ╟── because: cannot constrain  R15_1  <:  ¬(~R14_1)
//│ ╟── because: cannot constrain    <:  ¬(~R14_1)
//│ ╟── because: cannot constrain    <:  R14_1
//│ ╙── because: cannot constrain    <:  ¬()
//│ ╔══[ERROR] Type error in block
//│ ║  l.17: 	letreg(r => r).ref 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  α16_1 ∨ E11_1  <:  ⊥
//│ ╟── because: cannot constrain  α16_1  <:  ¬()
//│ ╟── because: cannot constrain  R15_1  <:  ¬()
//│ ╟── because: cannot constrain  R15_1  <:  ¬()
//│ ╙── because: cannot constrain    <:  ¬()
//│ Type: Ref[Int, ?]

letreg(r => r.ref 1)
//│ Type: Ref[Int, ?]

letreg(r => !(r.ref 1))
//│ Type: Int

:e
!letreg(r => r.ref 1)
//│ ╔══[ERROR] Type error in block
//│ ║  l.48: 	!letreg(r => r.ref 1)
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  α35_1 ∨ E29_1  <:  ⊥
//│ ╟── because: cannot constrain  α35_1  <:  ¬()
//│ ╟── because: cannot constrain  α33_1  <:  ¬()
//│ ╟── because: cannot constrain  α33_1  <:  ¬()
//│ ╟── because: cannot constrain  ¬⊥ ∧ R34_1  <:  ¬()
//│ ╟── because: cannot constrain  R34_1  <:  ¬()
//│ ╙── because: cannot constrain    <:  ¬()
//│ Type: Int

letreg of r =>
  let x = r.ref 1
  x := !x + 1
  !x
//│ Type: Int

let f = letreg(r => arg => r.ref arg)
//│ Type: ⊤

f
//│ Type: arg51_1 ->{⊤} Ref[arg51_1, ?]

:e
letreg(r => arg => r.ref arg)(0)
//│ ╔══[ERROR] Type error in block
//│ ║  l.74: 	letreg(r => arg => r.ref arg)(0)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  α64_1 ∨ E55_1  <:  ⊥
//│ ╟── because: cannot constrain  α64_1  <:  ¬()
//│ ╟── because: cannot constrain  α62_1  <:  ¬()
//│ ╟── because: cannot constrain  α62_1  <:  ¬()
//│ ╟── because: cannot constrain  ¬⊥ ∧ R63_1  <:  ¬()
//│ ╟── because: cannot constrain  R63_1  <:  ¬()
//│ ╙── because: cannot constrain    <:  ¬()
//│ Type: Ref[arg60_1, ?]
//│ Where:
//│   Int <: arg60_1



// * An incorrect one, just for testing the error:

fun letreg: [E,Res] -> ([R] -> Region[R] -> Res) ->{E} Res
//│ Type: ⊤

:e
letreg(r => r.ref 1)
//│ ╔══[ERROR] Type error in function literal with expected type (Region[<R>71_2]) ->{⊥} Res70_1
//│ ║  l.97: 	letreg(r => r.ref 1)
//│ ║        	       ^^^^^^^^^^^^
//│ ╟── because: cannot constrain  α72_2  <:  ⊥
//│ ╟── because: cannot constrain  α72_2  <:  ¬()
//│ ╙── because: cannot constrain  <R>71_2  <:  ¬()
//│ Type: Ref[Int, ?]

:e
letreg(r => !(r.ref 1))
//│ ╔══[ERROR] Type error in function literal with expected type (Region[<R>77_2]) ->{⊥} Res76_1
//│ ║  l.107: 	letreg(r => !(r.ref 1))
//│ ║         	       ^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  α79_2 ∨ α78_2  <:  ⊥
//│ ╟── because: cannot constrain  α79_2  <:  ¬()
//│ ╟── because: cannot constrain  α78_2  <:  ¬()
//│ ╟── because: cannot constrain  α78_2  <:  ¬()
//│ ╙── because: cannot constrain  <R>77_2  <:  ¬()
//│ ╔══[ERROR] Type error in function literal with expected type (Region[<R>77_2]) ->{⊥} Res76_1
//│ ║  l.107: 	letreg(r => !(r.ref 1))
//│ ║         	       ^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  α79_2 ∨ α78_2  <:  ⊥
//│ ╟── because: cannot constrain  α78_2  <:  ¬()
//│ ╙── because: cannot constrain  <R>77_2  <:  ¬()
//│ Type: Int


