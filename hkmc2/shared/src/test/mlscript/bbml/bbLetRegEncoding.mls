:bbml
//│ Type: ⊤



fun letreg: [E,Res] -> ([R] -> Region[R] ->{E | R} Res) ->{E} Res
//│ Type: ⊤

letreg
//│ Type: forall E2_2, Res3_2: (forall R4_3: (Region[R4_3]) ->{E2_2 ∨ R4_3} Res3_2) ->{E2_2} Res3_2

letreg(r => r)
//│ Type: Region[?]

:e
letreg(r => r).ref 1
//│ ╔══[ERROR] Type error in reference creation
//│ ║  l.16: 	letreg(r => r).ref 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  Res11_1  <:  Region[α15_1]
//│ ╟── because: cannot constrain  Res11_1  <:  ¬(~{Region[α15_1]})
//│ ╟── because: cannot constrain  Region[in ¬⊥ ∧ R13_1 out ¬⊥ ∧ R14_1] ∧ ¬⊥  <:  ¬(~{Region[α15_1]})
//│ ╟── because: cannot constrain  D( R14_1 )  <:  α15_1
//│ ╟── because: cannot constrain  R14_1  <:  α15_1
//│ ╟── because: cannot constrain  R14_1  <:  ¬(~R13_1)
//│ ╟── because: cannot constrain  R14_1  <:  ¬(~R13_1)
//│ ╟── because: cannot constrain    <:  ¬(~R13_1)
//│ ╟── because: cannot constrain    <:  R13_1
//│ ╙── because: cannot constrain    <:  ¬()
//│ ╔══[ERROR] Type error in block
//│ ║  l.16: 	letreg(r => r).ref 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  α15_1 ∨ E10_1  <:  Alloc
//│ ╟── because: cannot constrain  α15_1  <:  ¬(~{Alloc})
//│ ╟── because: cannot constrain  R14_1  <:  ¬(~{Alloc})
//│ ╟── because: cannot constrain  R14_1  <:  ¬(~{Alloc})
//│ ╙── because: cannot constrain    <:  ¬(~{Alloc})
//│ Type: Ref[Int, ?]

letreg(r => r.ref 1)
//│ Type: Ref[Int, ?]

letreg(r => !(r.ref 1))
//│ Type: Int

:e
!letreg(r => r.ref 1)
//│ ╔══[ERROR] Type error in block
//│ ║  l.47: 	!letreg(r => r.ref 1)
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  α34_1 ∨ E28_1  <:  Alloc
//│ ╟── because: cannot constrain  α34_1  <:  ¬(~{Alloc})
//│ ╟── because: cannot constrain  α32_1  <:  ¬(~{Alloc})
//│ ╟── because: cannot constrain  α32_1  <:  ¬(~{Alloc})
//│ ╟── because: cannot constrain  ¬⊥ ∧ R33_1  <:  ¬(~{Alloc})
//│ ╟── because: cannot constrain  R33_1  <:  ¬(~{Alloc})
//│ ╙── because: cannot constrain    <:  ¬(~{Alloc})
//│ Type: Int

letreg of r =>
  let x = r.ref 1
  x := !x + 1
  !x
//│ Type: Int

let f = letreg(r => arg => r.ref arg)
//│ Type: ⊤

f
//│ Type: arg50_1 ->{⊤} Ref[arg50_1, ?]

:e
letreg(r => arg => r.ref arg)(0)
//│ ╔══[ERROR] Type error in block
//│ ║  l.73: 	letreg(r => arg => r.ref arg)(0)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  α63_1 ∨ E54_1  <:  Alloc
//│ ╟── because: cannot constrain  α63_1  <:  ¬(~{Alloc})
//│ ╟── because: cannot constrain  α61_1  <:  ¬(~{Alloc})
//│ ╟── because: cannot constrain  α61_1  <:  ¬(~{Alloc})
//│ ╟── because: cannot constrain  ¬⊥ ∧ R62_1  <:  ¬(~{Alloc})
//│ ╟── because: cannot constrain  R62_1  <:  ¬(~{Alloc})
//│ ╙── because: cannot constrain    <:  ¬(~{Alloc})
//│ Type: Ref[arg59_1, ?]
//│ Where:
//│   Int <: arg59_1



// * An incorrect one, just for testing the error:

fun letreg: [E,Res] -> ([R] -> Region[R] -> Res) ->{E} Res
//│ Type: ⊤

:e
letreg(r => r.ref 1)
//│ ╔══[ERROR] Type error in function literal with expected type (Region[<R>70_2]) ->{⊥} Res69_1
//│ ║  l.96: 	letreg(r => r.ref 1)
//│ ║        	       ^^^^^^^^^^^^
//│ ╟── because: cannot constrain  α71_2  <:  ⊥
//│ ╟── because: cannot constrain  α71_2  <:  ¬()
//│ ╙── because: cannot constrain  <R>70_2  <:  ¬()
//│ Type: Ref[Int, ?]

:e
letreg(r => !(r.ref 1))
//│ ╔══[ERROR] Type error in function literal with expected type (Region[<R>76_2]) ->{⊥} Res75_1
//│ ║  l.106: 	letreg(r => !(r.ref 1))
//│ ║         	       ^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  α78_2 ∨ α77_2  <:  ⊥
//│ ╟── because: cannot constrain  α78_2  <:  ¬()
//│ ╟── because: cannot constrain  α77_2  <:  ¬()
//│ ╟── because: cannot constrain  α77_2  <:  ¬()
//│ ╙── because: cannot constrain  <R>76_2  <:  ¬()
//│ ╔══[ERROR] Type error in function literal with expected type (Region[<R>76_2]) ->{⊥} Res75_1
//│ ║  l.106: 	letreg(r => !(r.ref 1))
//│ ║         	       ^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  α78_2 ∨ α77_2  <:  ⊥
//│ ╟── because: cannot constrain  α77_2  <:  ¬()
//│ ╙── because: cannot constrain  <R>76_2  <:  ¬()
//│ Type: Int


