:global
:bbml

fun f(y) =
  let local = ((x => y(x) + 1): [A] -> A -> Int) in y
//│ Elab: { fun f(y@2) = { let local@3 = Lam(List(Param(‹›,x@4,None)),App(Ref(+),Tup(List(Fld(‹›,App(Ref(y@2),Tup(List(Fld(‹›,Ref(x@4),None)))),None), Fld(‹›,Lit(IntLit(1)),None))))): Forall(List(A@7),FunTy(Tup(List(Fld(‹›,Ref(A@7),None))),Ref(class:Int),None))‹›; y@2#1 }‹›; }‹›
//│ Type: ⊤

// * the parameter type of y is extruded.
f
//│ Elab: { f#0 }‹›
//│ Type: α1_0
//│ Where:
//│   ((((⊤) ∧ (¬(⊥))) ∧ (α2_0)) ->{⊥} ((⊤) ∧ (¬(⊥))) ∧ (α2_0)) ∧ (¬(⊥)) <: α1_0
//│   α2_0 <: ¬((⊤) ∧ (¬((((⊤) ∧ (¬(⊥))) ∧ (⊤)) ->{((⊤) ∧ (¬(⊥))) ∧ (α7_0)} ((⊤) ∧ (¬(⊥))) ∧ (α6_0))))
//│   α6_0 <: ¬((⊤) ∧ (¬((⊥) ∨ (Int))))
//│   α7_0 <: ¬((⊤) ∧ (¬(⊥)))

fun foo: [A] -> A -> Int
fun foo(x) = 0
//│ Elab: { fun foo: forall A@3: FunTy(Tup(List(Fld(‹›,Ref(A@3),None))),Ref(class:Int),None)‹›; fun foo(x@4): forall A@6: FunTy(Tup(List(Fld(‹›,Ref(A@6),None))),Ref(class:Int),None)‹› = 0‹›; }‹›
//│ Type: ⊤

foo
//│ Elab: { foo#0 }‹›
//│ Type: forall α8_1: (α8_1) ->{⊥} Int

f(foo)
//│ Elab: { f#1(foo#1)‹›‹› }‹›
//│ Type: α10_0
//│ Where:
//│   ((⊤) ∧ (¬(⊥))) ∧ (α2_0) <: α10_0
//│   ((((⊤) ∧ (¬(⊥))) ∧ (α11_0)) ->{⊥} (Int) ∧ (¬(⊥))) ∧ (¬(⊥)) <: α2_0
//│   (⊤) ∧ (¬(⊥)) <: α11_0
//│   α2_0 <: ¬((⊤) ∧ (¬((((⊤) ∧ (¬(⊥))) ∧ (⊤)) ->{((⊤) ∧ (¬(⊥))) ∧ (α7_0)} ((⊤) ∧ (¬(⊥))) ∧ (α6_0))))
//│   (Int) ∧ (¬(⊥)) <: α6_0
//│   α6_0 <: ¬((⊤) ∧ (¬((⊥) ∨ (Int))))
//│   α7_0 <: ¬((⊤) ∧ (¬(⊥)))

fun g: ([A] -> A -> Int) -> ([A] -> A -> Int)
fun g(y) =
  let local = ((x => y(x) + 1): ([A] -> A -> Int)) in y
//│ Elab: { fun g: (forall A@3: FunTy(Tup(List(Fld(‹›,Ref(A@3),None))),Ref(class:Int),None)‹›)‹› -> forall A@4: FunTy(Tup(List(Fld(‹›,Ref(A@4),None))),Ref(class:Int),None)‹›‹›; fun g(y@5): (forall A@12: FunTy(Tup(List(Fld(‹›,Ref(A@12),None))),Ref(class:Int),None)‹›)‹› -> forall A@13: FunTy(Tup(List(Fld(‹›,Ref(A@13),None))),Ref(class:Int),None)‹›‹› = { let local@6 = Lam(List(Param(‹›,x@7,None)),App(Ref(+),Tup(List(Fld(‹›,App(Ref(y@5),Tup(List(Fld(‹›,Ref(x@7),None)))),None), Fld(‹›,Lit(IntLit(1)),None))))): Forall(List(A@10),FunTy(Tup(List(Fld(‹›,Ref(A@10),None))),Ref(class:Int),None))‹›; y@5#1 }‹›; }‹›
//│ Type: ⊤

g
//│ Elab: { g#0 }‹›
//│ Type: (forall α12_1: (α12_1) ->{⊥} Int) ->{⊥} forall α13_1: (α13_1) ->{⊥} Int

g(foo)
//│ Elab: { g#1(foo#2)‹›‹› }‹›
//│ Type: forall α13_1: (α13_1) ->{⊥} Int

:e
y `=> (let t = run(x `=> x `+ y) in y)
//│ Elab: { code"λy@2. ${{ let t@3 = run#0(code"λx@5. ${code"+#2(${x@5#0}‹›, ${y@2#0}‹›)‹›‹›"‹›}‹›‹›"‹›)‹›‹›; y@2#1 }‹›}‹›‹›"‹› }‹›
//│ ╔══[ERROR] Cannot constrain skolem α18_2
//│ ╙──
//│ Type: CodeBase[in ⊥ out α25_1, in ⊥ out ⊤]
