:global
:bbml

fun f(y) =
  let local = ((x => y(x) + 1): [A] -> A -> Int) in y
//│ Elab: { fun f(y@2) = { let local@3 = Lam(List(Param(‹›,x@4,None)),App(Ref(+),Tup(List(Fld(‹›,App(Ref(y@2),Tup(List(Fld(‹›,Ref(x@4),None)))),None), Fld(‹›,Lit(IntLit(1)),None))))): Forall(List(A@7),FunTy(Tup(List(Fld(‹›,Ref(A@7),None))),Ref(class:Int),None))‹›; y@2#1 }‹›; }‹›
//│ Type: ⊤

// * the parameter type of y is extruded.
f
//│ Elab: { f#0 }‹›
//│ Type: α2_1 ->{⊥} α2_1
//│ Where:
//│   α2_1 <: ⊤ ->{⊥} Int

fun foo: [A] -> A -> Int
fun foo(x) = 0
//│ Elab: { fun foo: forall A@3: FunTy(Tup(List(Fld(‹›,Ref(A@3),None))),Ref(class:Int),None)‹›; fun foo(x@4): forall A@6: FunTy(Tup(List(Fld(‹›,Ref(A@6),None))),Ref(class:Int),None)‹› = 0‹›; }‹›
//│ Type: ⊤

foo
//│ Elab: { foo#0 }‹›
//│ Type: forall α9_2: (⊤) ->{⊥} Int

f(foo)
//│ Elab: { f#1(foo#1)‹› }‹›
//│ Type: ⊤ ->{⊥} Int

fun g: ([A] -> A -> Int) -> ([A] -> A -> Int)
fun g(y) =
  let local = ((x => y(x) + 1): ([A] -> A -> Int)) in y
//│ Elab: { fun g: forall A@3: FunTy(Tup(List(Fld(‹›,Ref(A@3),None))),Ref(class:Int),None)‹› -> forall A@4: FunTy(Tup(List(Fld(‹›,Ref(A@4),None))),Ref(class:Int),None)‹›‹›; fun g(y@5): forall A@12: FunTy(Tup(List(Fld(‹›,Ref(A@12),None))),Ref(class:Int),None)‹› -> forall A@13: FunTy(Tup(List(Fld(‹›,Ref(A@13),None))),Ref(class:Int),None)‹›‹› = { let local@6 = Lam(List(Param(‹›,x@7,None)),App(Ref(+),Tup(List(Fld(‹›,App(Ref(y@5),Tup(List(Fld(‹›,Ref(x@7),None)))),None), Fld(‹›,Lit(IntLit(1)),None))))): Forall(List(A@10),FunTy(Tup(List(Fld(‹›,Ref(A@10),None))),Ref(class:Int),None))‹›; y@5#1 }‹›; }‹›
//│ Type: ⊤

g
//│ Elab: { g#0 }‹›
//│ Type: (forall α15_2: (⊥) ->{⊥} Int) ->{⊥} forall α16_2: (⊤) ->{⊥} Int

g(foo)
//│ Elab: { g#1(foo#2)‹› }‹›
//│ Type: forall α16_2: (⊤) ->{⊥} Int

:e
y `=> (let t = run(x `=> x `+ y) in y)
//│ Elab: { code"λy@2. ${{ let t@3 = run#0(code"λx@5. ${code"+#2(${x@5#0}‹›, ${y@2#0}‹›)‹›"‹›}‹›‹›"‹›)‹›; y@2#1 }‹›}‹›‹›"‹› }‹›
//│ ╔══[ERROR] Type error in term Quoted(Lam(List(Param(‹›,x@5,None)),Unquoted(Quoted(App(Ref(+),Tup(List(Fld(‹›,Unquoted(Ref(x@5)),None), Fld(‹›,Unquoted(Ref(y@2)),None)))))))) with expected type CodeBase[out α23_3, ⊥, ?]
//│ ╟── because: cannot constrain  CodeBase[out α24_5 ->{⊥} α31_5, out α33_4, ?]  <:  CodeBase[out α23_3, ⊥, ?]
//│ ╟── because: cannot constrain  ((⊤ ∧ ⊤) ∧ α33_4) ∨ ⊥  <:  ⊥ ∨ ⊥
//│ ╟── because: cannot constrain  α33_4  <:  ⊥
//│ ╙── because: cannot constrain  <α>22_3  <:  ⊥
//│ Type: CodeBase[out α21_3 ->{⊥} α21_3, ⊥, ?]
//│ Where:
//│   α21_3 <: Int

class C[A](m: A, n: A -> Int)
//│ Elab: { class C[in out A@2](m@3: A@2#0, n@4: A@2#1 -> class:Int#23‹›) { }‹›; }‹›
//│ Type: ⊤


fun f: [A] -> ([B] -> (C[out B] & A) -> B) -> A -> Int
f
//│ Elab: { fun f: forall A@3: FunTy(Tup(List(Fld(‹›,Forall(List(B@4),FunTy(Tup(List(Fld(‹›,CompType(TyApp(Ref(class:C),List(WildcardTy(None,Some(Ref(B@4))))),Ref(A@3),false),None))),Ref(B@4),None)),None))),FunTy(Tup(List(Fld(‹›,Ref(A@3),None))),Ref(class:Int),None),None)‹›; f#0 }‹›
//│ Type: forall α39_2: (forall α40_3: (C[out α40_3] ∧ α39_2) ->{⊥} α40_3) ->{⊥} (α39_2) ->{⊥} Int

fun g: [D] -> C[in Int out D] -> D
g
//│ Elab: { fun g: forall D@3: FunTy(Tup(List(Fld(‹›,TyApp(Ref(class:C),List(WildcardTy(Some(Ref(class:Int)),Some(Ref(D@3))))),None))),Ref(D@3),None)‹›; g#0 }‹›
//│ Type: forall α41_2: (C[in Int out α41_2]) ->{⊥} α41_2


f(g)
//│ Elab: { f#1(g#1)‹› }‹›
//│ Type: (¬C[?] ∨ C[in Int out ⊥]) ->{⊥} Int

fun foo: C[in Int out Nothing]
foo
//│ Elab: { fun foo: class:C#2[WildcardTy(Some(Ref(class:Int)),Some(Ref(class:Nothing)))]‹›; foo#0 }‹›
//│ Type: C[in Int out ⊥]

fun bar: C[in Int out Int]
bar
//│ Elab: { fun bar: class:C#3[WildcardTy(Some(Ref(class:Int)),Some(Ref(class:Int)))]‹›; bar#0 }‹›
//│ Type: C[Int]

f(g)(foo)
//│ Elab: { f#2(g#2)‹›(foo#1)‹› }‹›
//│ Type: Int

:fixme // ???
f(g)(bar)
//│ Elab: { f#3(g#3)‹›(bar#1)‹› }‹›
//│ ╔══[ERROR] Type error in term Ref(bar) with expected type α48_1
//│ ╟── because: cannot constrain  C[Int]  <:  α48_1
//│ ╟── because: cannot constrain  C[((Int ∧ ⊤) ∧ ⊤) ∨ ⊥]  <:  α48_1
//│ ╟── because: cannot constrain  C[((Int ∧ ⊤) ∧ ⊤) ∨ ⊥]  <:  ¬C[in ⊥ ∨ ⊥ out ⊤ ∧ ⊤] ∨ C[in ((Int ∧ ⊤) ∧ ⊤) ∨ ⊥ out (⊤ ∧ ⊤) ∧ α50_1]
//│ ╟── because: cannot constrain  ((Int ∧ ⊤) ∧ ⊤) ∨ ⊥  <:  ((⊤ ∧ ⊤) ∧ α50_1) ∨ ⊥
//│ ╟── because: cannot constrain  Int  <:  α50_1
//│ ╙── because: cannot constrain  Int  <:  ⊥
//│ Type: Int
