:global
:bbml

42: forall (a): Int
//│ Elab: { Lit(IntLit(42)): ForallTy(List(a@1),Ref(class:Int))‹› }‹›
//│ Type: forall α0_1: Int

:e
42: forall (a): Str
//│ Elab: { Lit(IntLit(42)): ForallTy(List(a@1),Ref(class:Str))‹› }‹›
//│ ╔══[ERROR] Cannot solve Int <: ⊥
//│ ╙──
//│ Type: forall α1_1: Str

fun id: forall (a): a -> a
fun id(x) = x
//│ Elab: { fun id: forall a@2: FunTy(Tup(List(Fld(‹›,Ref(a@2),None))),Ref(a@2))‹›; fun id(x@3): forall a@5: FunTy(Tup(List(Fld(‹›,Ref(a@5),None))),Ref(a@5))‹› = x@3#0; }‹›
//│ Type: ⊤

id
//│ Elab: { id#0 }‹›
//│ Type: forall α2_1: (α2_1) ->{⊥} α2_1

(x => x): forall (a): a -> a
//│ Elab: { Lam(List(x@1),Ref(x@1)): ForallTy(List(a@2),FunTy(Tup(List(Fld(‹›,Ref(a@2),None))),Ref(a@2)))‹› }‹›
//│ Type: forall α3_1: (α3_1) ->{⊥} α3_1

:e
(x => x + 1): forall (a): a -> a
//│ Elab: { Lam(List(x@1),App(Ref(+),Tup(List(Fld(‹›,Ref(x@1),None), Fld(‹›,Lit(IntLit(1)),None))))): ForallTy(List(a@3),FunTy(Tup(List(Fld(‹›,Ref(a@3),None))),Ref(a@3)))‹› }‹›
//│ ╔══[ERROR] Cannot constrain skolem α4_1
//│ ╙──
//│ ╔══[ERROR] Cannot constrain skolem α4_1
//│ ╙──
//│ Type: forall α4_1: (α4_1) ->{⊥} α4_1

let t = 42 in ((x => x): forall (a): a -> a)
//│ Elab: { { let t@1 = 42‹›; Lam(List(x@2),Ref(x@2)): ForallTy(List(a@3),FunTy(Tup(List(Fld(‹›,Ref(a@3),None))),Ref(a@3)))‹› }‹› }‹›
//│ Type: forall α7_1: (α7_1) ->{⊥} α7_1


id(42)
//│ Elab: { id#1(42‹›)‹›‹› }‹›
//│ Type: α9_0
//│ Where:
//│   ⊤ ∧ ¬⊥ ∧ α10_0 <: α9_0
//│   Int ∧ ¬⊥ <: α10_0

id("abc")
//│ Elab: { id#2("abc"‹›)‹›‹› }‹›
//│ Type: α12_0
//│ Where:
//│   ⊤ ∧ ¬⊥ ∧ α13_0 <: α12_0
//│   Str ∧ ¬⊥ <: α13_0


class Pair[A, B](a: A, b: B)
//│ Elab: { class Pair[out A@1, out B@2](a@3: A@1#0, b@4: B@2#0) { }‹›; }‹›
//│ Type: ⊤

new Pair(42, true)
//│ Elab: { new class:Pair(Lit(IntLit(42)), Lit(BoolLit(true)))‹› }‹›
//│ Type: Pair[in α14_0 out α15_0, in α16_0 out α17_0]
//│ Where:
//│   Int ∧ ¬⊥ <: α15_0
//│   Bool ∧ ¬⊥ <: α17_0

fun swap: forall (a, b): Pair[out a, out b] -> Pair[out b, out a]
fun swap(p) = new Pair(Pair.b(p), Pair.a(p))
//│ Elab: { fun swap: forall a@2, b@3: FunTy(Tup(List(Fld(‹›,TyApp(Ref(class:Pair),List(WildcardTy(None,Some(Ref(a@2))), WildcardTy(None,Some(Ref(b@3))))),None))),TyApp(Ref(class:Pair),List(WildcardTy(None,Some(Ref(b@3))), WildcardTy(None,Some(Ref(a@2))))))‹›; fun swap(p@4): forall a@8, b@9: FunTy(Tup(List(Fld(‹›,TyApp(Ref(class:Pair),List(WildcardTy(None,Some(Ref(a@8))), WildcardTy(None,Some(Ref(b@9))))),None))),TyApp(Ref(class:Pair),List(WildcardTy(None,Some(Ref(b@9))), WildcardTy(None,Some(Ref(a@8))))))‹› = new class:Pair(App(Sel(Ref(class:Pair),Ident(b)),Tup(List(Fld(‹›,Ref(p@4),None)))), App(Sel(Ref(class:Pair),Ident(a)),Tup(List(Fld(‹›,Ref(p@4),None)))))‹›; }‹›
//│ Type: ⊤


swap
//│ Elab: { swap#0 }‹›
//│ Type: forall α18_1, α19_1: (Pair[out α18_1, out α19_1]) ->{⊥} Pair[out α19_1, out α18_1]

let t = new Pair(42, true) in swap(t)
//│ Elab: { { let t@1 = new class:Pair(Lit(IntLit(42)), Lit(BoolLit(true)))‹›; swap#1(t@1#0)‹›‹› }‹› }‹›
//│ Type: α37_0
//│ Where:
//│   Pair[out ⊤ ∧ ¬⊥ ∧ α39_0, out ⊤ ∧ ¬⊥ ∧ α38_0] ∧ ¬⊥ <: α37_0
//│   ⊤ ∧ ¬⊥ ∧ α35_0 <: α39_0
//│   Bool ∧ ¬⊥ <: α35_0
//│   ⊤ ∧ ¬⊥ ∧ α33_0 <: α38_0
//│   Int ∧ ¬⊥ <: α33_0

let t = new Pair("114", "514") in swap(t)
//│ Elab: { { let t@1 = new class:Pair(Lit(StrLit(114)), Lit(StrLit(514)))‹›; swap#2(t@1#0)‹›‹› }‹› }‹›
//│ Type: α45_0
//│ Where:
//│   Pair[out ⊤ ∧ ¬⊥ ∧ α47_0, out ⊤ ∧ ¬⊥ ∧ α46_0] ∧ ¬⊥ <: α45_0
//│   ⊤ ∧ ¬⊥ ∧ α43_0 <: α47_0
//│   Str ∧ ¬⊥ <: α43_0
//│   ⊤ ∧ ¬⊥ ∧ α41_0 <: α46_0
//│   Str ∧ ¬⊥ <: α41_0
