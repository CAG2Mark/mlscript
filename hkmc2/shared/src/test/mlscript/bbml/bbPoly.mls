:global
:bbml

42: [A] -> Int
//│ Elab: { Lit(IntLit(42)): Forall(List(A@1),Ref(class:Int))‹› }‹›
//│ Type: forall α0_1: Int

:e
42: [A] -> Str
//│ Elab: { Lit(IntLit(42)): Forall(List(A@1),Ref(class:Str))‹› }‹›
//│ ╔══[ERROR] Cannot solve Int ∧ ¬⊥
//│ ╙──
//│ Type: forall α1_1: Str

fun id: [A] -> A -> A
fun id(x) = x
//│ Elab: { fun id: forall A@2: FunTy(Tup(List(Fld(‹›,Ref(A@2),None))),Ref(A@2))‹›; fun id(x@3): forall A@5: FunTy(Tup(List(Fld(‹›,Ref(A@5),None))),Ref(A@5))‹› = x@3#0; }‹›
//│ Type: ⊤

id
//│ Elab: { id#0 }‹›
//│ Type: forall α2_1: (α2_1) ->{⊥} α2_1

[A] => (x: A) => x
//│ Elab: { forall A@1: Lam(List(Param(‹›,x@2,Some(Ref(A@1)))),Ref(x@2))‹› }‹›
//│ Type: forall α3_1: (α3_1) ->{⊥} α3_1

:e
[A] => (x: A) => x + 1
//│ Elab: { forall A@1: Lam(List(Param(‹›,x@2,Some(Ref(A@1)))),App(Ref(+),Tup(List(Fld(‹›,Ref(x@2),None), Fld(‹›,Lit(IntLit(1)),None)))))‹› }‹›
//│ ╔══[ERROR] Cannot constrain skolem α4_1
//│ ╙──
//│ Type: forall α4_1: (α4_1) ->{⊥} Int

:e
(x => x): [A] -> A -> A
//│ Elab: { Lam(List(Param(‹›,x@1,None)),Ref(x@1)): Forall(List(A@2),FunTy(Tup(List(Fld(‹›,Ref(A@2),None))),Ref(A@2)))‹› }‹›
//│ ╔══[ERROR] Cannot constrain skolem α5_1
//│ ╙──
//│ Type: forall α5_1: (α5_1) ->{⊥} α5_1

id: [A] -> A -> A
//│ Elab: { Ref(id): Forall(List(A@1),FunTy(Tup(List(Fld(‹›,Ref(A@1),None))),Ref(A@1)))‹› }‹›
//│ Type: forall α7_1: (α7_1) ->{⊥} α7_1

id: Int -> Int
//│ Elab: { Ref(id): FunTy(Tup(List(Fld(‹›,Ref(class:Int),None))),Ref(class:Int))‹› }‹›
//│ Type: (Int) ->{⊥} Int

fun myInc(inc: Int -> Int, x: Int) = inc(x)
//│ Elab: { fun myInc(inc@1: (class:Int#18)‹› -> class:Int#19‹›, x@2: class:Int#20) = inc@1#0(x@2#0)‹›‹›; }‹›
//│ Type: ⊤

myInc(id, 0)
//│ Elab: { myInc#0(id#3, 0‹›)‹›‹› }‹›
//│ Type: Int

let t = 42 in [A] => (x: A) => x
//│ Elab: { { let t@1 = 42‹›; forall A@2: Lam(List(Param(‹›,x@3,Some(Ref(A@2)))),Ref(x@3))‹› }‹› }‹›
//│ Type: forall α11_1: (α11_1) ->{⊥} α11_1


id(42)
//│ Elab: { id#4(42‹›)‹›‹› }‹›
//│ Type: α13_0
//│ Where:
//│   ⊤ ∧ ¬⊥ ∧ α14_0 <: α13_0
//│   Int ∧ ¬⊥ <: α14_0

id("abc")
//│ Elab: { id#5("abc"‹›)‹›‹› }‹›
//│ Type: α16_0
//│ Where:
//│   ⊤ ∧ ¬⊥ ∧ α17_0 <: α16_0
//│   Str ∧ ¬⊥ <: α17_0


class Pair[A, B](a: A, b: B)
//│ Elab: { class Pair[out A@1, out B@2](a@3: A@1#0, b@4: B@2#0) { }‹›; }‹›
//│ Type: ⊤

new Pair(42, true)
//│ Elab: { new class:Pair(Lit(IntLit(42)), Lit(BoolLit(true)))‹› }‹›
//│ Type: Pair[in α18_0 out α19_0, in α20_0 out α21_0]
//│ Where:
//│   Int ∧ ¬⊥ <: α19_0
//│   Bool ∧ ¬⊥ <: α21_0

fun swap: [A, B] -> Pair[out A, out B] -> Pair[out B, out A]
fun swap(p) = new Pair(Pair.b(p), Pair.a(p))
//│ Elab: { fun swap: forall A@2, B@3: FunTy(Tup(List(Fld(‹›,TyApp(Ref(class:Pair),List(WildcardTy(None,Some(Ref(A@2))), WildcardTy(None,Some(Ref(B@3))))),None))),TyApp(Ref(class:Pair),List(WildcardTy(None,Some(Ref(B@3))), WildcardTy(None,Some(Ref(A@2))))))‹›; fun swap(p@4): forall A@8, B@9: FunTy(Tup(List(Fld(‹›,TyApp(Ref(class:Pair),List(WildcardTy(None,Some(Ref(A@8))), WildcardTy(None,Some(Ref(B@9))))),None))),TyApp(Ref(class:Pair),List(WildcardTy(None,Some(Ref(B@9))), WildcardTy(None,Some(Ref(A@8))))))‹› = new class:Pair(App(Sel(Ref(class:Pair),Ident(b)),Tup(List(Fld(‹›,Ref(p@4),None)))), App(Sel(Ref(class:Pair),Ident(a)),Tup(List(Fld(‹›,Ref(p@4),None)))))‹›; }‹›
//│ Type: ⊤


swap
//│ Elab: { swap#0 }‹›
//│ Type: forall α22_1, α23_1: (Pair[in ⊥ out α22_1, in ⊥ out α23_1]) ->{⊥} Pair[in ⊥ out α23_1, in ⊥ out α22_1]

let t = new Pair(42, true) in swap(t)
//│ Elab: { { let t@1 = new class:Pair(Lit(IntLit(42)), Lit(BoolLit(true)))‹›; swap#1(t@1#0)‹›‹› }‹› }‹›
//│ Type: α41_0
//│ Where:
//│   Pair[in ⊥ out ⊤ ∧ ¬⊥ ∧ α43_0, in ⊥ out ⊤ ∧ ¬⊥ ∧ α42_0] ∧ ¬⊥ <: α41_0
//│   ⊤ ∧ ¬⊥ ∧ α39_0 <: α43_0
//│   Bool ∧ ¬⊥ <: α39_0
//│   ⊤ ∧ ¬⊥ ∧ α37_0 <: α42_0
//│   Int ∧ ¬⊥ <: α37_0

let t = new Pair("114", "514") in swap(t)
//│ Elab: { { let t@1 = new class:Pair(Lit(StrLit(114)), Lit(StrLit(514)))‹›; swap#2(t@1#0)‹›‹› }‹› }‹›
//│ Type: α49_0
//│ Where:
//│   Pair[in ⊥ out ⊤ ∧ ¬⊥ ∧ α51_0, in ⊥ out ⊤ ∧ ¬⊥ ∧ α50_0] ∧ ¬⊥ <: α49_0
//│   ⊤ ∧ ¬⊥ ∧ α47_0 <: α51_0
//│   Str ∧ ¬⊥ <: α47_0
//│   ⊤ ∧ ¬⊥ ∧ α45_0 <: α50_0
//│   Str ∧ ¬⊥ <: α45_0

let id = [A] => (x: A) => x in new Pair(id(42), id("42"))
//│ Elab: { { let id@1 = forall A@2: Lam(List(Param(‹›,x@3,Some(Ref(A@2)))),Ref(x@3))‹›; new class:Pair(App(Ref(id@1),Tup(List(Fld(‹›,Lit(IntLit(42)),None)))), App(Ref(id@1),Tup(List(Fld(‹›,Lit(StrLit(42)),None)))))‹› }‹› }‹›
//│ Type: Pair[in α53_0 out α54_0, in α55_0 out α56_0]
//│ Where:
//│   ⊤ ∧ ¬⊥ ∧ α58_0 <: α54_0
//│   ⊤ ∧ ¬⊥ ∧ α59_0 <: α58_0
//│   Int ∧ ¬⊥ <: α59_0
//│   ⊤ ∧ ¬⊥ ∧ α61_0 <: α56_0
//│   ⊤ ∧ ¬⊥ ∧ α62_0 <: α61_0
//│   Str ∧ ¬⊥ <: α62_0

fun foo: ([A] -> A -> A) -> Int
fun foo(x) = 42
//│ Elab: { fun foo: (forall A@2: FunTy(Tup(List(Fld(‹›,Ref(A@2),None))),Ref(A@2))‹›)‹› -> class:Int#21‹›; fun foo(x@3): (forall A@5: FunTy(Tup(List(Fld(‹›,Ref(A@5),None))),Ref(A@5))‹›)‹› -> class:Int#22‹› = 42‹›; }‹›
//│ Type: ⊤

foo
//│ Elab: { foo#0 }‹›
//│ Type: (forall α63_1: (α63_1) ->{⊥} α63_1) ->{⊥} Int

foo(id)
//│ Elab: { foo#1(id#6)‹›‹› }‹›
//│ Type: Int

foo([B] => (y: B) => y)
//│ Elab: { foo#2(forall B@2: Lam(List(Param(‹›,y@3,Some(Ref(B@2)))),Ref(y@3))‹›)‹›‹› }‹›
//│ Type: Int

:e
foo(x => x)
//│ Elab: { foo#3(λx@2. x@2#0‹›)‹›‹› }‹›
//│ ╔══[ERROR] Cannot constrain skolem α63_1
//│ ╙──
//│ Type: Int

class Foo(foo: [A] -> A -> A)
//│ Elab: { class Foo(foo@1: forall A@2: FunTy(Tup(List(Fld(‹›,Ref(A@2),None))),Ref(A@2))‹›) { }‹›; }‹›
//│ Type: ⊤

new Foo(id)
//│ Elab: { new class:Foo(Ref(id))‹› }‹›
//│ Type: Foo

:e
new Foo(x => x)
//│ Elab: { new class:Foo(Lam(List(Param(‹›,x@1,None)),Ref(x@1)))‹› }‹›
//│ ╔══[ERROR] Cannot constrain skolem α71_1
//│ ╙──
//│ Type: Foo

let foo = new Foo(id) in Foo.foo(foo)(42)
//│ Elab: { { let foo@1 = new class:Foo(Ref(id))‹›; class:Foo#0.foo‹›(foo@1#0)‹›‹›(42‹›)‹›‹› }‹› }‹›
//│ Type: α76_0
//│ Where:
//│   ⊤ ∧ ¬⊥ ∧ α77_0 <: α76_0
//│   Int ∧ ¬⊥ <: α77_0

class Bar[A](x: A, f: [B] -> B -> B)
//│ Elab: { class Bar[out A@1](x@2: A@1#0, f@3: forall B@4: FunTy(Tup(List(Fld(‹›,Ref(B@4),None))),Ref(B@4))‹›) { }‹›; }‹›
//│ Type: ⊤


new Bar(0, id)
//│ Elab: { new class:Bar(Lit(IntLit(0)), Ref(id))‹› }‹›
//│ Type: Bar[in α78_0 out α79_0]
//│ Where:
//│   Int ∧ ¬⊥ <: α79_0

let bar = new Bar(0, id) in Bar.f(bar)(Bar.x(bar))
//│ Elab: { { let bar@1 = new class:Bar(Lit(IntLit(0)), Ref(id))‹›; class:Bar#0.f‹›(bar@1#0)‹›‹›(class:Bar#1.x‹›(bar@1#1)‹›‹›)‹›‹› }‹› }‹›
//│ Type: α92_0
//│ Where:
//│   ⊤ ∧ ¬⊥ ∧ α93_0 <: α92_0
//│   ⊤ ∧ ¬⊥ ∧ α90_0 <: α93_0
//│   ⊤ ∧ ¬⊥ ∧ α83_0 <: α90_0
//│   Int ∧ ¬⊥ <: α83_0

class Some[A](value: A)
//│ Elab: { class Some[out A@1](value@2: A@1#0) { }‹›; }‹›
//│ Type: ⊤

new Some([A] => (x: A) => x)
//│ Elab: { new class:Some(Forall(List(A@1),Lam(List(Param(‹›,x@2,Some(Ref(A@1)))),Ref(x@2))))‹› }‹›
//│ Type: Some[in α94_0 out α95_0]
//│ Where:
//│   (⊤ ∧ ¬⊥ ∧ α97_0) ->{⊥} ⊤ ∧ ¬⊥ ∧ α97_0 ∧ ¬⊥ <: α95_0

:fixme
let s = new Some([A] => (x: A) => x) in let t = Some.value(s)(42) in Some.value(s)(false)
//│ Elab: { { let s@1 = new class:Some(Forall(List(A@2),Lam(List(Param(‹›,x@3,Some(Ref(A@2)))),Ref(x@3))))‹›; { let t@4 = class:Some#0.value‹›(s@1#0)‹›‹›(42‹›)‹›‹›; class:Some#1.value‹›(s@1#1)‹›‹›(false‹›)‹›‹› }‹› }‹› }‹›
//│ Type: α109_0
//│ Where:
//│   ⊤ ∧ ¬⊥ ∧ α101_0 <: α109_0
//│   Bool ∧ ¬⊥ <: α101_0
//│   Int ∧ ¬⊥ <: α101_0

fun gen(x) =
  let t = x + 1 in [A] => (y: A) => y
//│ Elab: { fun gen(x@1) = { let t@2 = +#1(x@1#0, 1‹›)‹›‹›; forall A@4: Lam(List(Param(‹›,y@5,Some(Ref(A@4)))),Ref(y@5))‹› }‹›; }‹›
//│ Type: ⊤

gen
//│ Elab: { gen#0 }‹›
//│ Type: (α110_0) ->{⊥} forall α111_1: (α111_1) ->{⊥} α111_1
//│ Where:
//│   α110_0 <: ¬⊤ ∧ ¬⊥ ∨ Int


gen(42)
//│ Elab: { gen#1(42‹›)‹›‹› }‹›
//│ Type: forall α111_1: (α111_1) ->{⊥} α111_1

// FIXME: toLoc
:fixme
:e
fun cnt: Some[out [A] -> A -> A] -> Int
fun cnt(x) = 42
//│ Elab: { fun cnt: (class:Some#2[WildcardTy(None,Some(Forall(List(A@2),FunTy(Tup(List(Fld(‹›,Ref(A@2),None))),Ref(A@2)))))]‹›)‹› -> class:Int#23‹›; fun cnt(x@3): (class:Some#3[WildcardTy(None,Some(Forall(List(A@5),FunTy(Tup(List(Fld(‹›,Ref(A@5),None))),Ref(A@5)))))]‹›)‹› -> class:Int#24‹› = 42‹›; }‹›
//│ /!!!\ Uncaught error: scala.NotImplementedError: an implementation is missing
