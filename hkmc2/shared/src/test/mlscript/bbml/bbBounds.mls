:bbml
//│ Type: ⊤


(x => x + 1): [A extends Int] -> A -> Int
//│ Type: (Int) ->{⊥} Int


(x => x): [A restricts Int] -> A -> A
//│ Type: forall A4_2: (A4_2) ->{⊥} A4_2
//│ Where:
//│   Int <: A4_2


(x => x - 1): [A extends Int restricts Int] -> A -> A
//│ Type: forall A6_2: (A6_2) ->{⊥} A6_2
//│ Where:
//│   Int <: A6_2
//│   A6_2 <: Int

fun iid: [A extends Int] -> A -> A
fun iid(x) = x
//│ Type: ⊤

iid
//│ Type: forall A9_2: (A9_2) ->{⊥} A9_2
//│ Where:
//│   A9_2 <: Int

:e
iid("42")
//│ ╔══[ERROR] Type error in string literal with expected type A11_1
//│ ║  l.31: 	iid("42")
//│ ║        	    ^^^^
//│ ╟── because: cannot constrain  Str  <:  A11_1
//│ ╟── because: cannot constrain  Str  <:  A11_1
//│ ╙── because: cannot constrain  Str  <:  Int
//│ Type: Str


iid(42)
//│ Type: Int

class Foo[A]
//│ Type: ⊤

fun foo: [A extends Foo[in Nothing out Any] restricts Foo[in Num]] -> A -> A
foo
//│ Type: forall A13_2: (A13_2) ->{⊥} A13_2
//│ Where:
//│   Foo[in Num] <: A13_2
//│   A13_2 <: Foo[?]

fun bar: Foo[in Num out Int]
//│ Type: ⊤

foo(bar)
//│ Type: Foo[in Num out Int] ∨ Foo[in Num]

:e
fun badfoo: [A extends Str restricts Int] -> A -> A
//│ ╔══[ERROR] Type error in block
//│ ║  l.61: 	fun badfoo: [A extends Str restricts Int] -> A -> A
//│ ║        	                                             ^^^^^^
//│ ╙── because: cannot constrain  Int  <:  Str
//│ Type: ⊤


fun baz: [A extends B, B extends A] -> A -> B
baz
//│ Type: (⊤) ->{⊥} ⊤

fun bazbaz: [A extends Int] -> A -> [B extends A] -> B
bazbaz
//│ Type: (Int) ->{⊥} forall B19_3: ⊥

fun foofun: [A extends Int -> Int restricts Any -> Int] -> A -> Int -> Int
foofun
//│ Type: (Int -> Int) ->{⊥} (Int) ->{⊥} Int

foofun(x => x + 1)(42)
//│ Type: Int

fun bazbaz: [A extends Int] -> A -> ([B extends A -> A restricts A -> A] -> B) -> A
bazbaz
//│ Type: forall A23_2: (A23_2) ->{⊥} (forall B24_3: A23_2 -> A23_2) ->{⊥} A23_2
//│ Where:
//│   A23_2 <: Int

bazbaz(42)(x => x + 1)
//│ Type: Int

fun cc: [A extends B -> B restricts B -> B, B extends A -> A restricts A -> A] -> A -> B -> Bool
cc
//│ Type: forall A28_2, B29_2: (A28_2) ->{⊥} (B29_2) ->{⊥} Bool
//│ Where:
//│   A28_2 -> A28_2 <: B29_2
//│   B29_2 <: A28_2 -> A28_2
//│   B29_2 -> B29_2 <: A28_2
//│   A28_2 <: B29_2 -> B29_2

fun w: Any -> Nothing
//│ Type: ⊤

cc(w)(w)
//│ Type: Bool

fun h: [C] -> ([A extends Int] -> A -> ([B extends A -> A restricts A -> A] -> B) -> A) -> C -> Int
//│ Type: ⊤

:e
bazbaz: [A extends Int] -> A -> ([B extends A -> A restricts A -> A] -> B) -> A
//│ ╔══[ERROR] Cannot type non-function term Sel(Ref(globalThis:block#16),Ident(bazbaz)) as (<A>37_2) ->{⊥} (forall B36_3: B36_3) ->{⊥} <A>37_2
//│ ║  l.112: 	bazbaz: [A extends Int] -> A -> ([B extends A -> A restricts A -> A] -> B) -> A
//│ ╙──       	^^^^^^
//│ Type: forall A35_2: (A35_2) ->{⊥} (forall B36_3: A35_2 -> A35_2) ->{⊥} A35_2
//│ Where:
//│   A35_2 <: Int


(x => f => bazbaz(x)(f)): [A extends Int] -> A -> ([B extends A -> A restricts A -> A] -> B) -> A
//│ Type: forall A38_2: (A38_2) ->{⊥} (forall B39_3: A38_2 -> A38_2) ->{⊥} A38_2
//│ Where:
//│   A38_2 <: Int


h(x => f => bazbaz(x)(f))(42)
//│ Type: Int

