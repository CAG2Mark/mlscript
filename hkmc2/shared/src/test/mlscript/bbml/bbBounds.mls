:bbml
//│ Type: ⊤

//│ Type: ⊤

(x => x + 1): [A extends Int] -> A -> Int
//│ Type: (Int) ->{⊥} Int


(x => x): [A restricts Int] -> A -> A
//│ Type: forall A5_2: (A5_2) ->{⊥} A5_2
//│ Where:
//│   Int <: A5_2


(x => x - 1): [A extends Int restricts Int] -> A -> A
//│ Type: forall A7_2: (A7_2) ->{⊥} A7_2
//│ Where:
//│   Int <: A7_2
//│   A7_2 <: Int

fun iid: [A extends Int] -> A -> A
fun iid(x) = x
//│ Type: ⊤

iid
//│ Type: forall A10_2: (A10_2) ->{⊥} A10_2
//│ Where:
//│   A10_2 <: Int

:e
iid("42")
//│ ╔══[ERROR] Type error in string literal with expected type A12_1
//│ ║  l.32: 	iid("42")
//│ ║        	    ^^^^
//│ ╟── because: cannot constrain  Str  <:  A12_1
//│ ╟── because: cannot constrain  Str  <:  A12_1
//│ ╙── because: cannot constrain  Str  <:  Int
//│ Type: Str


iid(42)
//│ Type: Int

class Foo[A]
//│ Type: ⊤

fun foo: [A extends Foo[in Nothing out Any] restricts Foo[in Num]] -> A -> A
foo
//│ Type: forall A14_2: (A14_2) ->{⊥} A14_2
//│ Where:
//│   Foo[in Num] <: A14_2
//│   A14_2 <: Foo[?]

fun bar: Foo[in Num out Int]
//│ Type: ⊤

foo(bar)
//│ Type: Foo[in Num out Int] ∨ Foo[in Num]

:e
fun badfoo: [A extends Str restricts Int] -> A -> A
//│ ╔══[ERROR] Type error in block
//│ ║  l.62: 	fun badfoo: [A extends Str restricts Int] -> A -> A
//│ ║        	                                             ^^^^^^
//│ ╙── because: cannot constrain  Int  <:  Str
//│ Type: ⊤


fun baz: [A extends B, B extends A] -> A -> B
baz
//│ Type: (⊤) ->{⊥} ⊤

fun bazbaz: [A extends Int] -> A -> [B extends A] -> B
bazbaz
//│ Type: (Int) ->{⊥} forall B20_3: ⊥

fun foofun: [A extends Int -> Int restricts Any -> Int] -> A -> Int -> Int
foofun
//│ Type: (Int -> Int) ->{⊥} (Int) ->{⊥} Int

foofun(x => x + 1)(42)
//│ Type: Int

fun bazbaz: [A extends Int] -> A -> ([B extends A -> A restricts A -> A] -> B) -> A
bazbaz
//│ Type: forall A24_2: (A24_2) ->{⊥} (forall B25_3: A24_2 -> A24_2) ->{⊥} A24_2
//│ Where:
//│   A24_2 <: Int

bazbaz(42)(x => x + 1)
//│ Type: Int

fun cc: [A extends B -> B restricts B -> B, B extends A -> A restricts A -> A] -> A -> B -> Bool
cc
//│ Type: forall A29_2, B30_2: (A29_2) ->{⊥} (B30_2) ->{⊥} Bool
//│ Where:
//│   A29_2 -> A29_2 <: B30_2
//│   B30_2 <: A29_2 -> A29_2
//│   B30_2 -> B30_2 <: A29_2
//│   A29_2 <: B30_2 -> B30_2

fun w: Any -> Nothing
//│ Type: ⊤

cc(w)(w)
//│ Type: Bool

fun h: [C] -> ([A extends Int] -> A -> ([B extends A -> A restricts A -> A] -> B) -> A) -> C -> Int
//│ Type: ⊤

:e
bazbaz: [A extends Int] -> A -> ([B extends A -> A restricts A -> A] -> B) -> A
//│ ╔══[ERROR] Cannot type non-function term SynthSel(Ref(globalThis:block#17),Ident(bazbaz)) as (<A>38_2) ->{⊥} (forall B37_3: B37_3) ->{⊥} <A>38_2
//│ ║  l.113: 	bazbaz: [A extends Int] -> A -> ([B extends A -> A restricts A -> A] -> B) -> A
//│ ╙──       	^^^^^^
//│ Type: forall A36_2: (A36_2) ->{⊥} (forall B37_3: A36_2 -> A36_2) ->{⊥} A36_2
//│ Where:
//│   A36_2 <: Int


(x => f => bazbaz(x)(f)): [A extends Int] -> A -> ([B extends A -> A restricts A -> A] -> B) -> A
//│ Type: forall A39_2: (A39_2) ->{⊥} (forall B40_3: A39_2 -> A39_2) ->{⊥} A39_2
//│ Where:
//│   A39_2 <: Int


h(x => f => bazbaz(x)(f))(42)
//│ Type: Int

