:global
:bbml



fun letreg: [E,Res] -> ([R] -> Region[R] ->{E | R} Res) ->{E} Res
//│ Type: ⊤

letreg
//│ Type: forall α1_2, α2_2: (forall α3_3: (Region[α3_3]) ->{α1_2 ∨ α3_3} α2_2) ->{α1_2} α2_2

letreg(r => r)
//│ Type: Region[?]

:e
letreg(r => r).ref 1
//│ ╔══[ERROR] Type error in term (letreg#2(λr@3. r@3#0)).ref 1
//│ ╟── because: cannot constrain  α7_1  <:  Region[α8_1]
//│ ╟── because: cannot constrain  α7_1  <:  Region[((⊤ ∧ ⊤) ∧ α8_1) ∨ ⊥]
//│ ╟── because: cannot constrain  Region[out ⊤ ∧ ⊤]  <:  Region[((⊤ ∧ ⊤) ∧ α8_1) ∨ ⊥]
//│ ╟── because: cannot constrain  ((⊤ ∧ ⊤) ∧ ⊤) ∨ ⊥  <:  ((⊤ ∧ ⊤) ∧ α8_1) ∨ ⊥
//│ ╟── because: cannot constrain  ⊤  <:  α8_1
//│ ╙── because: cannot constrain  ⊤  <:  ⊥
//│ ╔══[ERROR] Type error in term { (letreg#2(λr@3. r@3#0)).ref 1 }
//│ ╟── because: cannot constrain  α8_1 ∨ α6_1  <:  <α>0_0
//│ ╟── because: cannot constrain  α8_1  <:  <α>0_0
//│ ╙── because: cannot constrain  ⊤  <:  <α>0_0
//│ Type: Ref[Int, ?]

letreg(r => r.ref 1)
//│ Type: Ref[Int, ?]

letreg(r => !(r.ref 1))
//│ Type: Int

:e
!letreg(r => r.ref 1)
//│ ╔══[ERROR] General type is not allowed here.
//│ ╙──
//│ Type: ⊥

:fixme
letreg of r =>
  let x = ref 1
  x := !x + 1
  !x
//│ ╔══[PARSE ERROR] Expected 'let' keyword, 'new' keyword, 'in' keyword, 'if' keyword, 'case' keyword, 'region' keyword, 'fun' keyword, 'val' keyword, 'type' keyword, 'class' keyword, 'trait' keyword, 'module' keyword, 'abstract' keyword, 'mut' keyword, 'virtual' keyword, 'override' keyword, 'declare' keyword, 'public' keyword, 'private' keyword, 'out' keyword, expression, 'true' keyword, or 'false' keyword after start of statement; found indented block instead
//│ ║  l.44: 	  let x = ref 1
//│ ╙──      	^^
//│ Type: ⊥

let f = letreg(r => arg => r.ref arg)
//│ Type: ⊤

:e
f
//│ ╔══[ERROR] Variable not found: f
//│ ╙──
//│ Type: ⊥

:e
letreg(r => arg => r.ref arg)(0)
//│ ╔══[ERROR] Type error in term { letreg#8(λr@4. λarg@5. (r@4#0).ref arg@5#0)(0) }
//│ ╟── because: cannot constrain  α44_1 ∨ α35_1  <:  <α>0_0
//│ ╟── because: cannot constrain  α44_1  <:  <α>0_0
//│ ╟── because: cannot constrain  α43_1  <:  <α>0_0
//│ ╙── because: cannot constrain  ⊤  <:  <α>0_0
//│ Type: Ref[in α40_1 out α40_1 ∨ Int, ?]



// * An incorrect one, just for testing the error:

fun letreg: [E,Res] -> ([R] -> Region[R] -> Res) ->{E} Res
//│ Type: ⊤

:e
letreg(r => r.ref 1)
//│ ╔══[ERROR] Type error in term λr@3. (r@3#0).ref 1 with expected type (Region[<α>48_2]) ->{⊥} α50_1
//│ ╟── because: cannot constrain  α51_2  <:  ⊥
//│ ╙── because: cannot constrain  <α>48_2  <:  ⊥
//│ Type: Ref[Int, ?]

:e
letreg(r => !(r.ref 1))
//│ ╔══[ERROR] Type error in term λr@3. !RegRef(Ref(r@3),Lit(IntLit(1))) with expected type (Region[<α>48_2]) ->{⊥} α54_1
//│ ╟── because: cannot constrain  α56_2 ∨ α55_2  <:  ⊥
//│ ╟── because: cannot constrain  α56_2  <:  ⊥
//│ ╟── because: cannot constrain  α55_2  <:  ⊥
//│ ╙── because: cannot constrain  <α>48_2  <:  ⊥
//│ ╔══[ERROR] Type error in term λr@3. !RegRef(Ref(r@3),Lit(IntLit(1))) with expected type (Region[<α>48_2]) ->{⊥} α54_1
//│ ╟── because: cannot constrain  α56_2 ∨ α55_2  <:  ⊥
//│ ╟── because: cannot constrain  α55_2  <:  ⊥
//│ ╙── because: cannot constrain  <α>48_2  <:  ⊥
//│ Type: Int


