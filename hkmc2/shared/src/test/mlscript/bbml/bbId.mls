:global
:bbml


fun id(x) = x
//│ Elab: { fun id(x@2) = x@2#0; }‹›
//│ Type: ⊤

id(1)
//│ Elab: { id#0(1‹›)‹› }‹›
//│ Type: Int

id
//│ Elab: { id#1 }‹›
//│ Type: α2_1 ->{⊥} α2_1
//│ Where:
//│   Int <: α2_1

id(true)
//│ Elab: { id#2(true‹›)‹› }‹›
//│ Type: Bool ∨ Int

id
//│ Elab: { id#3 }‹›
//│ Type: α2_1 ->{⊥} α2_1
//│ Where:
//│   Bool <: α2_1
//│   Int <: α2_1


fun id(x) = x
//│ Elab: { fun id(x@2) = x@2#0; }‹›
//│ Type: ⊤

:e
id : [A] -> A -> A
//│ Elab: { Ref(id): Forall(List(A@2),FunTy(Tup(List(Fld(‹›,Ref(A@2),None))),Ref(A@2),None))‹› }‹›
//│ ╔══[ERROR] Type error in term Ref(id) with expected type (<α>9_2) ->{⊥} <α>9_2
//│ ╟── because: cannot constrain  α7_1  <:  <α>9_2 ->{⊥} <α>9_2
//│ ╟── because: cannot constrain  α7_1  <:  (⊤ ∧ ⊤) ->{⊥ ∨ ⊥} ⊥
//│ ╟── because: cannot constrain  (((⊤ ∧ ⊤) ∧ α8_1) ∨ ⊥) ->{⊥ ∨ ⊥} (((⊤ ∧ ⊤) ∧ α8_1) ∨ ⊥)  <:  (⊤ ∧ ⊤) ->{⊥ ∨ ⊥} ⊥
//│ ╟── because: cannot constrain  ((⊤ ∧ ⊤) ∧ α8_1) ∨ ⊥  <:  ⊥ ∨ ⊥
//│ ╟── because: cannot constrain  α8_1  <:  ⊥
//│ ╙── because: cannot constrain  ⊤  <:  ⊥
//│ Type: forall α9_2: (α9_2) ->{⊥} α9_2


(y => y) : [A] -> A -> A
//│ Elab: { Lam(List(Param(‹›,y@2,None)),Ref(y@2)): Forall(List(A@3),FunTy(Tup(List(Fld(‹›,Ref(A@3),None))),Ref(A@3),None))‹› }‹›
//│ Type: forall α10_2: (α10_2) ->{⊥} α10_2

:fixme
fun id(x) = x
(y => id(y)) : [A] -> A -> A
//│ Elab: { fun id(x@2) = x@2#0; Lam(List(Param(‹›,y@4,None)),App(Ref(id),Tup(List(Fld(‹›,Ref(y@4),None))))): Forall(List(A@6),FunTy(Tup(List(Fld(‹›,Ref(A@6),None))),Ref(A@6),None))‹› }‹›
//│ ╔══[ERROR] Type error in term Lam(List(Param(‹›,y@4,None)),App(Ref(id),Tup(List(Fld(‹›,Ref(y@4),None))))) with expected type (<α>13_2) ->{⊥} <α>13_2
//│ ╟── because: cannot constrain  α15_2  <:  <α>13_2
//│ ╟── because: cannot constrain  α16_1  <:  <α>13_2
//│ ╟── because: cannot constrain  α16_1  <:  ⊥
//│ ╟── because: cannot constrain  α12_1  <:  ⊥
//│ ╙── because: cannot constrain  ⊤  <:  ⊥
//│ Type: forall α13_2: (α13_2) ->{⊥} α13_2





