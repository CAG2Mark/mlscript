:global
:bbml


123
//│ Elab: { 123‹› }‹›
//│ Type: Int

3.14
//│ Elab: { 3.14‹› }‹›
//│ Type: Num

false
//│ Elab: { false‹› }‹›
//│ Type: Bool

"bbml"
//│ Elab: { "bbml"‹› }‹›
//│ Type: Str

()
//│ Elab: { }‹›
//│ Type: ⊤

fun id(x) = x
//│ Elab: { fun id(x@1) = x@1#0; }‹›
//│ Type: ⊤

fun inc(x) = x + 1
//│ Elab: { fun inc(x@1) = +#0(x@1#0, 1‹›)‹›‹›; }‹›
//│ Type: ⊤

fun mul(x, y) = x * y
//│ Elab: { fun mul(x@1, y@2) = *#0(x@1#0, y@2#0)‹›‹›; }‹›
//│ Type: ⊤

x => x
//│ Elab: { λx@1. x@1#0‹› }‹›
//│ Type: (α5_0) ->{⊥} α5_0

+
//│ Elab: { +#1 }‹›
//│ Type: (Int, Int) ->{⊥} Int

(x, y) => x + y
//│ Elab: { λx@1, y@2. +#2(x@1#0, y@2#0)‹›‹›‹› }‹›
//│ Type: (α6_0, α7_0) ->{⊥ ∨ ⊥ ∨ ⊥ ∨ ⊥} Int
//│ Where:
//│   α6_0 <: ¬⊤ ∧ ¬⊥ ∨ Int
//│   α7_0 <: ¬⊤ ∧ ¬⊥ ∨ Int

((x, y) => x + y)(40, 2)
//│ Elab: { λx@2, y@3. +#3(x@2#0, y@3#0)‹›‹›‹›(40‹›, 2‹›)‹›‹› }‹›
//│ Type: Int

:e
114 + "514"
//│ Elab: { +#4(114‹›, "514"‹›)‹›‹› }‹›
//│ ╔══[ERROR] Cannot solve Str ∧ ¬⊥
//│ ╙──
//│ Type: Int


inc(42)
//│ Elab: { inc#0(42‹›)‹›‹› }‹›
//│ Type: Int

let x = 42 in x
//│ Elab: { { let x@1 = 42‹›; x@1#0 }‹› }‹›
//│ Type: Int

let x = 1 in let y = 2 in x + y
//│ Elab: { { let x@1 = 1‹›; { let y@2 = 2‹›; +#5(x@1#0, y@2#0)‹›‹› }‹› }‹› }‹›
//│ Type: Int

:e
let x = 0 in x + "1"
//│ Elab: { { let x@1 = 0‹›; +#6(x@1#0, "1"‹›)‹›‹› }‹› }‹›
//│ ╔══[ERROR] Cannot solve Str ∧ ¬⊥
//│ ╙──
//│ Type: Int

class Foo(x: Int)
//│ Elab: { class Foo(x@1: class:Int#15) { }‹›; }‹›
//│ Type: ⊤

:e
new Nothingness(0)
//│ ╔══[ERROR] Class Nothingness not found.
//│ ║  l.88: 	new Nothingness(0)
//│ ╙──      	               ^^^
//│ Elab: { <error>‹› }‹›
//│ Type: ⊥

:e
new 42
//│ ╔══[ERROR] Illegal new expression.
//│ ╙──
//│ Elab: { <error>‹› }‹›
//│ Type: ⊥


new Foo(42)
//│ Elab: { new class:Foo(Lit(IntLit(42)))‹› }‹›
//│ Type: Foo


class Point(x: Num, y: Num, z: Num)
//│ Elab: { class Point(x@1: class:Num#13, y@2: class:Num#14, z@3: class:Num#15) { }‹›; }‹›
//│ Type: ⊤


new Point(0.0, 0.0, 0.0)
//│ Elab: { new class:Point(Lit(DecLit(0.0)), Lit(DecLit(0.0)), Lit(DecLit(0.0)))‹› }‹›
//│ Type: Point

:e
new Foo("1!5!")
//│ Elab: { new class:Foo(Lit(StrLit(1!5!)))‹› }‹›
//│ ╔══[ERROR] Cannot solve Str ∧ ¬⊥
//│ ╙──
//│ Type: Foo


class Some[A](value: A)
//│ Elab: { class Some[out A@1](value@2: A@1#0) { }‹›; }‹›
//│ Type: ⊤

new Some(true)
//│ Elab: { new class:Some(Lit(BoolLit(true)))‹› }‹›
//│ Type: Some[in α10_0 out α11_0]
//│ Where:
//│   Bool ∧ ¬⊥ <: α11_0

new Some(42)
//│ Elab: { new class:Some(Lit(IntLit(42)))‹› }‹›
//│ Type: Some[in α12_0 out α13_0]
//│ Where:
//│   Int ∧ ¬⊥ <: α13_0

let p = new Point(1.0, 0.0, 0.0) in Point.x(p)
//│ Elab: { { let p@1 = new class:Point(Lit(DecLit(1.0)), Lit(DecLit(0.0)), Lit(DecLit(0.0)))‹›; class:Point#0.x‹›(p@1#0)‹›‹› }‹› }‹›
//│ Type: Num

let t = new Some(true) in Some.value(t)
//│ Elab: { { let t@1 = new class:Some(Lit(BoolLit(true)))‹›; class:Some#0.value‹›(t@1#0)‹›‹› }‹› }‹›
//│ Type: α17_0
//│ Where:
//│   ⊤ ∧ ¬⊥ ∧ α15_0 <: α17_0
//│   Bool ∧ ¬⊥ <: α15_0

:e
Some.value(42)
//│ Elab: { class:Some#1.value‹›(42‹›)‹›‹› }‹›
//│ ╔══[ERROR] Cannot solve Int ∧ ¬⊥
//│ ╙──
//│ Type: α19_0


class Printer[T](f: T -> Str)
//│ Elab: { class Printer[in T@1](f@2: (T@1#0)‹› -> class:Str#0‹›) { }‹›; }‹›
//│ Type: ⊤

fun foofoo(x) =
  let t = x + 1 in "foo"
//│ Elab: { fun foofoo(x@1) = { let t@2 = +#7(x@1#0, 1‹›)‹›‹›; "foo"‹› }‹›; }‹›
//│ Type: ⊤

new Printer(foofoo)
//│ Elab: { new class:Printer(Ref(foofoo))‹› }‹›
//│ Type: Printer[in α21_0 out α22_0]
//│ Where:
//│   α21_0 <: ¬⊤ ∧ ¬⊥ ∨ Int

let ip = new Printer(foofoo) in Printer.f(ip)(42)
//│ Elab: { { let ip@1 = new class:Printer(Ref(foofoo))‹›; class:Printer#0.f‹›(ip@1#0)‹›‹›(42‹›)‹›‹› }‹› }‹›
//│ Type: Str

:e
let ip = new Printer(foofoo) in Printer.f(ip)("42")
//│ Elab: { { let ip@1 = new class:Printer(Ref(foofoo))‹›; class:Printer#1.f‹›(ip@1#0)‹›‹›("42"‹›)‹›‹› }‹› }‹›
//│ ╔══[ERROR] Cannot solve Str ∧ ¬⊥
//│ ╙──
//│ Type: Str

class TFun[T](f: T -> T)
//│ Elab: { class TFun[in out T@1](f@2: (T@1#0)‹› -> T@1#1‹›) { }‹›; }‹›
//│ Type: ⊤

fun inc(x) = x + 1
//│ Elab: { fun inc(x@1) = +#8(x@1#0, 1‹›)‹›‹›; }‹›
//│ Type: ⊤

new TFun(inc)
//│ Elab: { new class:TFun(Ref(inc))‹› }‹›
//│ Type: TFun[in α32_0 out α33_0]
//│ Where:
//│   α32_0 <: ¬⊤ ∧ ¬⊥ ∨ Int
//│   Int ∧ ¬⊥ <: α33_0

let tf = new TFun(inc) in TFun.f(tf)(1)
//│ Elab: { { let tf@1 = new class:TFun(Ref(inc))‹›; class:TFun#0.f‹›(tf@1#0)‹›‹›(1‹›)‹›‹› }‹› }‹›
//│ Type: α37_0
//│ Where:
//│   ⊤ ∧ ¬⊥ ∧ α35_0 <: α37_0
//│   Int ∧ ¬⊥ <: α35_0

:e
let tf = new TFun(inc) in TFun.f(tf)("1")
//│ Elab: { { let tf@1 = new class:TFun(Ref(inc))‹›; class:TFun#1.f‹›(tf@1#0)‹›‹›("1"‹›)‹›‹› }‹› }‹›
//│ ╔══[ERROR] Cannot solve Str ∧ ¬⊥
//│ ╙──
//│ Type: α41_0
//│ Where:
//│   ⊤ ∧ ¬⊥ ∧ α39_0 <: α41_0
//│   Int ∧ ¬⊥ <: α39_0

class Pair[A, B](fst: A, snd: B)
//│ Elab: { class Pair[out A@1, out B@2](fst@3: A@1#0, snd@4: B@2#0) { }‹›; }‹›
//│ Type: ⊤

Pair.fst(new Pair(42, true))
//│ Elab: { class:Pair#0.fst‹›(new class:Pair(Lit(IntLit(42)), Lit(BoolLit(true)))‹›)‹›‹› }‹›
//│ Type: α47_0
//│ Where:
//│   ⊤ ∧ ¬⊥ ∧ α43_0 <: α47_0
//│   Int ∧ ¬⊥ <: α43_0

Pair.snd(new Pair(42, true))
//│ Elab: { class:Pair#1.snd‹›(new class:Pair(Lit(IntLit(42)), Lit(BoolLit(true)))‹›)‹›‹› }‹›
//│ Type: α57_0
//│ Where:
//│   ⊤ ∧ ¬⊥ ∧ α53_0 <: α57_0
//│   Bool ∧ ¬⊥ <: α53_0


if 1 < 2 then 1 else 0
//│ Elab: { if Cons(Boolean(App(Ref(<),Tup(List(Fld(‹›,Lit(IntLit(1)),None), Fld(‹›,Lit(IntLit(2)),None)))),Else(Lit(IntLit(1)))),Else(Lit(IntLit(0))))‹› }‹›
//│ Type: Int ∨ Int

if false then 1 else "1"
//│ Elab: { if Cons(Boolean(Lit(BoolLit(false)),Else(Lit(IntLit(1)))),Else(Lit(StrLit(1))))‹› }‹›
//│ Type: Int ∨ Str


if 1 is Int then 1 else 0
//│ Elab: { if Cons(Match(Lit(IntLit(1)),Cons(PatternBranch(Class(class:Int,None,true),Else(Lit(IntLit(1)))),NoSplit)),Else(Lit(IntLit(0))))‹› }‹›
//│ Type: Int ∨ Int

fun test(x) =
  if x is Int then x + 1 else 0
test
//│ Elab: { fun test(x@1) = if Cons(Match(Ref(x@1),Cons(PatternBranch(Class(class:Int,None,true),Else(App(Ref(+),Tup(List(Fld(‹›,Ref(x@1),None), Fld(‹›,Lit(IntLit(1)),None)))))),NoSplit)),Else(Lit(IntLit(0))))‹›; test#0 }‹›
//│ Type: (α59_0) ->{⊥ ∨ ⊥ ∨ ⊥ ∨ ⊥ ∨ ⊥ ∨ ⊥} Int ∨ Int
//│ Where:
//│   α59_0 <: ¬Int ∧ ¬⊥ ∨ Int

test(1)
//│ Elab: { test#1(1‹›)‹›‹› }‹›
//│ Type: Int ∨ Int

test("1")
//│ Elab: { test#2("1"‹›)‹›‹› }‹›
//│ Type: Int ∨ Int

// TODO: annotation?
fun fact: Int -> Int
fun fact(n) =
  if n > 1 then n * fact(n - 1) else 1
//│ Elab: { fun fact: (class:Int#16)‹› -> class:Int#17‹›; fun fact(n@2): (class:Int#18)‹› -> class:Int#19‹› = if Cons(Boolean(App(Ref(>),Tup(List(Fld(‹›,Ref(n@2),None), Fld(‹›,Lit(IntLit(1)),None)))),Else(App(Ref(*),Tup(List(Fld(‹›,Ref(n@2),None), Fld(‹›,App(Ref(fact),Tup(List(Fld(‹›,App(Ref(-),Tup(List(Fld(‹›,Ref(n@2),None), Fld(‹›,Lit(IntLit(1)),None)))),None)))),None)))))),Else(Lit(IntLit(1))))‹›; }‹›
//│ Type: ⊤

fact
//│ Elab: { fact#1 }‹›
//│ Type: (Int) ->{⊥} Int

fun fact2: Int -> Int
fun fact2 = case
  0 then 1
  n then n * fact(n - 1)
//│ Elab: { fun fact2: (class:Int#20)‹› -> class:Int#21‹›; fun fact2: (class:Int#22)‹› -> class:Int#23‹› = λn@2. if Cons(Boolean(App(Ref(==),Tup(List(Fld(‹›,Ref(n@2),None), Fld(‹›,Lit(IntLit(0)),None)))),Else(Lit(IntLit(1)))),Else(App(Ref(*),Tup(List(Fld(‹›,Ref(n@2),None), Fld(‹›,App(Ref(fact),Tup(List(Fld(‹›,App(Ref(-),Tup(List(Fld(‹›,Ref(n@2),None), Fld(‹›,Lit(IntLit(1)),None)))),None)))),None))))))‹›‹›; }‹›
//│ Type: ⊤

fact2
//│ Elab: { fact2#0 }‹›
//│ Type: (Int) ->{⊥} Int
