:global
:bbml
:parseOnly

class Foo
//│ Parsed:
//│ 	TypeDef(Cls,Ident(Foo),None,None)

class Bar(x: Int)
//│ Parsed:
//│ 	TypeDef(Cls,App(Ident(Bar),Tup(List(InfixApp(Ident(x),keyword ':',Ident(Int))))),None,None)

class Bar2(x: Int, y: Int)
//│ Parsed:
//│ 	TypeDef(Cls,App(Ident(Bar2),Tup(List(InfixApp(Ident(x),keyword ':',Ident(Int)), InfixApp(Ident(y),keyword ':',Ident(Int))))),None,None)

class Baz[A]
//│ Parsed:
//│ 	TypeDef(Cls,TyApp(Ident(Baz),List(Ident(A))),None,None)

class BazBaz[A](f: A -> A)
//│ Parsed:
//│ 	TypeDef(Cls,App(TyApp(Ident(BazBaz),List(Ident(A))),Tup(List(InfixApp(Ident(f),keyword ':',InfixApp(Tup(List(Ident(A))),keyword '->',Ident(A)))))),None,None)

let x = 42 in x + 0
//│ Parsed:
//│ 	Let(Ident(x),IntLit(42),Some(App(Ident(+),Tup(List(Ident(x), IntLit(0))))))

fun id(x) = x
//│ Parsed:
//│ 	TermDef(Fun,None,Some(App(Ident(id),Tup(List(Ident(x))))),Some(Ident(x)))

x => x + 1
//│ Parsed:
//│ 	InfixApp(Tup(List(Ident(x))),keyword '=>',App(Ident(+),Tup(List(Ident(x), IntLit(1)))))

let bar = new Bar(42)
//│ Parsed:
//│ 	Let(Ident(bar),New(App(Ident(Bar),Tup(List(IntLit(42))))),None)

let bar = new Bar2(1, 1)
//│ Parsed:
//│ 	Let(Ident(bar),New(App(Ident(Bar2),Tup(List(IntLit(1), IntLit(1))))),None)

new Bar(0)
//│ Parsed:
//│ 	New(App(Ident(Bar),Tup(List(IntLit(0)))))

new Bar2(114, 514)
//│ Parsed:
//│ 	New(App(Ident(Bar2),Tup(List(IntLit(114), IntLit(514)))))

fun inc: Int -> Int
//│ Parsed:
//│ 	TermDef(Fun,None,Some(InfixApp(Ident(inc),keyword ':',InfixApp(Tup(List(Ident(Int))),keyword '->',Ident(Int)))),None)

// TODO: weird...
fun id: forall (a): a -> a
//│ Parsed:
//│ 	TermDef(Fun,None,Some(InfixApp(InfixApp(Ident(id),keyword ':',App(Ident(forall),Tup(List(Ident(a))))),keyword ':',InfixApp(Tup(List(Ident(a))),keyword '->',Ident(a)))),None)

(x => x): forall (a): a -> a
//│ Parsed:
//│ 	InfixApp(InfixApp(InfixApp(Tup(List(Ident(x))),keyword '=>',Ident(x)),keyword ':',App(Ident(forall),Tup(List(Ident(a))))),keyword ':',InfixApp(Tup(List(Ident(a))),keyword '->',Ident(a)))

fun foo: forall (a, b): a -> b
//│ Parsed:
//│ 	TermDef(Fun,None,Some(InfixApp(InfixApp(Ident(foo),keyword ':',App(Ident(forall),Tup(List(Ident(a), Ident(b))))),keyword ':',InfixApp(Tup(List(Ident(a))),keyword '->',Ident(b)))),None)

fun foo: forall (Int <: a <: Num): a -> a
//│ Parsed:
//│ 	TermDef(Fun,None,Some(InfixApp(InfixApp(Ident(foo),keyword ':',App(Ident(forall),Tup(List(App(Ident(<:),Tup(List(Ident(Int), App(Ident(<:),Tup(List(Ident(a), Ident(Num))))))))))),keyword ':',InfixApp(Tup(List(Ident(a))),keyword '->',Ident(a)))),None)

:fixme
if 1 < 2 then 1 else 0
//│ ╔══[PARSE ERROR] Expected 'let' keyword, 'new' keyword, 'fun' keyword, 'val' keyword, 'type' keyword, 'class' keyword, 'trait' keyword, 'module' keyword, 'abstract' keyword, 'mut' keyword, 'virtual' keyword, 'override' keyword, 'declare' keyword, 'public' keyword, 'private' keyword, expression, 'true' keyword, or 'false' keyword after start of statement; found 'if' keyword instead
//│ ║  l.75: 	if 1 < 2 then 1 else 0
//│ ╙──      	^^
//│ ╔══[PARSE ERROR] Expected end of input; found literal instead
//│ ║  l.75: 	if 1 < 2 then 1 else 0
//│ ╙──      	   ^
//│ Parsed:
//│ 	Error()

:fixme
fun fact = case
  0 then 1
  n then n * fact(n - 1)
//│ ╔══[PARSE ERROR] Expected expression after 'fun' binding equals sign; found 'case' keyword instead
//│ ║  l.86: 	fun fact = case
//│ ╙──      	           ^^^^
//│ Parsed:
//│ 	Error()

:fixme
`42
//│ /!!!\ Uncaught error: scala.NotImplementedError: QUOTE

x `=> x
//│ Parsed:
//│ 	Quoted(InfixApp(Tup(List(Ident(x))),keyword '=>',Unquoted(Ident(x))))

:fixme
`1 `+ `1
//│ /!!!\ Uncaught error: scala.NotImplementedError: QUOTE

:fixme
`let x = `42 `in x
//│ /!!!\ Uncaught error: scala.NotImplementedError: QUOTE

// TODO: region & effects
