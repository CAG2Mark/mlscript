:global
:bbml
:parseOnly

class Foo
//│ Parsed:
//│ 	TypeDef(Cls,Ident(Foo),None,None)

class Bar(x: Int)
//│ Parsed:
//│ 	TypeDef(Cls,App(Ident(Bar),Tup(List(InfixApp(Ident(x),keyword ':',Ident(Int))))),None,None)

class Baz[A]
//│ Parsed:
//│ 	TypeDef(Cls,TyApp(Ident(Baz),List(Ident(A))),None,None)

class BazBaz[A](f: A -> A)
//│ Parsed:
//│ 	TypeDef(Cls,App(TyApp(Ident(BazBaz),List(Ident(A))),Tup(List(InfixApp(Ident(f),keyword ':',InfixApp(Tup(List(Ident(A))),keyword '->',Ident(A)))))),None,None)

let x = 42 in x + 0
//│ Parsed:
//│ 	Let(Ident(x),IntLit(42),Some(App(Ident(+),Tup(List(Ident(x), IntLit(0))))))

fun id(x) = x
//│ Parsed:
//│ 	TermDef(Fun,None,Some(App(Ident(id),Tup(List(Ident(x))))),Some(Ident(x)))

x => x + 1
//│ Parsed:
//│ 	InfixApp(Tup(List(Ident(x))),keyword '=>',App(Ident(+),Tup(List(Ident(x), IntLit(1)))))

:fixme
let bar = new Bar(42)
//│ ╔══[PARSE ERROR] Expected expression after 'let' binding equals sign; found 'new' keyword instead
//│ ║  l.34: 	let bar = new Bar(42)
//│ ╙──      	          ^^^
//│ ╔══[PARSE ERROR] Expected end of input; found identifier instead
//│ ║  l.34: 	let bar = new Bar(42)
//│ ╙──      	              ^^^
//│ Parsed:
//│ 	Error()

:fixme
if 1 < 2 then 1 else 0
//│ ╔══[PARSE ERROR] Expected 'let' keyword, 'fun' keyword, 'val' keyword, 'type' keyword, 'class' keyword, 'trait' keyword, 'module' keyword, 'abstract' keyword, 'mut' keyword, 'virtual' keyword, 'override' keyword, 'declare' keyword, 'public' keyword, 'private' keyword, expression, 'true' keyword, or 'false' keyword after start of statement; found 'if' keyword instead
//│ ║  l.45: 	if 1 < 2 then 1 else 0
//│ ╙──      	^^
//│ ╔══[PARSE ERROR] Expected end of input; found literal instead
//│ ║  l.45: 	if 1 < 2 then 1 else 0
//│ ╙──      	   ^
//│ Parsed:
//│ 	Error()

:fixme
fun fact = case
  0 then 1
  n then n * fact(n - 1)
//│ ╔══[PARSE ERROR] Expected expression after 'fun' binding equals sign; found 'case' keyword instead
//│ ║  l.56: 	fun fact = case
//│ ╙──      	           ^^^^
//│ Parsed:
//│ 	Error()

:fixme
`42
//│ /!!!\ Uncaught error: scala.NotImplementedError: QUOTE

x `=> x
//│ Parsed:
//│ 	Quoted(InfixApp(Tup(List(Ident(x))),keyword '=>',Unquoted(Ident(x))))

:fixme
`1 `+ `1
//│ /!!!\ Uncaught error: scala.NotImplementedError: QUOTE

:fixme
`let x = `42 `in x
//│ /!!!\ Uncaught error: scala.NotImplementedError: QUOTE

// TODO: region & effects
