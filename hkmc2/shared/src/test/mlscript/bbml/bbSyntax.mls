:global
:bbml
:parseOnly

class Foo
//│ Parsed:
//│ 	TypeDef(Cls,Ident(Foo),None,None)

class Bar(x: Int)
//│ Parsed:
//│ 	TypeDef(Cls,App(Ident(Bar),Tup(List(InfixApp(Ident(x),keyword ':',Ident(Int))))),None,None)

class Bar2(x: Int, y: Int)
//│ Parsed:
//│ 	TypeDef(Cls,App(Ident(Bar2),Tup(List(InfixApp(Ident(x),keyword ':',Ident(Int)), InfixApp(Ident(y),keyword ':',Ident(Int))))),None,None)

class Baz[A]
//│ Parsed:
//│ 	TypeDef(Cls,TyApp(Ident(Baz),List(Ident(A))),None,None)

class BazBaz[A](f: A -> A)
//│ Parsed:
//│ 	TypeDef(Cls,App(TyApp(Ident(BazBaz),List(Ident(A))),Tup(List(InfixApp(Ident(f),keyword ':',InfixApp(Tup(List(Ident(A))),keyword '->',Ident(A)))))),None,None)

Baz[Int]
//│ Parsed:
//│ 	TyApp(Ident(Baz),List(Ident(Int)))

Baz[in Int]
//│ Parsed:
//│ 	TyApp(Ident(Baz),List(Modified(keyword 'in',Ident(Int))))

Baz[out Int]
//│ Parsed:
//│ 	TyApp(Ident(Baz),List(Modified(keyword 'out',Ident(Int))))

Baz[in Int out Int]
//│ Parsed:
//│ 	TyApp(Ident(Baz),List(Tup(List(Modified(keyword 'in',Ident(Int)), Modified(keyword 'out',Ident(Int))))))

let x = 42 in x + 0
//│ Parsed:
//│ 	Let(Ident(x),IntLit(42),Some(App(Ident(+),Tup(List(Ident(x), IntLit(0))))))

fun id(x) = x
//│ Parsed:
//│ 	TermDef(Fun,None,Some(App(Ident(id),Tup(List(Ident(x))))),Some(Ident(x)))

x => x + 1
//│ Parsed:
//│ 	InfixApp(Tup(List(Ident(x))),keyword '=>',App(Ident(+),Tup(List(Ident(x), IntLit(1)))))

let bar = new Bar(42)
//│ Parsed:
//│ 	Let(Ident(bar),New(App(Ident(Bar),Tup(List(IntLit(42))))),None)

let bar = new Bar2(1, 1)
//│ Parsed:
//│ 	Let(Ident(bar),New(App(Ident(Bar2),Tup(List(IntLit(1), IntLit(1))))),None)

new Bar(0)
//│ Parsed:
//│ 	New(App(Ident(Bar),Tup(List(IntLit(0)))))

new Bar2(114, 514)
//│ Parsed:
//│ 	New(App(Ident(Bar2),Tup(List(IntLit(114), IntLit(514)))))

fun inc: Int -> Int
//│ Parsed:
//│ 	TermDef(Fun,None,Some(InfixApp(Ident(inc),keyword ':',InfixApp(Tup(List(Ident(Int))),keyword '->',Ident(Int)))),None)

[A] -> A -> A
//│ Parsed:
//│ 	Forall(List(Ident(A)),InfixApp(Tup(List(Ident(A))),keyword '->',Ident(A)))

fun id: [A] -> A -> A
//│ Parsed:
//│ 	TermDef(Fun,None,Some(InfixApp(Ident(id),keyword ':',Forall(List(Ident(A)),InfixApp(Tup(List(Ident(A))),keyword '->',Ident(A))))),None)

[A] => (x: A) => x
//│ Parsed:
//│ 	Forall(List(Ident(A)),InfixApp(Tup(List(InfixApp(Ident(x),keyword ':',Ident(A)))),keyword '=>',Ident(x)))

[A, B] -> A -> B
//│ Parsed:
//│ 	Forall(List(Ident(A), Ident(B)),InfixApp(Tup(List(Ident(A))),keyword '->',Ident(B)))

[A, B, C] -> (A, B) -> C
//│ Parsed:
//│ 	Forall(List(Ident(A), Ident(B), Ident(C)),InfixApp(Tup(List(Ident(A), Ident(B))),keyword '->',Ident(C)))

([A] -> A -> A) -> Int
//│ Parsed:
//│ 	InfixApp(Tup(List(Forall(List(Ident(A)),InfixApp(Tup(List(Ident(A))),keyword '->',Ident(A))))),keyword '->',Ident(Int))


if 1 < 2 then 1 else 0
//│ Parsed:
//│ 	IfElse(InfixApp(App(Ident(<),Tup(List(IntLit(1), IntLit(2)))),keyword 'then',IntLit(1)),IntLit(0))


fun fact = case
  0 then 1
  n then n * fact(n - 1)
//│ Parsed:
//│ 	TermDef(Fun,None,Some(Ident(fact)),Some(Case(Block(List(InfixApp(IntLit(0),keyword 'then',IntLit(1)), InfixApp(Ident(n),keyword 'then',App(Ident(*),Tup(List(Ident(n), App(Ident(fact),Tup(List(App(Ident(-),Tup(List(Ident(n), IntLit(1))))))))))))))))

:fixme
`42
//│ /!!!\ Uncaught error: scala.NotImplementedError: QUOTE

x `=> x
//│ Parsed:
//│ 	Quoted(InfixApp(Tup(List(Ident(x))),keyword '=>',Unquoted(Ident(x))))

:fixme
`1 `+ `1
//│ /!!!\ Uncaught error: scala.NotImplementedError: QUOTE

:fixme
`let x = `42 `in x
//│ /!!!\ Uncaught error: scala.NotImplementedError: QUOTE

// TODO: region & effects
