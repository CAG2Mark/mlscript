:global
:bbml


region x in 42
//│ Type: Int

region x in x
//│ Type: Region[?]


region x in x.ref 42
//│ Type: Ref[Int, ?]

let r = region x in x.ref 42
r
//│ Type: Ref[Int, ?]

:e
let r = region x in x.ref 42
!r
//│ ╔══[ERROR] Type error in term { let r@2 = region x in (x@3#0).ref 42; !Ref(r@2) }
//│ ╟── because: cannot constrain  (α17_1 ∨ α15_1) ∨ <α>0_0  <:  <α>0_0
//│ ╟── because: cannot constrain  α17_1  <:  <α>0_0
//│ ╟── because: cannot constrain  α16_1  <:  <α>0_0
//│ ╙── because: cannot constrain  ⊤  <:  <α>0_0
//│ Type: Int

fun mkRef() = region x in x.ref 42
mkRef
//│ Type: () ->{<α>0_0} Ref[Int, ?]

:e
let t = region x in x in t.ref 42
//│ ╔══[ERROR] Type error in term (t@2#0).ref 42
//│ ╟── because: cannot constrain  Region[?]  <:  Region[α26_1]
//│ ╟── because: cannot constrain  ((⊤ ∧ ⊤) ∧ ⊤) ∨ ⊥  <:  ((⊤ ∧ ⊤) ∧ α26_1) ∨ ⊥
//│ ╟── because: cannot constrain  ⊤  <:  α26_1
//│ ╙── because: cannot constrain  ⊤  <:  ⊥
//│ ╔══[ERROR] Type error in term { { let t@2 = region x in x@3#0; (t@2#0).ref 42 } }
//│ ╟── because: cannot constrain  (α26_1 ∨ α25_1) ∨ <α>0_0  <:  <α>0_0
//│ ╟── because: cannot constrain  α26_1  <:  <α>0_0
//│ ╙── because: cannot constrain  ⊤  <:  <α>0_0
//│ Type: Ref[Int, ?]


region x in
  let r = x.ref 42 in r := 0
//│ Type: Int

:e
let t = region x in
  x.ref 42
in t := 0
//│ ╔══[ERROR] Type error in term { { let t@2 = region x in (x@3#0).ref 42; t@2#0 := 0 } }
//│ ╟── because: cannot constrain  (α35_1 ∨ α33_1) ∨ <α>0_0  <:  <α>0_0
//│ ╟── because: cannot constrain  α35_1  <:  <α>0_0
//│ ╟── because: cannot constrain  α34_1  <:  <α>0_0
//│ ╙── because: cannot constrain  ⊤  <:  <α>0_0
//│ Type: Int


region x in
  let r = x.ref 42 in !r
//│ Type: Int

:e
let t = region x in
  x.ref 42
in !t
//│ ╔══[ERROR] Type error in term { { let t@2 = region x in (x@3#0).ref 42; !Ref(t@2) } }
//│ ╟── because: cannot constrain  (α46_1 ∨ α44_1) ∨ <α>0_0  <:  <α>0_0
//│ ╟── because: cannot constrain  α46_1  <:  <α>0_0
//│ ╟── because: cannot constrain  α45_1  <:  <α>0_0
//│ ╙── because: cannot constrain  ⊤  <:  <α>0_0
//│ Type: Int

region x in
  let r = x.ref 42 in let t = r := 0 in !r
//│ Type: Int

:e
fun rid: [A] -> A -> A
fun rid(x) =
  let t = (region y in 42) in x
//│ ╔══[ERROR] Type error in term λx@4. { let t@5 = region y in 42; x@4#0 } with expected type (<α>56_2) ->{⊥} <α>56_2
//│ ╙── because: cannot constrain  α58_2 ∨ <α>0_0  <:  ⊥
//│ Type: ⊤

:e
region x in
  (let dz = x.ref 42 in 42): [A] -> Int
//│ ╔══[ERROR] Type error in term { let dz@3 = (x@2#0).ref 42; 42 } with expected type forall α60_3: Int
//│ ╟── because: cannot constrain  α61_3  <:  ⊥
//│ ╙── because: cannot constrain  <α>59_2  <:  ⊥
//│ Type: forall α60_3: Int


:e
let t =
  region x in
    y => x.ref y
  in t(42)
//│ ╔══[ERROR] Type error in term { { let t@2 = region x in λy@4. (x@3#0).ref y@4#0; t@2#0(42) } }
//│ ╟── because: cannot constrain  (α71_1 ∨ α66_1) ∨ <α>0_0  <:  <α>0_0
//│ ╟── because: cannot constrain  α71_1  <:  <α>0_0
//│ ╙── because: cannot constrain  ⊤  <:  <α>0_0
//│ Type: Ref[in α68_1 out α68_1 ∨ Int, ?]

fun foo: [A] -> Int ->{A | Alloc} Int
fun foo(x) =
  region y in x + 1
//│ Type: ⊤

