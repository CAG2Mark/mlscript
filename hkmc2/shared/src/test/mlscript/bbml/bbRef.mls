:global
:bbml


region x in 42
//│ Elab: { region x in 42‹›‹› }‹›
//│ Type: Int

region x in x
//│ Elab: { region x in x@1#0‹› }‹›
//│ Type: Region[in α3_1 out α3_1]

// TODO: check again
region x in
  x.ref 42
//│ Elab: { region x in (x@1#0).ref 42‹›‹›‹› }‹›
//│ Type: Ref[in Int out Int, in ⊥ out α6_1]
//│ Where:
//│   ⊤ ∧ ¬⊥ ∧ α5_1 <: α6_1
//│   α6_1 <: ¬⊤ ∧ ¬⊥ ∧ ¬α5_1 ∧ ¬α7_0
//│   α7_0 <: ¬⊤ ∧ ¬⊥ ∧ ¬α0_0
//│   α6_1 <: ¬⊤ ∧ ¬⊥ ∧ ¬α5_1

:e
let t = region x in x in t.ref 42
//│ Elab: { { let t@1 = region x in x@2#0‹›; (t@1#0).ref 42‹›‹› }‹› }‹›
//│ ╔══[ERROR] Cannot solve ⊤ ∧ ¬⊥
//│ ╙──
//│ ╔══[ERROR] Cannot constrain skolem α0_0
//│ ╙──
//│ Type: Ref[in Int out Int, in ⊥ out α10_0]
//│ Where:
//│   ⊤ ∧ ¬⊥ ∧ ⊤ <: α10_0
//│   α10_0 <: ¬⊤ ∧ ¬⊥ ∧ ¬α0_0
//│   α10_0 <: ¬⊤ ∧ ¬⊥ ∧ ¬⊥


region x in
  let r = x.ref 42 in r := 0
//│ Elab: { region x in { let r@2 = (x@1#0).ref 42‹›‹›; r@2#0 := 0‹›‹› }‹›‹› }‹›
//│ Type: Int

:e
let t = region x in
  x.ref 42
in t := 0
//│ Elab: { { let t@1 = region x in (x@2#0).ref 42‹›‹›‹›; t@1#0 := 0‹›‹› }‹› }‹›
//│ ╔══[ERROR] Cannot constrain skolem α0_0
//│ ╙──
//│ Type: Int


region x in
  let r = x.ref 42 in !r
//│ Elab: { region x in { let r@2 = (x@1#0).ref 42‹›‹›; !Ref(r@2)‹› }‹›‹› }‹›
//│ Type: α22_1
//│ Where:
//│   Int ∧ ¬⊥ <: α22_1
//│   α22_1 <: ¬⊤ ∧ ¬⊥ ∨ Int

:e
let t = region x in
  x.ref 42
in !t
//│ Elab: { { let t@1 = region x in (x@2#0).ref 42‹›‹›‹›; !Ref(t@1)‹› }‹› }‹›
//│ ╔══[ERROR] Cannot constrain skolem α0_0
//│ ╙──
//│ Type: α28_0
//│ Where:
//│   Int ∧ ¬⊥ <: α28_0
//│   α28_0 <: ¬⊤ ∧ ¬⊥ ∨ Int

region x in
  let r = x.ref 42 in let t = r := 0 in !r
//│ Elab: { region x in { let r@2 = (x@1#0).ref 42‹›‹›; { let t@3 = r@2#0 := 0‹›‹›; !Ref(r@2)‹› }‹› }‹›‹› }‹›
//│ Type: α33_1
//│ Where:
//│   Int ∧ ¬⊥ <: α33_1
//│   α33_1 <: ¬⊤ ∧ ¬⊥ ∨ Int

