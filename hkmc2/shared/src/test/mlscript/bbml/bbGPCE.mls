:global
:bbml

fun power: [C] -> CodeBase[out C, out Any] -> Int -> CodeBase[out C, out Any]
fun power(x) = case
  0 then `1.0
  n then x `*. power(x)(n - 1)
power
//│ Elab: { fun power: forall C@3: FunTy(Tup(List(Fld(‹›,TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(C@3))), WildcardTy(None,Some(Ref(class:Any))))),None))),FunTy(Tup(List(Fld(‹›,Ref(class:Int),None))),TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(C@3))), WildcardTy(None,Some(Ref(class:Any))))),None),None)‹›; fun power(x@4): forall C@12: FunTy(Tup(List(Fld(‹›,TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(C@12))), WildcardTy(None,Some(Ref(class:Any))))),None))),FunTy(Tup(List(Fld(‹›,Ref(class:Int),None))),TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(C@12))), WildcardTy(None,Some(Ref(class:Any))))),None),None)‹› = λn@5. if Cons(Boolean(App(Ref(==),Tup(List(Fld(‹›,Ref(n@5),None), Fld(‹›,Lit(IntLit(0)),None)))),Else(Quoted(Lit(DecLit(1.0))))),Else(Quoted(App(Ref(*.),Tup(List(Fld(‹›,Unquoted(Ref(x@4)),None), Fld(‹›,Unquoted(App(App(Ref(power),Tup(List(Fld(‹›,Ref(x@4),None)))),Tup(List(Fld(‹›,App(Ref(-),Tup(List(Fld(‹›,Ref(n@5),None), Fld(‹›,Lit(IntLit(1)),None)))),None))))),None)))))))‹›‹›; power#1 }‹›
//│ Type: forall α1_2: (CodeBase[in ⊥ out α1_2, in ⊥ out ⊤]) ->{⊥} (Int) ->{⊥} CodeBase[in ⊥ out α1_2, in ⊥ out ⊤]


fun id: [A] -> A -> A
fun id(x) = x
//│ Elab: { fun id: forall A@3: FunTy(Tup(List(Fld(‹›,Ref(A@3),None))),Ref(A@3),None)‹›; fun id(x@4): forall A@6: FunTy(Tup(List(Fld(‹›,Ref(A@6),None))),Ref(A@6),None)‹› = x@4#0; }‹›
//│ Type: ⊤

run(x `=> id(x) `* x)
//│ Elab: { run#0(code"λx@3. ${code"*#0(${id#0(x@3#0)‹›‹›}‹›, ${x@3#1}‹›)‹›‹›"‹›}‹›‹›"‹›)‹›‹› }‹›
//│ Type: ⊤

fun assertNotZero: [C] -> CodeBase[out C, out Any] -> CodeBase[out C, out Any]
fun assertNotZero(x) =
  `if (x `== `0.0) then `error else x
let checkedDiv = x `=> y `=> x `/ assertNotZero(y)
run(checkedDiv)
//│ Elab: { fun assertNotZero: forall C@3: FunTy(Tup(List(Fld(‹›,TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(C@3))), WildcardTy(None,Some(Ref(class:Any))))),None))),TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(C@3))), WildcardTy(None,Some(Ref(class:Any))))),None)‹›; fun assertNotZero(x@4): forall C@7: FunTy(Tup(List(Fld(‹›,TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(C@7))), WildcardTy(None,Some(Ref(class:Any))))),None))),TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(C@7))), WildcardTy(None,Some(Ref(class:Any))))),None)‹› = code"if Cons(Boolean(Unquoted(Quoted(App(Ref(==),Tup(List(Fld(‹›,Unquoted(Ref(x@4)),None), Fld(‹›,Unquoted(Quoted(Lit(DecLit(0.0)))),None)))))),Else(Unquoted(Quoted(Ref(error))))),Else(Unquoted(Ref(x@4))))‹›"‹›; let checkedDiv@8 = code"λx@9. ${code"λy@10. ${code"/#0(${x@9#0}‹›, ${assertNotZero#0(y@10#0)‹›‹›}‹›)‹›‹›"‹›}‹›‹›"‹›}‹›‹›"‹›; run#1(checkedDiv@8#0)‹›‹› }‹›
//│ Type: ⊤


fun show: CodeBase[out Any, out Any] -> Str = s => "debug"
show
//│ Elab: { fun show: (class:CodeBase#8[WildcardTy(None,Some(Ref(class:Any))), WildcardTy(None,Some(Ref(class:Any)))]‹›)‹› -> class:Str#0‹› = λs@2. "debug"‹›‹›; show#0 }‹›
//│ Type: (CodeBase[in ⊥ out ⊤, in ⊥ out ⊤]) ->{⊥} Str


fun inc(dbg) =
  x `=> let c = x `+ `1 in let t = dbg(c) in c
inc
//│ Elab: { fun inc(dbg@2) = code"λx@3. ${{ let c@4 = code"+#0(${x@3#0}‹›, ${code"1‹›"‹›}‹›)‹›‹›"‹›; { let t@6 = dbg@2#0(c@4#0)‹›‹›; c@4#1 }‹› }‹›}‹›‹›"‹›; inc#0 }‹›
//│ Type: ((CodeBase[in ⊥ out ⊤, in ⊥ out ⊤]) ->{α39_1} ⊤) ->{α39_1} CodeBase[in ⊥ out ⊥, in ⊥ out ⊤]

inc(c => log(show(c)))
//│ Elab: { inc#1(λc@3. log#0(show#1(c@3#0)‹›‹›)‹›‹›‹›)‹›‹› }‹›
//│ Type: CodeBase[in ⊥ out ⊥, in ⊥ out ⊤]

fun body: [T, C] -> (CodeBase[out T, out Any], CodeBase[out C, out Any]) -> Int -> CodeBase[out T | C, out Any]
fun body(x, y) = case
  0 then x
  1 then y
  n then body(y, x `+ y)(n - 1)
fun gib_naive(n) =
  (x, y) `=> body(x, y)(n)
let gn5 = run(gib_naive(5))
//│ Elab: { fun body: forall T@3, C@4: FunTy(Tup(List(Fld(‹›,TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(T@3))), WildcardTy(None,Some(Ref(class:Any))))),None), Fld(‹›,TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(C@4))), WildcardTy(None,Some(Ref(class:Any))))),None))),FunTy(Tup(List(Fld(‹›,Ref(class:Int),None))),TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(CompType(Ref(T@3),Ref(C@4),true))), WildcardTy(None,Some(Ref(class:Any))))),None),None)‹›; fun body(x@5, y@6): forall T@15, C@16: FunTy(Tup(List(Fld(‹›,TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(T@15))), WildcardTy(None,Some(Ref(class:Any))))),None), Fld(‹›,TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(C@16))), WildcardTy(None,Some(Ref(class:Any))))),None))),FunTy(Tup(List(Fld(‹›,Ref(class:Int),None))),TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(CompType(Ref(T@15),Ref(C@16),true))), WildcardTy(None,Some(Ref(class:Any))))),None),None)‹› = λn@7. if Cons(Boolean(App(Ref(==),Tup(List(Fld(‹›,Ref(n@7),None), Fld(‹›,Lit(IntLit(0)),None)))),Else(Ref(x@5))),Cons(Boolean(App(Ref(==),Tup(List(Fld(‹›,Ref(n@7),None), Fld(‹›,Lit(IntLit(1)),None)))),Else(Ref(y@6))),Else(App(App(Ref(body),Tup(List(Fld(‹›,Ref(y@6),None), Fld(‹›,Quoted(App(Ref(+),Tup(List(Fld(‹›,Unquoted(Ref(x@5)),None), Fld(‹›,Unquoted(Ref(y@6)),None))))),None)))),Tup(List(Fld(‹›,App(Ref(-),Tup(List(Fld(‹›,Ref(n@7),None), Fld(‹›,Lit(IntLit(1)),None)))),None)))))))‹›‹›; fun gib_naive(n@17) = code"λx@18, y@19. ${body#1(x@18#0, y@19#0)‹›‹›(n@17#0)‹›‹›}‹›‹›"‹›; let gn5@23 = run#2(gib_naive#0(5‹›)‹›‹›)‹›‹›; }‹›
//│ Type: ⊤

fun bind(rhs, k) = `let x = rhs `in k(x)
bind
//│ Elab: { fun bind(rhs@2, k@3) = code"{ let x@4 = ${rhs@2#0}‹›; ${k@3#0(x@4#0)‹›‹›}‹› }‹›"‹›; bind#0 }‹›
//│ Type: (CodeBase[in ⊥ out α71_1, in ⊥ out ⊤], (CodeBase[in ⊥ out ⊤, in ⊥ out ⊥]) ->{α76_1} CodeBase[in ⊥ out α78_1, in ⊥ out ⊤]) ->{α76_1} CodeBase[in ⊥ out (α71_1) ∨ (α78_1), in ⊥ out ⊤]

:e
fun body: [G] -> (CodeBase[out G, out Any], CodeBase[out G, out Any]) -> Int -> CodeBase[out G, out Any]
fun body(x, y) = case
  0 then x
  1 then y
  n then bind of x `+ y, [C] => (z: CodeBase[out C, out Any]) => body(y, z)(n - 1)
//│ Elab: { fun body: forall G@3: FunTy(Tup(List(Fld(‹›,TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(G@3))), WildcardTy(None,Some(Ref(class:Any))))),None), Fld(‹›,TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(G@3))), WildcardTy(None,Some(Ref(class:Any))))),None))),FunTy(Tup(List(Fld(‹›,Ref(class:Int),None))),TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(G@3))), WildcardTy(None,Some(Ref(class:Any))))),None),None)‹›; fun body(x@4, y@5): forall G@17: FunTy(Tup(List(Fld(‹›,TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(G@17))), WildcardTy(None,Some(Ref(class:Any))))),None), Fld(‹›,TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(G@17))), WildcardTy(None,Some(Ref(class:Any))))),None))),FunTy(Tup(List(Fld(‹›,Ref(class:Int),None))),TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(G@17))), WildcardTy(None,Some(Ref(class:Any))))),None),None)‹› = λn@6. if Cons(Boolean(App(Ref(==),Tup(List(Fld(‹›,Ref(n@6),None), Fld(‹›,Lit(IntLit(0)),None)))),Else(Ref(x@4))),Cons(Boolean(App(Ref(==),Tup(List(Fld(‹›,Ref(n@6),None), Fld(‹›,Lit(IntLit(1)),None)))),Else(Ref(y@5))),Else(App(Ref(bind),Tup(List(Fld(‹›,Quoted(App(Ref(+),Tup(List(Fld(‹›,Unquoted(Ref(x@4)),None), Fld(‹›,Unquoted(Ref(y@5)),None))))),None), Fld(‹›,Forall(List(C@9),Lam(List(Param(‹›,z@10,Some(TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(C@9))), WildcardTy(None,Some(Ref(class:Any)))))))),App(App(Ref(body),Tup(List(Fld(‹›,Ref(y@5),None), Fld(‹›,Ref(z@10),None)))),Tup(List(Fld(‹›,App(Ref(-),Tup(List(Fld(‹›,Ref(n@6),None), Fld(‹›,Lit(IntLit(1)),None)))),None)))))),None)))))))‹›‹›; }‹›
//│ ╔══[ERROR] Cannot solve ⊤ ∧ ¬⊥
//│ ╙──
//│ ╔══[ERROR] Cannot solve ⊤ ∧ ¬⊥
//│ ╙──
//│ ╔══[ERROR] Cannot solve ⊤ ∧ ¬⊥
//│ ╙──
//│ ╔══[ERROR] Cannot solve ⊤ ∧ ¬⊥
//│ ╙──
//│ Type: ⊤

fun bind: [G] -> (CodeBase[out G, out Any], [C] -> CodeBase[out C, out Any] -> CodeBase[out C | G, out Any]) -> CodeBase[out G, out Any]
fun bind(rhs, k) = `let x = rhs `in k(x)
bind
//│ Elab: { fun bind: forall G@3: FunTy(Tup(List(Fld(‹›,TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(G@3))), WildcardTy(None,Some(Ref(class:Any))))),None), Fld(‹›,Forall(List(C@4),FunTy(Tup(List(Fld(‹›,TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(C@4))), WildcardTy(None,Some(Ref(class:Any))))),None))),TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(CompType(Ref(C@4),Ref(G@3),true))), WildcardTy(None,Some(Ref(class:Any))))),None)),None))),TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(G@3))), WildcardTy(None,Some(Ref(class:Any))))),None)‹›; fun bind(rhs@5, k@6): forall G@10: FunTy(Tup(List(Fld(‹›,TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(G@10))), WildcardTy(None,Some(Ref(class:Any))))),None), Fld(‹›,Forall(List(C@11),FunTy(Tup(List(Fld(‹›,TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(C@11))), WildcardTy(None,Some(Ref(class:Any))))),None))),TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(CompType(Ref(C@11),Ref(G@10),true))), WildcardTy(None,Some(Ref(class:Any))))),None)),None))),TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(G@10))), WildcardTy(None,Some(Ref(class:Any))))),None)‹› = code"{ let x@7 = ${rhs@5#0}‹›; ${k@6#0(x@7#0)‹›‹›}‹› }‹›"‹›; bind#0 }‹›
//│ Type: forall α100_2: (CodeBase[in ⊥ out α100_2, in ⊥ out ⊤], forall α101_3: (CodeBase[in ⊥ out α101_3, in ⊥ out ⊤]) ->{⊥} CodeBase[in ⊥ out (α101_3) ∨ (α100_2), in ⊥ out ⊤]) ->{⊥} CodeBase[in ⊥ out α100_2, in ⊥ out ⊤]

:fixme
fun body: [G] -> (CodeBase[out G, out Any], CodeBase[out G, out Any]) -> Int -> CodeBase[out G, out Any]
fun body(x, y) = case
  0 then x
  1 then y
  n then bind of x `+ y, [C] => (z: CodeBase[out C, out Any]) => body(y, z)(n - 1)
//│ Elab: { fun body: forall G@3: FunTy(Tup(List(Fld(‹›,TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(G@3))), WildcardTy(None,Some(Ref(class:Any))))),None), Fld(‹›,TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(G@3))), WildcardTy(None,Some(Ref(class:Any))))),None))),FunTy(Tup(List(Fld(‹›,Ref(class:Int),None))),TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(G@3))), WildcardTy(None,Some(Ref(class:Any))))),None),None)‹›; fun body(x@4, y@5): forall G@17: FunTy(Tup(List(Fld(‹›,TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(G@17))), WildcardTy(None,Some(Ref(class:Any))))),None), Fld(‹›,TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(G@17))), WildcardTy(None,Some(Ref(class:Any))))),None))),FunTy(Tup(List(Fld(‹›,Ref(class:Int),None))),TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(G@17))), WildcardTy(None,Some(Ref(class:Any))))),None),None)‹› = λn@6. if Cons(Boolean(App(Ref(==),Tup(List(Fld(‹›,Ref(n@6),None), Fld(‹›,Lit(IntLit(0)),None)))),Else(Ref(x@4))),Cons(Boolean(App(Ref(==),Tup(List(Fld(‹›,Ref(n@6),None), Fld(‹›,Lit(IntLit(1)),None)))),Else(Ref(y@5))),Else(App(Ref(bind),Tup(List(Fld(‹›,Quoted(App(Ref(+),Tup(List(Fld(‹›,Unquoted(Ref(x@4)),None), Fld(‹›,Unquoted(Ref(y@5)),None))))),None), Fld(‹›,Forall(List(C@9),Lam(List(Param(‹›,z@10,Some(TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(C@9))), WildcardTy(None,Some(Ref(class:Any)))))))),App(App(Ref(body),Tup(List(Fld(‹›,Ref(y@5),None), Fld(‹›,Ref(z@10),None)))),Tup(List(Fld(‹›,App(Ref(-),Tup(List(Fld(‹›,Ref(n@6),None), Fld(‹›,Lit(IntLit(1)),None)))),None)))))),None)))))))‹›‹›; }‹›
//│ ╔══[ERROR] Cannot constrain skolem <α>107_2
//│ ╙──
//│ Type: ⊤

fun gib(n) = (x, y) `=> body(x, y)(n)
let g5 = run(gib(5))
//│ Elab: { fun gib(n@2) = code"λx@3, y@4. ${body#1(x@3#0, y@4#0)‹›‹›(n@2#0)‹›‹›}‹›‹›"‹›; let g5@8 = run#3(gib#0(5‹›)‹›‹›)‹›‹›; }‹›
//│ Type: ⊤
