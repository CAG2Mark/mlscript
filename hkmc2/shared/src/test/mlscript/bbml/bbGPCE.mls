:global
:bbml

fun power: [C] -> CodeBase[out Num, out C, out Any] -> Int -> CodeBase[out Num, out C, out Any]
fun power(x) = case
  0 then `1.0
  n then x `*. power(x)(n - 1)
power
//│ Type: forall α2_2: (CodeBase[out Num, out α2_2, ?]) ->{⊥} (Int) ->{⊥} CodeBase[out Num, out α2_2, ?]


fun id: [A] -> A -> A
fun id(x) = x
//│ Type: ⊤

run(x `=> id(x) `* x)
//│ Type: Int ->{⊥} Int

fun assertNotZero: [C] -> CodeBase[out Num, out C, out Any] -> CodeBase[out Num, out C, out Any]
fun assertNotZero(x) =
  `if (x `== `0.0) then `error else x
let checkedDiv = x `=> y `=> x `/. (assertNotZero(y))
run(checkedDiv)
//│ Type: Num ->{⊥} (Num ->{⊥} Num)


fun show: [T] -> CodeBase[out T, out Any, out Any] -> Str = s => "debug"
show
//│ Type: forall α64_2: (CodeBase[?, ?, ?]) ->{⊥} Str


fun inc(dbg) =
  x `=> let c = x `+ `1 in let t = dbg(c) in c
inc
//│ Type: (CodeBase[out Int, ?, ?] ->{α80_1} ⊤) ->{α80_1} CodeBase[out Int ->{⊥} Int, ⊥, ?]

inc(c => log(show(c)))
//│ Type: CodeBase[out Int ->{⊥} Int, ⊥, ?]

fun body: [T, C] -> (CodeBase[out Int, out T, out Any], CodeBase[out Int, out C, out Any]) -> Int -> CodeBase[out Int, out T | C, out Any]
fun body(x, y) = case
  0 then x
  1 then y
  n then body(y, x `+ y)(n - 1)
fun gib_naive(n) =
  (x, y) `=> body(x, y)(n)
let gn5 = run(gib_naive(5))
//│ Type: ⊤

fun bind(rhs, k) = `let x = rhs `in k(x)
bind
//│ Type: (CodeBase[out α129_1, out α130_1, ?], CodeBase[in α134_1 out α134_1 ∨ α129_1, ?, ⊥] ->{α137_1} CodeBase[out α140_1, out α141_1, ?]) ->{α137_1} CodeBase[out α140_1, out α130_1 ∨ α141_1, ?]

:e
fun body: [G] -> (CodeBase[out Int, out G, out Any], CodeBase[out Int, out G, out Any]) -> Int -> CodeBase[out Int, out G, out Any]
fun body(x, y) = case
  0 then x
  1 then y
  n then bind of x `+ y, (z => body(y, z)(n - 1)): [C] -> CodeBase[out Int, out C, out Any] -> CodeBase[out C, out Any]
//│ ╔══[ERROR] Type error in function literal with expected type (CodeBase[out Int, out <α>148_2, ?], CodeBase[out Int, out <α>148_2, ?]) ->{⊥} (Int) ->{⊥} CodeBase[out Int, out <α>148_2, ?]
//│ ║  l.56: 	fun body(x, y) = case
//│ ║        	         ^^^^^^^^^^^^
//│ ║  l.57: 	  0 then x
//│ ║        	^^^^^^^^^^
//│ ║  l.58: 	  1 then y
//│ ║        	^^^^^^^^^^
//│ ║  l.59: 	  n then bind of x `+ y, (z => body(y, z)(n - 1)): [C] -> CodeBase[out Int, out C, out Any] -> CodeBase[out C, out Any]
//│ ║        	^^^
//│ ╟── because: cannot constrain  α149_2 ->{α159_2} (CodeBase[out Int, out <α>148_2, ?] ∨ α160_2)  <:  Int ->{⊥} CodeBase[out Int, out <α>148_2, ?]
//│ ╟── because: cannot constrain  (((CodeBase[in ⊥ ∨ ⊥ out ((Int ∧ ⊤) ∧ ⊤) ∨ ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ <α>148_2) ∨ ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ ⊤) ∨ ⊥] ∧ ⊤) ∧ ⊤) ∨ ((⊤ ∧ ⊤) ∧ α160_2)) ∨ ⊥  <:  ((CodeBase[in ⊥ ∨ ⊥ out ((Int ∧ ⊤) ∧ ⊤) ∨ ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ <α>148_2) ∨ ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ ⊤) ∨ ⊥] ∧ ⊤) ∧ ⊤) ∨ ⊥
//│ ╟── because: cannot constrain  α160_2  <:  CodeBase[in ⊥ ∨ ⊥ out ((Int ∧ ⊤) ∧ ⊤) ∨ ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ <α>148_2) ∨ ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ ⊤) ∨ ⊥]
//│ ╟── because: cannot constrain  α167_1  <:  CodeBase[in ⊥ ∨ ⊥ out ((Int ∧ ⊤) ∧ ⊤) ∨ ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ <α>148_2) ∨ ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ ⊤) ∨ ⊥]
//│ ╟── because: cannot constrain  α167_1  <:  CodeBase[in ⊥ ∨ ⊥ out ((Int ∧ ⊤) ∧ ⊤) ∨ ⊥, in ⊥ ∨ ⊥ out ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ ⊤) ∨ ⊥]
//│ ╟── because: cannot constrain  CodeBase[in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ α140_1) ∨ ⊥, in ⊥ ∨ ⊥ out (((⊤ ∧ ⊤) ∧ α130_1) ∨ ((⊤ ∧ ⊤) ∧ α141_1)) ∨ ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ ⊤) ∨ ⊥]  <:  CodeBase[in ⊥ ∨ ⊥ out ((Int ∧ ⊤) ∧ ⊤) ∨ ⊥, in ⊥ ∨ ⊥ out ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ ⊤) ∨ ⊥]
//│ ╟── because: cannot constrain  (((⊤ ∧ ⊤) ∧ α130_1) ∨ ((⊤ ∧ ⊤) ∧ α141_1)) ∨ ⊥  <:  ⊥ ∨ ⊥
//│ ╟── because: cannot constrain  α130_1  <:  ⊥
//│ ╙── because: cannot constrain  ⊤  <:  ⊥
//│ ╔══[ERROR] Type error in function literal with expected type (CodeBase[out Int, out <α>148_2, ?], CodeBase[out Int, out <α>148_2, ?]) ->{⊥} (Int) ->{⊥} CodeBase[out Int, out <α>148_2, ?]
//│ ║  l.56: 	fun body(x, y) = case
//│ ║        	         ^^^^^^^^^^^^
//│ ║  l.57: 	  0 then x
//│ ║        	^^^^^^^^^^
//│ ║  l.58: 	  1 then y
//│ ║        	^^^^^^^^^^
//│ ║  l.59: 	  n then bind of x `+ y, (z => body(y, z)(n - 1)): [C] -> CodeBase[out Int, out C, out Any] -> CodeBase[out C, out Any]
//│ ║        	^^^
//│ ╟── because: cannot constrain  α149_2 ->{α159_2} (CodeBase[out Int, out <α>148_2, ?] ∨ α160_2)  <:  Int ->{⊥} CodeBase[out Int, out <α>148_2, ?]
//│ ╟── because: cannot constrain  (((CodeBase[in ⊥ ∨ ⊥ out ((Int ∧ ⊤) ∧ ⊤) ∨ ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ <α>148_2) ∨ ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ ⊤) ∨ ⊥] ∧ ⊤) ∧ ⊤) ∨ ((⊤ ∧ ⊤) ∧ α160_2)) ∨ ⊥  <:  ((CodeBase[in ⊥ ∨ ⊥ out ((Int ∧ ⊤) ∧ ⊤) ∨ ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ <α>148_2) ∨ ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ ⊤) ∨ ⊥] ∧ ⊤) ∧ ⊤) ∨ ⊥
//│ ╟── because: cannot constrain  α160_2  <:  CodeBase[in ⊥ ∨ ⊥ out ((Int ∧ ⊤) ∧ ⊤) ∨ ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ <α>148_2) ∨ ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ ⊤) ∨ ⊥]
//│ ╟── because: cannot constrain  α167_1  <:  CodeBase[in ⊥ ∨ ⊥ out ((Int ∧ ⊤) ∧ ⊤) ∨ ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ <α>148_2) ∨ ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ ⊤) ∨ ⊥]
//│ ╟── because: cannot constrain  α167_1  <:  CodeBase[in ⊥ ∨ ⊥ out ((Int ∧ ⊤) ∧ ⊤) ∨ ⊥, in ⊥ ∨ ⊥ out ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ ⊤) ∨ ⊥]
//│ ╟── because: cannot constrain  CodeBase[in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ α140_1) ∨ ⊥, in ⊥ ∨ ⊥ out (((⊤ ∧ ⊤) ∧ α130_1) ∨ ((⊤ ∧ ⊤) ∧ α141_1)) ∨ ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ ⊤) ∨ ⊥]  <:  CodeBase[in ⊥ ∨ ⊥ out ((Int ∧ ⊤) ∧ ⊤) ∨ ⊥, in ⊥ ∨ ⊥ out ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ ⊤) ∨ ⊥]
//│ ╟── because: cannot constrain  (((⊤ ∧ ⊤) ∧ α130_1) ∨ ((⊤ ∧ ⊤) ∧ α141_1)) ∨ ⊥  <:  ⊥ ∨ ⊥
//│ ╟── because: cannot constrain  α130_1  <:  ⊥
//│ ╙── because: cannot constrain  ⊤  <:  ⊥
//│ ╔══[ERROR] Type error in function literal with expected type (CodeBase[out Int, out <α>148_2, ?], CodeBase[out Int, out <α>148_2, ?]) ->{⊥} (Int) ->{⊥} CodeBase[out Int, out <α>148_2, ?]
//│ ║  l.56: 	fun body(x, y) = case
//│ ║        	         ^^^^^^^^^^^^
//│ ║  l.57: 	  0 then x
//│ ║        	^^^^^^^^^^
//│ ║  l.58: 	  1 then y
//│ ║        	^^^^^^^^^^
//│ ║  l.59: 	  n then bind of x `+ y, (z => body(y, z)(n - 1)): [C] -> CodeBase[out Int, out C, out Any] -> CodeBase[out C, out Any]
//│ ║        	^^^
//│ ╟── because: cannot constrain  α149_2 ->{α159_2} (CodeBase[out Int, out <α>148_2, ?] ∨ α160_2)  <:  Int ->{⊥} CodeBase[out Int, out <α>148_2, ?]
//│ ╟── because: cannot constrain  (((CodeBase[in ⊥ ∨ ⊥ out ((Int ∧ ⊤) ∧ ⊤) ∨ ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ <α>148_2) ∨ ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ ⊤) ∨ ⊥] ∧ ⊤) ∧ ⊤) ∨ ((⊤ ∧ ⊤) ∧ α160_2)) ∨ ⊥  <:  ((CodeBase[in ⊥ ∨ ⊥ out ((Int ∧ ⊤) ∧ ⊤) ∨ ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ <α>148_2) ∨ ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ ⊤) ∨ ⊥] ∧ ⊤) ∧ ⊤) ∨ ⊥
//│ ╟── because: cannot constrain  α160_2  <:  CodeBase[in ⊥ ∨ ⊥ out ((Int ∧ ⊤) ∧ ⊤) ∨ ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ <α>148_2) ∨ ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ ⊤) ∨ ⊥]
//│ ╟── because: cannot constrain  α167_1  <:  CodeBase[in ⊥ ∨ ⊥ out ((Int ∧ ⊤) ∧ ⊤) ∨ ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ <α>148_2) ∨ ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ ⊤) ∨ ⊥]
//│ ╟── because: cannot constrain  α167_1  <:  CodeBase[in ⊥ ∨ ⊥ out ((Int ∧ ⊤) ∧ ⊤) ∨ ⊥, in ⊥ ∨ ⊥ out ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ ⊤) ∨ ⊥]
//│ ╟── because: cannot constrain  CodeBase[in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ α140_1) ∨ ⊥, in ⊥ ∨ ⊥ out (((⊤ ∧ ⊤) ∧ α130_1) ∨ ((⊤ ∧ ⊤) ∧ α141_1)) ∨ ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ ⊤) ∨ ⊥]  <:  CodeBase[in ⊥ ∨ ⊥ out ((Int ∧ ⊤) ∧ ⊤) ∨ ⊥, in ⊥ ∨ ⊥ out ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ ⊤) ∨ ⊥]
//│ ╟── because: cannot constrain  (((⊤ ∧ ⊤) ∧ α130_1) ∨ ((⊤ ∧ ⊤) ∧ α141_1)) ∨ ⊥  <:  ⊥ ∨ ⊥
//│ ╟── because: cannot constrain  α141_1  <:  ⊥
//│ ╙── because: cannot constrain  ⊤  <:  ⊥
//│ ╔══[ERROR] Type error in function literal with expected type (CodeBase[out Int, out <α>148_2, ?], CodeBase[out Int, out <α>148_2, ?]) ->{⊥} (Int) ->{⊥} CodeBase[out Int, out <α>148_2, ?]
//│ ║  l.56: 	fun body(x, y) = case
//│ ║        	         ^^^^^^^^^^^^
//│ ║  l.57: 	  0 then x
//│ ║        	^^^^^^^^^^
//│ ║  l.58: 	  1 then y
//│ ║        	^^^^^^^^^^
//│ ║  l.59: 	  n then bind of x `+ y, (z => body(y, z)(n - 1)): [C] -> CodeBase[out Int, out C, out Any] -> CodeBase[out C, out Any]
//│ ║        	^^^
//│ ╟── because: cannot constrain  α149_2 ->{α159_2} (CodeBase[out Int, out <α>148_2, ?] ∨ α160_2)  <:  Int ->{⊥} CodeBase[out Int, out <α>148_2, ?]
//│ ╟── because: cannot constrain  (((CodeBase[in ⊥ ∨ ⊥ out ((Int ∧ ⊤) ∧ ⊤) ∨ ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ <α>148_2) ∨ ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ ⊤) ∨ ⊥] ∧ ⊤) ∧ ⊤) ∨ ((⊤ ∧ ⊤) ∧ α160_2)) ∨ ⊥  <:  ((CodeBase[in ⊥ ∨ ⊥ out ((Int ∧ ⊤) ∧ ⊤) ∨ ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ <α>148_2) ∨ ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ ⊤) ∨ ⊥] ∧ ⊤) ∧ ⊤) ∨ ⊥
//│ ╟── because: cannot constrain  α160_2  <:  CodeBase[in ⊥ ∨ ⊥ out ((Int ∧ ⊤) ∧ ⊤) ∨ ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ <α>148_2) ∨ ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ ⊤) ∨ ⊥]
//│ ╟── because: cannot constrain  α167_1  <:  CodeBase[in ⊥ ∨ ⊥ out ((Int ∧ ⊤) ∧ ⊤) ∨ ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ <α>148_2) ∨ ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ ⊤) ∨ ⊥]
//│ ╟── because: cannot constrain  α167_1  <:  CodeBase[in ⊥ ∨ ⊥ out ((Int ∧ ⊤) ∧ ⊤) ∨ ⊥, in ⊥ ∨ ⊥ out ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ ⊤) ∨ ⊥]
//│ ╟── because: cannot constrain  CodeBase[in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ α140_1) ∨ ⊥, in ⊥ ∨ ⊥ out (((⊤ ∧ ⊤) ∧ α130_1) ∨ ((⊤ ∧ ⊤) ∧ α141_1)) ∨ ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ ⊤) ∨ ⊥]  <:  CodeBase[in ⊥ ∨ ⊥ out ((Int ∧ ⊤) ∧ ⊤) ∨ ⊥, in ⊥ ∨ ⊥ out ⊥, in ⊥ ∨ ⊥ out ((⊤ ∧ ⊤) ∧ ⊤) ∨ ⊥]
//│ ╟── because: cannot constrain  (((⊤ ∧ ⊤) ∧ α130_1) ∨ ((⊤ ∧ ⊤) ∧ α141_1)) ∨ ⊥  <:  ⊥ ∨ ⊥
//│ ╟── because: cannot constrain  α141_1  <:  ⊥
//│ ╙── because: cannot constrain  ⊤  <:  ⊥
//│ Type: ⊤

fun bind: [G] -> (CodeBase[out Int, out G, out Any], [C] -> CodeBase[out Int, out C, out Any] -> CodeBase[out Int, out C | G, out Any]) -> CodeBase[out Int, out G, out Any]
fun bind(rhs, k) = `let x = rhs `in k(x)
bind
//│ Type: forall α171_2: (CodeBase[out Int, out α171_2, ?], forall α172_3: (CodeBase[out Int, out α172_3, ?]) ->{⊥} CodeBase[out Int, out α172_3 ∨ α171_2, ?]) ->{⊥} CodeBase[out Int, out α171_2, ?]


fun body: [G] -> (CodeBase[out Int, out G, out Any], CodeBase[out Int, out G, out Any]) -> Int -> CodeBase[out Int, out G, out Any]
fun body(x, y) = case
  0 then x
  1 then y
  n then bind of x `+ y, (z => body(y, z)(n - 1)): [C] -> CodeBase[out Int, out C, out Any] -> CodeBase[out Int, out C, out Any]
body
//│ Type: forall α181_2: (CodeBase[out Int, out α181_2, ?], CodeBase[out Int, out α181_2, ?]) ->{⊥} (Int) ->{⊥} CodeBase[out Int, out α181_2, ?]

fun gib(n) = (x, y) `=> body(x, y)(n)
let g5 = run(gib(5))
g5
//│ Type: (Int, Int) ->{⊥} Int
