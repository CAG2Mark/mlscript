:bbml
//│ Type: ⊤

:fixme
fun power: [C] -> CodeBase[out Num, out C, out Any] -> Int -> CodeBase[out Num, out C, out Any]
fun power(x) = case
  0 then `1.0
  n then x `*. power(x)(n - 1)
power
//│ /!!!\ Uncaught error: scala.MatchError: Cons(Branch(Ref(caseScrut@35),Lit(IntLit(0)),Else(Quoted(Lit(DecLit(1.0))))),Let(n@36,Ref(caseScrut@35),Else(Quoted(App(Ref(builtin:*),Tup(List(Fld(‹›,Unquoted(Ref(x@33)),None), Fld(‹›,Unquoted(App(App(Sel(Ref(globalThis:block#0),Ident(power)),Tup(List(Fld(‹›,Ref(x@33),None)))),Tup(List(Fld(‹›,App(Sel(Ref(globalThis:import#bbPredef),Ident(-)),Tup(List(Fld(‹›,Ref(n@36),None), Fld(‹›,Lit(IntLit(1)),None)))),None))))),None)))))))) (of class hkmc2.semantics.Split$Cons)


fun id: [A] -> A -> A
fun id(x) = x
//│ Type: ⊤

:fixme // FIXME[CY]
run(x `=> id(x) `* x)
//│ ╔══[ERROR] Cannot quote Sel(Ref(globalThis:import#bbPredef),Ident(*))
//│ ║  l.18: 	run(x `=> id(x) `* x)
//│ ╙──      	                 ^
//│ Type: ⊤

:fixme
fun assertNotZero: [C] -> CodeBase[out Num, out C, out Any] -> CodeBase[out Num, out C, out Any]
fun assertNotZero(x) =
  `if (x `== `0.0) then `error else x
let checkedDiv = x `=> y `=> x `/. (assertNotZero(y))
run(checkedDiv)
//│ /!!!\ Uncaught error: scala.MatchError: IfElse(InfixApp(Unquoted(Quoted(App(Ident(==),Tup(List(Unquoted(Ident(x)), Unquoted(Quoted(DecLit(0.0)))))))),keyword 'then',Unquoted(Quoted(Ident(error)))),Unquoted(Ident(x))) (of class hkmc2.syntax.Tree$IfElse)


:todo // :fixme
fun show: [T] -> CodeBase[out T, out Any, out Any] -> Str = s => "debug"
show
//│ Type: (CodeBase[?, ?, ?]) ->{⊥} Str


:fixme // FIXME[CY]
fun inc(dbg) =
  x `=> let c = x `+ `1 in let t = dbg(c) in c
inc
//│ ╔══[ERROR] Cannot quote Sel(Ref(globalThis:import#bbPredef),Ident(+))
//│ ║  l.41: 	  x `=> let c = x `+ `1 in let t = dbg(c) in c
//│ ╙──      	                   ^
//│ Type: forall α34_2: (CodeBase[⊥, ?, ?] ->{α34_2} ⊤) ->{α34_2} CodeBase[out ⊤ -> ⊥, ⊥, ?]

inc(c => log(show(c)))
//│ Type: CodeBase[out ⊤ -> ⊥, ⊥, ?]

:fixme
fun body: [T, C] -> (CodeBase[out Int, out T, out Any], CodeBase[out Int, out C, out Any]) -> Int -> CodeBase[out Int, out T | C, out Any]
fun body(x, y) = case
  0 then x
  1 then y
  n then body(y, x `+ y)(n - 1)
fun gib_naive(n) =
  (x, y) `=> body(x, y)(n)
let gn5 = run(gib_naive(5))
//│ /!!!\ Uncaught error: scala.MatchError: Cons(Branch(Ref(caseScrut@88),Lit(IntLit(0)),Else(Ref(x@84))),Cons(Branch(Ref(caseScrut@88),Lit(IntLit(1)),Else(Ref(y@85))),Let(n@89,Ref(caseScrut@88),Else(App(App(Sel(Ref(globalThis:block#7),Ident(body)),Tup(List(Fld(‹›,Ref(y@85),None), Fld(‹›,Quoted(App(Sel(Ref(globalThis:import#bbPredef),Ident(+)),Tup(List(Fld(‹›,Unquoted(Ref(x@84)),None), Fld(‹›,Unquoted(Ref(y@85)),None))))),None)))),Tup(List(Fld(‹›,App(Sel(Ref(globalThis:import#bbPredef),Ident(-)),Tup(List(Fld(‹›,Ref(n@89),None), Fld(‹›,Lit(IntLit(1)),None)))),None)))))))) (of class hkmc2.semantics.Split$Cons)

fun bind(rhs, k) = `let x = rhs `in k(x)
bind
//│ Type: forall α69_2, α70_2, α74_2, α77_2, α80_2, α81_2: (CodeBase[out α69_2, out α70_2, ?], CodeBase[in α74_2 out α74_2 ∨ α69_2, ?, ⊥] ->{α77_2} CodeBase[out α80_2, out α81_2, ?]) ->{α77_2} CodeBase[out α80_2, out α70_2 ∨ α81_2, ?]

:e
:fixme
fun body: [G] -> (CodeBase[out Int, out G, out Any], CodeBase[out Int, out G, out Any]) -> Int -> CodeBase[out Int, out G, out Any]
fun body(x, y) = case
  0 then x
  1 then y
  n then bind of x `+ y, (z => body(y, z)(n - 1)): [C] -> CodeBase[out Int, out C, out Any] -> CodeBase[out C, out Any]
//│ /!!!\ Uncaught error: scala.MatchError: Cons(Branch(Ref(caseScrut@116),Lit(IntLit(0)),Else(Ref(x@113))),Cons(Branch(Ref(caseScrut@116),Lit(IntLit(1)),Else(Ref(y@114))),Let(n@117,Ref(caseScrut@116),Else(App(Sel(Ref(globalThis:block#8),Ident(bind)),Tup(List(Fld(‹›,Quoted(App(Sel(Ref(globalThis:import#bbPredef),Ident(+)),Tup(List(Fld(‹›,Unquoted(Ref(x@113)),None), Fld(‹›,Unquoted(Ref(y@114)),None))))),None), Fld(‹›,Lam(List(Param(‹›,z@120,None)),App(App(Sel(Ref(globalThis:block#9),Ident(body)),Tup(List(Fld(‹›,Ref(y@114),None), Fld(‹›,Ref(z@120),None)))),Tup(List(Fld(‹›,App(Sel(Ref(globalThis:import#bbPredef),Ident(-)),Tup(List(Fld(‹›,Ref(n@117),None), Fld(‹›,Lit(IntLit(1)),None)))),None))))),Some(Forall(List(QuantVar(C@124,None,None)),FunTy(Tup(List(Fld(‹›,TyApp(Sel(Ref(globalThis:import#bbPredef),Ident(CodeBase)),List(WildcardTy(None,Some(Sel(Ref(globalThis:import#Prelude),Ident(Int)))), WildcardTy(None,Some(Ref(C@124))), WildcardTy(None,Some(Sel(Ref(globalThis:import#Prelude),Ident(Any)))))),None))),TyApp(Sel(Ref(globalThis:import#bbPredef),Ident(CodeBase)),List(WildcardTy(None,Some(Ref(C@124))), WildcardTy(None,Some(Sel(Ref(globalThis:import#Prelude),Ident(Any)))))),None))))))))))) (of class hkmc2.semantics.Split$Cons)

fun bind: [G] -> (CodeBase[out Int, out G, out Any], [C] -> CodeBase[out Int, out C, out Any] -> CodeBase[out Int, out C | G, out Any]) -> CodeBase[out Int, out G, out Any]
fun bind(rhs, k) = `let x = rhs `in k(x)
bind
//│ Type: forall α92_2: (CodeBase[out Int, out α92_2, ?], forall α93_3: (CodeBase[out Int, out α93_3, ?]) ->{⊥} CodeBase[out Int, out α93_3 ∨ α92_2, ?]) ->{⊥} CodeBase[out Int, out α92_2, ?]


:fixme
fun body: [G] -> (CodeBase[out Int, out G, out Any], CodeBase[out Int, out G, out Any]) -> Int -> CodeBase[out Int, out G, out Any]
fun body(x, y) = case
  0 then x
  1 then y
  n then bind of x `+ y, (z => body(y, z)(n - 1)): [C] -> CodeBase[out Int, out C, out Any] -> CodeBase[out Int, out C, out Any]
body
//│ /!!!\ Uncaught error: scala.MatchError: Cons(Branch(Ref(caseScrut@146),Lit(IntLit(0)),Else(Ref(x@143))),Cons(Branch(Ref(caseScrut@146),Lit(IntLit(1)),Else(Ref(y@144))),Let(n@147,Ref(caseScrut@146),Else(App(Sel(Ref(globalThis:block#10),Ident(bind)),Tup(List(Fld(‹›,Quoted(App(Sel(Ref(globalThis:import#bbPredef),Ident(+)),Tup(List(Fld(‹›,Unquoted(Ref(x@143)),None), Fld(‹›,Unquoted(Ref(y@144)),None))))),None), Fld(‹›,Lam(List(Param(‹›,z@150,None)),App(App(Sel(Ref(globalThis:block#11),Ident(body)),Tup(List(Fld(‹›,Ref(y@144),None), Fld(‹›,Ref(z@150),None)))),Tup(List(Fld(‹›,App(Sel(Ref(globalThis:import#bbPredef),Ident(-)),Tup(List(Fld(‹›,Ref(n@147),None), Fld(‹›,Lit(IntLit(1)),None)))),None))))),Some(Forall(List(QuantVar(C@154,None,None)),FunTy(Tup(List(Fld(‹›,TyApp(Sel(Ref(globalThis:import#bbPredef),Ident(CodeBase)),List(WildcardTy(None,Some(Sel(Ref(globalThis:import#Prelude),Ident(Int)))), WildcardTy(None,Some(Ref(C@154))), WildcardTy(None,Some(Sel(Ref(globalThis:import#Prelude),Ident(Any)))))),None))),TyApp(Sel(Ref(globalThis:import#bbPredef),Ident(CodeBase)),List(WildcardTy(None,Some(Sel(Ref(globalThis:import#Prelude),Ident(Int)))), WildcardTy(None,Some(Ref(C@154))), WildcardTy(None,Some(Sel(Ref(globalThis:import#Prelude),Ident(Any)))))),None))))))))))) (of class hkmc2.semantics.Split$Cons)

fun gib(n) = (x, y) `=> body(x, y)(n)
let g5 = run(gib(5))
g5
//│ Type: ⊤
