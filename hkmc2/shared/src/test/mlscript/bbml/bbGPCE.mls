:global
:bbml

fun power: [C] -> CodeBase[out C, out Any] -> Int -> CodeBase[out C, out Any]
fun power(x) = case
  0 then `1.0
  n then x `*. power(x)(n - 1)
power
//│ Elab: { fun power: forall C@2: FunTy(Tup(List(Fld(‹›,TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(C@2))), WildcardTy(None,Some(Ref(class:Any))))),None))),FunTy(Tup(List(Fld(‹›,Ref(class:Int),None))),TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(C@2))), WildcardTy(None,Some(Ref(class:Any)))))))‹›; fun power(x@3): forall C@11: FunTy(Tup(List(Fld(‹›,TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(C@11))), WildcardTy(None,Some(Ref(class:Any))))),None))),FunTy(Tup(List(Fld(‹›,Ref(class:Int),None))),TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(C@11))), WildcardTy(None,Some(Ref(class:Any)))))))‹› = λn@4. if Cons(Boolean(App(Ref(==),Tup(List(Fld(‹›,Ref(n@4),None), Fld(‹›,Lit(IntLit(0)),None)))),Else(Quoted(Lit(DecLit(1.0))))),Else(Quoted(App(Ref(*.),Tup(List(Fld(‹›,Unquoted(Ref(x@3)),None), Fld(‹›,Unquoted(App(App(Ref(power),Tup(List(Fld(‹›,Ref(x@3),None)))),Tup(List(Fld(‹›,App(Ref(-),Tup(List(Fld(‹›,Ref(n@4),None), Fld(‹›,Lit(IntLit(1)),None)))),None))))),None)))))))‹›‹›; power#1 }‹›
//│ Type: forall α1_1: (CodeBase[in ⊥ out α1_1, in ⊥ out ⊤]) ->{⊥} (Int) ->{⊥} CodeBase[in ⊥ out α1_1, in ⊥ out ⊤]


fun id: [A] -> A -> A
fun id(x) = x
//│ Elab: { fun id: forall A@2: FunTy(Tup(List(Fld(‹›,Ref(A@2),None))),Ref(A@2))‹›; fun id(x@3): forall A@5: FunTy(Tup(List(Fld(‹›,Ref(A@5),None))),Ref(A@5))‹› = x@3#0; }‹›
//│ Type: ⊤

run(x `=> id(x) `* x)
//│ Elab: { run#0(code"λx@2. ${code"*#0(${id#0(x@2#0)‹›‹›}‹›, ${x@2#1}‹›)‹›‹›"‹›}‹›‹›"‹›)‹›‹› }‹›
//│ Type: ⊤

fun assertNotZero: [C] -> CodeBase[out C, out Any] -> CodeBase[out C, out Any]
fun assertNotZero(x) =
  `if (x `== `0.0) then `error else x
let checkedDiv = x `=> y `=> x `/ assertNotZero(y)
run(checkedDiv)
//│ Elab: { fun assertNotZero: forall C@2: FunTy(Tup(List(Fld(‹›,TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(C@2))), WildcardTy(None,Some(Ref(class:Any))))),None))),TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(C@2))), WildcardTy(None,Some(Ref(class:Any))))))‹›; fun assertNotZero(x@3): forall C@6: FunTy(Tup(List(Fld(‹›,TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(C@6))), WildcardTy(None,Some(Ref(class:Any))))),None))),TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(C@6))), WildcardTy(None,Some(Ref(class:Any))))))‹› = code"if Cons(Boolean(Unquoted(Quoted(App(Ref(==),Tup(List(Fld(‹›,Unquoted(Ref(x@3)),None), Fld(‹›,Unquoted(Quoted(Lit(DecLit(0.0)))),None)))))),Else(Unquoted(Quoted(Ref(error))))),Else(Unquoted(Ref(x@3))))‹›"‹›; let checkedDiv@7 = code"λx@8. ${code"λy@9. ${code"/#0(${x@8#0}‹›, ${assertNotZero#0(y@9#0)‹›‹›}‹›)‹›‹›"‹›}‹›‹›"‹›}‹›‹›"‹›; run#1(checkedDiv@7#0)‹›‹› }‹›
//│ Type: ⊤


fun show: CodeBase[out Any, out Any] -> Str = s => "debug"
show
//│ Elab: { fun show: (class:CodeBase#8[WildcardTy(None,Some(Ref(class:Any))), WildcardTy(None,Some(Ref(class:Any)))]‹›)‹› -> class:Str#0‹› = λs@1. "debug"‹›‹›; show#0 }‹›
//│ Type: (CodeBase[in ⊥ out ⊤, in ⊥ out ⊤]) ->{⊥} Str


fun inc(dbg) =
  x `=> let c = x `+ `1 in let t = dbg(c) in c
inc
//│ Elab: { fun inc(dbg@1) = code"λx@2. ${{ let c@3 = code"+#0(${x@2#0}‹›, ${code"1‹›"‹›}‹›)‹›‹›"‹›; { let t@5 = dbg@1#0(c@3#0)‹›‹›; c@3#1 }‹› }‹›}‹›‹›"‹›; inc#0 }‹›
//│ Type: (α29_0) ->{⊥ ∨ α33_2 ∨ ⊥ ∨ ⊥ ∨ ⊥ ∨ ⊥ ∨ ⊥} CodeBase[in ⊥ out α40_1, in ⊥ out ⊤]
//│ Where:
//│   α29_0 <: ¬⊤ ∧ ¬(CodeBase[in ⊥ out ⊥ ∨ ⊤ ∧ ¬⊥ ∧ α35_0 ∨ ⊤ ∧ ¬⊥ ∧ α36_0, in ⊥ out ⊤ ∧ ¬⊥] ∧ ¬⊥) ->{⊤ ∧ ¬⊥ ∧ α38_0} ⊤ ∧ ¬⊥ ∧ α37_0
//│   ⊤ ∧ ¬⊥ ∧ ⊤ <: α35_0
//│   α38_0 <: α33_2

inc(c => log(show(c)))
//│ Elab: { inc#1(λc@2. log#0(show#1(c@2#0)‹›‹›)‹›‹›‹›)‹›‹› }‹›
//│ Type: CodeBase[in ⊥ out α40_1, in ⊥ out ⊤]

fun body: [T, C] -> (CodeBase[out T, out Any], CodeBase[out C, out Any]) -> Int -> CodeBase[out T | C, out Any]
fun body(x, y) = case
  0 then x
  1 then y
  n then body(y, x `+ y)(n - 1)
fun gib_naive(n) =
  (x, y) `=> body(x, y)(n)
let gn5 = run(gib_naive(5))
//│ Elab: { fun body: forall T@2, C@3: FunTy(Tup(List(Fld(‹›,TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(T@2))), WildcardTy(None,Some(Ref(class:Any))))),None), Fld(‹›,TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(C@3))), WildcardTy(None,Some(Ref(class:Any))))),None))),FunTy(Tup(List(Fld(‹›,Ref(class:Int),None))),TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(CompType(Ref(T@2),Ref(C@3),true))), WildcardTy(None,Some(Ref(class:Any)))))))‹›; fun body(x@4, y@5): forall T@14, C@15: FunTy(Tup(List(Fld(‹›,TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(T@14))), WildcardTy(None,Some(Ref(class:Any))))),None), Fld(‹›,TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(C@15))), WildcardTy(None,Some(Ref(class:Any))))),None))),FunTy(Tup(List(Fld(‹›,Ref(class:Int),None))),TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(CompType(Ref(T@14),Ref(C@15),true))), WildcardTy(None,Some(Ref(class:Any)))))))‹› = λn@6. if Cons(Boolean(App(Ref(==),Tup(List(Fld(‹›,Ref(n@6),None), Fld(‹›,Lit(IntLit(0)),None)))),Else(Ref(x@4))),Cons(Boolean(App(Ref(==),Tup(List(Fld(‹›,Ref(n@6),None), Fld(‹›,Lit(IntLit(1)),None)))),Else(Ref(y@5))),Else(App(App(Ref(body),Tup(List(Fld(‹›,Ref(y@5),None), Fld(‹›,Quoted(App(Ref(+),Tup(List(Fld(‹›,Unquoted(Ref(x@4)),None), Fld(‹›,Unquoted(Ref(y@5)),None))))),None)))),Tup(List(Fld(‹›,App(Ref(-),Tup(List(Fld(‹›,Ref(n@6),None), Fld(‹›,Lit(IntLit(1)),None)))),None)))))))‹›‹›; fun gib_naive(n@16) = code"λx@17, y@18. ${body#1(x@17#0, y@18#0)‹›‹›(n@16#0)‹›‹›}‹›‹›"‹›; let gn5@22 = run#2(gib_naive#0(5‹›)‹›‹›)‹›‹›; }‹›
//│ Type: ⊤

fun bind(rhs, k) = `let x = rhs `in k(x)
bind
//│ Elab: { fun bind(rhs@1, k@2) = code"{ let x@3 = ${rhs@1#0}‹›; ${k@2#0(x@3#0)‹›‹›}‹› }‹›"‹›; bind#0 }‹›
//│ Type: (α58_0, α59_0) ->{⊥ ∨ α63_2 ∨ ⊥ ∨ ⊥} CodeBase[in ⊥ out α60_1 ∨ α69_1, in ⊥ out ⊤]
//│ Where:
//│   α58_0 <: ¬⊤ ∧ ¬⊥ ∨ CodeBase[in ⊥ out ⊤ ∧ ¬⊥ ∧ α61_0, in ⊥ out ⊤ ∧ ¬⊥]
//│   α59_0 <: ¬⊤ ∧ ¬(CodeBase[in ⊤ ∧ ¬⊥ ∧ ⊥ out ⊤ ∧ ¬⊥ ∧ ⊤, in ⊥ out ⊥] ∧ ¬⊥) ->{⊤ ∧ ¬⊥ ∧ α66_0} ⊤ ∧ ¬⊥ ∧ α65_0
//│   α65_0 <: ¬⊤ ∧ ¬⊥ ∨ CodeBase[in ⊥ out ⊤ ∧ ¬⊥ ∧ α68_0, in ⊥ out ⊤ ∧ ¬⊥]
//│   α61_0 <: α60_1
//│   ⊤ ∧ ¬⊥ ∧ ¬⊥ ∧ α68_0 <: α69_1
//│   α66_0 <: α63_2

fun bind: [G] -> (CodeBase[out G, out Any], [C] -> CodeBase[out C, out Any] -> CodeBase[out C | G, out Any]) -> CodeBase[out G, out Any]
fun bind(rhs, k) = `let x = rhs `in k(x)
bind
//│ Elab: { fun bind: forall G@2: FunTy(Tup(List(Fld(‹›,TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(G@2))), WildcardTy(None,Some(Ref(class:Any))))),None), Fld(‹›,Forall(List(C@3),FunTy(Tup(List(Fld(‹›,TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(C@3))), WildcardTy(None,Some(Ref(class:Any))))),None))),TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(CompType(Ref(C@3),Ref(G@2),true))), WildcardTy(None,Some(Ref(class:Any))))))),None))),TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(G@2))), WildcardTy(None,Some(Ref(class:Any))))))‹›; fun bind(rhs@4, k@5): forall G@9: FunTy(Tup(List(Fld(‹›,TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(G@9))), WildcardTy(None,Some(Ref(class:Any))))),None), Fld(‹›,Forall(List(C@10),FunTy(Tup(List(Fld(‹›,TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(C@10))), WildcardTy(None,Some(Ref(class:Any))))),None))),TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(CompType(Ref(C@10),Ref(G@9),true))), WildcardTy(None,Some(Ref(class:Any))))))),None))),TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(G@9))), WildcardTy(None,Some(Ref(class:Any))))))‹› = code"{ let x@6 = ${rhs@4#0}‹›; ${k@5#0(x@6#0)‹›‹›}‹› }‹›"‹›; bind#0 }‹›
//│ Type: forall α70_1: (CodeBase[in ⊥ out α70_1, in ⊥ out ⊤], forall α71_2: (CodeBase[in ⊥ out α71_2, in ⊥ out ⊤]) ->{⊥} CodeBase[in ⊥ out α71_2 ∨ α70_1, in ⊥ out ⊤]) ->{⊥} CodeBase[in ⊥ out α70_1, in ⊥ out ⊤]


fun body: [G] -> (CodeBase[out G, out Any], CodeBase[out G, out Any]) -> Int -> CodeBase[out G, out Any]
fun body(x, y) = case
  0 then x
  1 then y
  n then bind of x `+ y, [C] => (z: CodeBase[out C, out Any]) => body(y, z)(n - 1)
//│ Elab: { fun body: forall G@2: FunTy(Tup(List(Fld(‹›,TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(G@2))), WildcardTy(None,Some(Ref(class:Any))))),None), Fld(‹›,TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(G@2))), WildcardTy(None,Some(Ref(class:Any))))),None))),FunTy(Tup(List(Fld(‹›,Ref(class:Int),None))),TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(G@2))), WildcardTy(None,Some(Ref(class:Any)))))))‹›; fun body(x@3, y@4): forall G@16: FunTy(Tup(List(Fld(‹›,TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(G@16))), WildcardTy(None,Some(Ref(class:Any))))),None), Fld(‹›,TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(G@16))), WildcardTy(None,Some(Ref(class:Any))))),None))),FunTy(Tup(List(Fld(‹›,Ref(class:Int),None))),TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(G@16))), WildcardTy(None,Some(Ref(class:Any)))))))‹› = λn@5. if Cons(Boolean(App(Ref(==),Tup(List(Fld(‹›,Ref(n@5),None), Fld(‹›,Lit(IntLit(0)),None)))),Else(Ref(x@3))),Cons(Boolean(App(Ref(==),Tup(List(Fld(‹›,Ref(n@5),None), Fld(‹›,Lit(IntLit(1)),None)))),Else(Ref(y@4))),Else(App(Ref(bind),Tup(List(Fld(‹›,Quoted(App(Ref(+),Tup(List(Fld(‹›,Unquoted(Ref(x@3)),None), Fld(‹›,Unquoted(Ref(y@4)),None))))),None), Fld(‹›,Forall(List(C@8),Lam(List(Param(‹›,z@9,Some(TyApp(Ref(class:CodeBase),List(WildcardTy(None,Some(Ref(C@8))), WildcardTy(None,Some(Ref(class:Any)))))))),App(App(Ref(body),Tup(List(Fld(‹›,Ref(y@4),None), Fld(‹›,Ref(z@9),None)))),Tup(List(Fld(‹›,App(Ref(-),Tup(List(Fld(‹›,Ref(n@5),None), Fld(‹›,Lit(IntLit(1)),None)))),None)))))),None)))))))‹›‹›; }‹›
//│ Type: ⊤

fun gib(n) = (x, y) `=> body(x, y)(n)
let g5 = run(gib(5))
//│ Elab: { fun gib(n@1) = code"λx@2, y@3. ${body#1(x@2#0, y@3#0)‹›‹›(n@1#0)‹›‹›}‹›‹›"‹›; let g5@7 = run#3(gib#0(5‹›)‹›‹›)‹›‹›; }‹›
//│ Type: ⊤
