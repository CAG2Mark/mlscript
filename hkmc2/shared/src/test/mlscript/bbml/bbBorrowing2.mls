:bbml
//│ Type: ⊤

//│ Type: ⊤

class Reg[Rg, Br]
//│ Type: ⊤

fun letreg: [E, Res] -> ([Rg] -> Reg[Rg, E] ->{E | Rg} Res) ->{E} Res
//│ Type: ⊤

fun subreg: [E, Rg, Br, Res] -> Reg[Rg, Br] -> ([Rg2] -> Reg[Rg2 & ~Rg, E] ->{E | Rg2} Res) ->{E} Res
//│ Type: ⊤

fun read: [Rg, Br] -> Reg[Rg, Br] ->{Br} Int
fun write: [Rg, Br] -> Reg[Rg, Br] ->{Rg} Int
//│ Type: ⊤


fun borrow: [Rg, Br, Res] -> Reg[Rg, Br] ->{Rg} (() ->{Br} Res) ->{Br} Res
//│ Type: ⊤

letreg of r =>
  read(r)
  borrow(r) of () =>
    read(r)
  write(r)
//│ Type: Int

:e
letreg of r =>
  read(r)
  borrow(r) of () =>
    write(r)
    read(r)
  write(r)
//│ ╔══[ERROR] Type error in block
//│ ║  l.23: 	letreg of r =>
//│ ║        	^^^^^^^^^^^^^^
//│ ║  l.24: 	  read(r)
//│ ║        	^^^^^^^^^
//│ ║  l.25: 	  borrow(r) of () =>
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.26: 	    write(r)
//│ ║        	^^^^^^^^^^^^
//│ ║  l.27: 	    read(r)
//│ ║        	^^^^^^^^^^^
//│ ║  l.28: 	  write(r)
//│ ║        	^^^^^^^^^^
//│ ╟── because: cannot constrain  'E  <:  ⊥
//│ ╟── because: cannot constrain  'E  <:  ¬()
//│ ╟── because: cannot constrain  ¬⊥ ∧ 'Rg  <:  ¬()
//│ ╟── because: cannot constrain  'Rg  <:  ¬()
//│ ╙── because: cannot constrain    <:  ¬()
//│ Type: Int


fun borrow: [Rg, Br, Res] -> Reg[Rg, Br] ->{Rg} (() ->{Br | ~Rg} Res) ->{Br} Res
//│ Type: ⊤

letreg of r =>
  read(r)
  borrow(r) of () =>
    read(r)
  write(r)
//│ Type: Int

// FIXME why no error?
// :e
letreg of r =>
  read(r)
  borrow(r) of () =>
    write(r)
    read(r)
  write(r)
//│ Type: Int


// * TODO...


