:js
:il

// Check: __resume should not be instrumented
print(Predef.__resume)
//│ > __resume(cont, tail) {
//│ >     return (value) => {
//│ >       let scrut, tmp, tmp1, tmp2;
//│ >       tmp3: while (true) {
//│ >         if (cont) {
//│ >           tmp = cont.resume(value);
//│ >           value = tmp;
//│ >           if (value) {
//│ >             scrut = value.__isCont;
//│ >             if (scrut) {
//│ >               value.tail = tail;
//│ >               return value;
//│ >             } else {
//│ >               cont = cont.next;
//│ >               tmp1 = undefined;
//│ >             }
//│ >           } else {
//│ >             cont = cont.next;
//│ >             tmp1 = undefined;
//│ >           }
//│ >           tmp2 = tmp1;
//│ >           continue tmp3;
//│ >         } else {
//│ >           tmp2 = value;
//│ >         }
//│ >         break;
//│ >       }
//│ >       return tmp2;
//│ >     };
//│ >   }

// note: seems we can't use traits yet :|
// using a field to store the effect handler instead

// TODO: use this syntax
// TODO: prepend or append resumption parameter like fun perform(x)(resume): Str -> Str or fun perform(resume)(x): Str -> Str
// Handle the case where the function is defined like fun perform: Str, then e.perform should also yield an effect?
// handle ... fun perform(resume)(x)(y)(z): A = resume(x)
// Dummy handler: fun dummy_perform(x)(y)(z) = { let result = new EffectSig$(h, perform(x)(y)(z)); result.tail = result; return result; }
// resume: A -> ?
// this simplifies current handler code, no need to Array.push anymore
:sjs
abstract class Effect[A] with
  fun perform(x: A): Str -> Str
//│ JS:
//│ this.Effect = class Effect { constructor() {  } toString() { return "Effect"; } }; undefined

:sjs
class Effect[A](perform: Str -> Str)
//│ JS:
//│ this.Effect = function Effect(perform1) { return new Effect.class(perform1); };
//│ this.Effect.class = class Effect {
//│   constructor(perform) {
//│     this.perform = perform;
//│     
//│   }
//│   toString() { return "Effect(" + this.perform + ")"; }
//│ };
//│ undefined

:expect 'b'
val r = handle h = Effect with
  fun perform(arg, k) = "b"
in
  h.perform("k")
r
//│ r = 'b'

:expect 'k'
val r = handle h = Effect with
  fun perform(arg, k) = arg
in
  h.perform("k")
r
//│ r = 'k'

:expect 'Hello'
fun foo(e) = e.perform("hi")
val r = handle h = Effect with
  fun perform(arg, k) =
    print(arg)
    k(arg)
in
  (() => h.perform("Hello"))()
r
//│ > Hello
//│ r = 'Hello'

:expect 'hi'
fun foo(e) = e.perform("hi")
val r = handle h = Effect with
  fun perform(arg, k) =
    print(arg)
    k(arg)
in
  foo(h)
r
//│ > hi
//│ r = 'hi'

:expect '54321'
let result = ""
handle h = Effect with
  fun perform(arg, k) =
    let v = k(arg)
    result = result + arg
    v
in
  h.perform("1")
  h.perform("2")
  h.perform("3")
  h.perform("4")
  h.perform("5")
result
//│ result = '54321'

:expect 'b'
val x =
  handle h = Effect with
    fun perform(arg, k) =
      print(arg)
      "b"
  in
    h.perform("t")
x
//│ > t
//│ x = 'b'

// TODO: val is not working
:expect 'Hello World!'
fun foo(h) =
  print("Entering foo")
  let result = h.perform("Hello")
  h.perform("?")
  print("Exiting foo")
  result
val x = handle h = Effect with
  fun perform(arg, k) =
    print("handler called")
    let result = k(arg)
    print("handler finished")
    result
in
  print("mainbody start")
  let result = foo(h) + " World!"
  print("mainbody end")
  result
x
//│ > mainbody start
//│ > Entering foo
//│ > handler called
//│ > handler called
//│ > Exiting foo
//│ > mainbody end
//│ > handler finished
//│ > handler finished
//│ x = 'Hello World!'

:expect 'Hello World!'
fun foo(h) =
  print("Entering foo")
  let result = h.perform("Hello")
  h.perform("Oops!")
  print("Exiting foo")
  result
fun bar(h) =
  print("Entering bar")
  let result = foo(h) + " World"
  print("Exiting bar")
  result
fun foobar(h) =
  print("Entering foobar")
  let result = bar(h) + "!"
  print("Exiting foobar")
  result
val x = handle h = Effect with
  fun perform(arg, k) =
    print("handler called")
    let result = k(arg)
    print("handler finished")
    result
in
  print("mainbody start")
  let result = foobar(h)
  print("mainbody end")
  result
x
//│ > mainbody start
//│ > Entering foobar
//│ > Entering bar
//│ > Entering foo
//│ > handler called
//│ > handler called
//│ > Exiting foo
//│ > Exiting bar
//│ > Exiting foobar
//│ > mainbody end
//│ > handler finished
//│ > handler finished
//│ x = 'Hello World!'

class Cell(getVal: () -> Int, setVal: Int -> ())
let x = 0
let k
let m
let res = handle h = Cell with
  fun getVal(k) = k(x)
  fun setVal(value, k) =
    x = value
    k(())
in
  k = h.getVal()
  h.setVal(1)
  m = h.getVal()
//│ k = 0
//│ m = 1
//│ x = 1

class A(x) with
  fun debug() = print(x)
let x = new A(333)
x.debug()
//│ > 333
//│ x = A { x: 333 }

:fixme
fun f() =
  val x = 3
  let y = 5 in
    val x = 5
    x + y
//│ ═══[COMPILATION ERROR] [Uncaught SyntaxError] Identifier 'x' has already been declared

fun f() =
  let x = 2 
  let y = f()
  let z = 3
  2

class Eff(get: () -> Int)

:expect 120
fun fact(e, factvalue) = 
  if factvalue != 0 then
    factvalue * fact(e, factvalue-1)
  else e.get()
handle h = Eff with
  fun get(k) = k(1)
let result = fact(h, 5)
result
//│ result = 120

class StackDelay(raise: () -> ())

// stack safe recursion
:expect 5050
handle h = StackDelay with
  fun raise(k) =
    // console.trace("Stack unwinded!")
    k(10)
fun sum(depth, x) =
  val new_depth = if depth > 70 then
    // console.trace("Too deep, heapifying the stack")
    h.raise()
  else
    depth + 1
  if x != 0 then
    x + sum(new_depth, x - 1)
  else 0
let result = sum(0, 100)
result
//│ result = 5050

class StackDelay(raise: () -> Int)

// stack safe recursion
:expect 450015000
handle h = StackDelay with
  fun raise(k) = // TODO: This should codegen to a simple return without instrumentation
    k(10)
fun sum(depth, x) =
  val new_depth = if depth > 4000 then h.raise() else depth + 1
  if x != 0 then
    x + sum(new_depth, x - 1)
  else 0
let result = sum(0, 30000)
result
//│ result = 450015000

:re
fun sum(x) =
  if x != 0 then
    x + sum(x - 1)
  else 0
let result = sum(10000)
result
//│ ═══[RUNTIME ERROR] RangeError: Maximum call stack size exceeded
//│ result = 450015000
