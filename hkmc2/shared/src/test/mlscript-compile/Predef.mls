
module Predef with ...

fun id(x) = x

fun not(x) = x is false

fun (|>) pipe(x, f) = f(x)

fun (.) apply(receiver, f)(...args) = f(receiver, ...args)

fun (|>.) call(receiver, f)(...args) = f.call(receiver, ...args)

fun print(x) =
  console.log(String(x))

fun tupleSlice(xs, i, j) =
  globalThis.Array.prototype.slice.call(xs, i, xs.length - j)

fun tupleGet(xs, i) =
  globalThis.Array.prototype.at.call(xs, i)

fun stringStartsWith(string, prefix) = string.startsWith(prefix)

fun stringGet(string, i) = string.at(i)

fun stringDrop(string, n) = string.slice(n)

class MatchResult(captures)
class MatchFailure(errors)

fun checkArgs(functionName, expected, isUB, got) =
  if got < expected || isUB && got > expected then
    let name = if functionName.length > 0 then " '" + functionName + "'" else ""
    throw globalThis.Error("Function" + name + " expected " + expected + " arguments but got " + got)
    // TODO
    // throw globalThis.Error("Function" + name + " expected "
    //   + expected
    //   + (if isUB then "" else " at least")
    //   + " arguments but got " + got)
  else ()

class Test with
  val y = 1

// Private definitions for algebraic effects

class __Cont(resume, resumed, next, __isCont)

fun __resume(cont, tail)(value) =
  while cont then
    value = cont.resume(value)
    if value and value.__isCont then
      set value.tail = tail
      return value
    else
      cont = cont.next
  else
    value

fun __debugCont(cont) =
  let msg = "Chain: "
  let first = true
  while cont then
    if first then
      set first = false
    else
      set msg = msg + " -> "
    set msg = msg + "(" + cont.constructor.name
    if cont.tail then
      set msg = msg + " with tail " + cont.tail.constructor.name
    else ()
    set msg = msg + ")"
    set cont = cont.next
  else
    print(msg)
