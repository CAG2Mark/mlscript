
module Predef with ...

fun id(x) = x

fun not(x) = x is false

fun (|>) pipeInto(x, f) = f(x)
fun (<|) pipeFrom(f, x) = f(x)

fun (>>) andThen(f, g)(x) = g(f(x))
fun (<<) compose(f, g)(x) = f(g(x))

fun (.) passTo(receiver, f)(...args) = f(receiver, ...args)

fun (|>.) call(receiver, f)(...args) = f.call(receiver, ...args)

fun print(x) =
  console.log(String(x))

val assert = console.assert

fun tupleSlice(xs, i, j) =
  globalThis.Array.prototype.slice.call(xs, i, xs.length - j)

fun tupleGet(xs, i) =
  globalThis.Array.prototype.at.call(xs, i)

fun stringStartsWith(string, prefix) = string.startsWith(prefix)

fun stringGet(string, i) = string.at(i)

fun stringDrop(string, n) = string.slice(n)

class MatchResult(captures)
class MatchFailure(errors)

fun checkArgs(functionName, expected, isUB, got) =
  if got < expected || isUB && got > expected do
    let name = if functionName.length > 0 then " '" + functionName + "'" else ""
    throw globalThis.Error("Function" + name + " expected " + expected + " arguments but got " + got)
    // TODO
    // throw globalThis.Error("Function" + name + " expected "
    //   + expected
    //   + (if isUB then "" else " at least")
    //   + " arguments but got " + got)

module TraceLogger with
  mut val enabled = false
  mut val indentLvl = 0
  fun indent() =
    if enabled then
      let prev = indentLvl
      set indentLvl = prev + 1
      prev
    else ()
  fun resetIndent(n) =
    if enabled then
      set indentLvl = n
    else ()
  fun log(msg) =
    if enabled then
      console.log("| ".repeat(indentLvl) + msg.replaceAll("\n", "\n" + "  ".repeat(indentLvl)))
    else ()

class Test with
  print("Test")
  val y = 1

// Private definitions for algebraic effects

abstract class __Cont(next) with
  fun resume(value)
class __TailList(next, tail)
class __HandleBlock(next, nextHandler, tail, handler)

class __EffectSig(next, nextHandler, tail, tailHandler, resumed, handler, handlerFun)
class __Return(value)

fun __mkEffect(handler, handlerFun) =
  let res = new __EffectSig(null, null, null, null, false, handler, handlerFun)
  set res.tail = res
  set res.tailHandler = res
  res

// fun checkEffectHead(cur) =
//   if cur is __EffectSig then
//     let hand = cur
//     while hand.nextHandler !== null do
//       set hand = hand.nextHandler
//     assert(hand === cur.tailHandler)
//     assert(cur.resumed === false)

fun __handleBlockImpl(cur, handler) =
  let handlerCont = new __HandleBlock(null, null, null, handler)
  set handlerCont.tail = handlerCont
  while cur is
    __EffectSig then
      let nxt = __handleEffect(cur, handler, handlerCont)
      if cur === nxt then
        set cur.tailHandler.nextHandler = handlerCont
        set cur.tailHandler = handlerCont
        set cur.tail = handlerCont.tail
        return cur
      else
        set cur = nxt
    else return cur

fun __handleEffect(cur, handler, handlerTailList) =
  let prevCont = cur
  let handlerCont = cur.nextHandler
  while handlerCont is __HandleBlock and handlerCont.handler !== cur.handler do
    set prevCont = handlerCont
    set handlerCont = handlerCont.nextHandler
  if handlerCont then
    let origTail = cur.tailHandler
    set prevCont.nextHandler = null
    set cur.tailHandler = prevCont
    let savedNext = handlerCont.next
    set cur = cur.handlerFun(__resume(cur, handlerCont))
    if savedNext !== handlerCont.next do
      set handlerCont.next.next = savedNext
    if cur is __EffectSig then
      set cur.tailHandler.nextHandler = handlerCont
      set cur.tailHandler = origTail
      return cur
    else if cur is __Return then
      set cur.tailHandler.nextHandler = handlerCont
      set cur.tailHandler = origTail
      return cur
    else
      set cur = __resume(handlerCont, null)(cur)
  else if handler === cur.handler then
    let savedNext = handlerTailList.next
    set cur = cur.handlerFun(__resume(cur, handlerTailList))
    if savedNext !== handlerTailList.next do
      set handlerTailList.next.next = savedNext
      if savedNext === null do
        set handlerTailList.tail = handlerTailList.next
  else
    return cur
  while
    cur is
      __EffectSig then return cur
      __Return then return cur
    handlerTailList.next is __Cont then
      let nxt = handlerTailList.next
      set handlerTailList.next = handlerTailList.next.next
      set cur = nxt.resume(cur)
    else cur

// fun __resume(cur, tail)(value) =
//   if cur.resumed do
//     throw Error("multiple resumption")
//   set cur.resumed = true
//   let cont = cur.next
//   while
//     cont is __Cont then
//       value = cont.resume(value)
//       if value is __EffectSig then
//         set value.tail = tail
//         if cur.tailHandler !== cur do
//           set value.tailHandler.nextHandler = cur.nextHandler
//           set value.tailHandler = cur.tailHandler
//         return value
//       else
//         set cont = cont.next
//     cur.nextHandler is __HandleBlock then
//       set cont = cur.nextHandler.next
//       set cur.nextHandler = cur.nextHandler.nextHandler
//     else value

fun __resume(cur, tail)(value) =
  if cur.resumed do
    throw Error("multiple resumption")
  set cur.resumed = true
  
  let cont = cur.next
  while
    cont is __Cont do
      // NOTE: we do not need to link to cont.next again if it is effsig
      // because cont.resume will not change its own next
      set value = cont.resume(value)
      if value is __EffectSig then
        set value.tail = tail
        if cur.tailHandler !== cur do
          set value.tailHandler.nextHandler = cur.nextHandler
          set value.tailHandler = cur.tailHandler
        return value
      else
        set cont = cont.next
  // We're done with the head, now resume the handle blocks
  while
    cur.nextHandler is __HandleBlock and
      cur.nextHandler.next is __Cont then
        // resuming tailHandlerList or post handler continuations
        let nxt = cur.nextHandler.next
        set value = nxt.resume(value)
        if value is __EffectSig then
          // console.dir(cur.nextHandler.next)
          // console.dir(value.tail.next)
          // console.dir(value)
          // console.dir(cur)
          // console.dir(nxt)
          // console.log(nxt.resume.toString())
          assert(cur.tailHandler !== cur)
          assert(cur.nextHandler !== null)
          // This checks when continuation resume results in tail call to effectful func
          if cur.nextHandler.next === value.tail.next then
            set value.tail.next = null
          else
            set cur.nextHandler.next = cur.nextHandler.next.next
          set value.tail = tail
          set value.tailHandler.nextHandler = cur.nextHandler
          set value.tailHandler = cur.tailHandler
          return value
        else
          assert(cur.nextHandler.next !== cur.nextHandler.next.next)
          set cur.nextHandler.next = cur.nextHandler.next.next
      // here using else will emit the wrong code and cause null to be returned from the loop
      true then
        // the list is empty, go to next handle block
        assert(cur.nextHandler.next === null)
        assert(cur.nextHandler !== cur.nextHandler.nextHandler)
        set cur.nextHandler = cur.nextHandler.nextHandler
    else
      assert(cur.nextHandler === null)
      return value

// stack safety
val __stackDepth = 0
val __stackHandler = null
abstract class __StackDelay() with
  fun perform()