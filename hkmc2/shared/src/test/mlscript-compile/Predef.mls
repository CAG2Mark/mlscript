
module Predef with ...

fun id(x) = x

fun not(x) = x is false

fun (|>) pipe(x, f) = f(x)

fun (.) apply(receiver, f)(...args) = f(receiver, ...args)

fun (|>.) call(receiver, f)(...args) = f.call(receiver, ...args)

fun print(x) =
  console.log(String(x))

fun tupleSlice(xs, i, j) =
  globalThis.Array.prototype.slice.call(xs, i, xs.length - j)

fun tupleGet(xs, i) =
  globalThis.Array.prototype.at.call(xs, i)

fun stringStartsWith(string, prefix) = string.startsWith(prefix)

fun stringGet(string, i) = string.at(i)

fun stringDrop(string, n) = string.slice(n)

class MatchResult(captures)
class MatchFailure(errors)

fun checkArgs(functionName, expected, isUB, got) =
  if got < expected || isUB && got > expected do
    let name = if functionName.length > 0 then " '" + functionName + "'" else ""
    throw globalThis.Error("Function" + name + " expected " + expected + " arguments but got " + got)
    // TODO
    // throw globalThis.Error("Function" + name + " expected "
    //   + expected
    //   + (if isUB then "" else " at least")
    //   + " arguments but got " + got)

module TraceLogger with
  mut val enabled = false
  mut val indentLvl = 0
  fun indent() =
    if enabled then
      let prev = indentLvl
      set indentLvl = prev + 1
      prev
    else ()
  fun resetIndent(n) =
    if enabled then
      set indentLvl = n
    else ()
  fun log(msg) =
    if enabled then
      console.log("| ".repeat(indentLvl) + msg.replaceAll("\n", "\n" + "  ".repeat(indentLvl)))
    else ()

class Test with
  val y = 1

// Private definitions for algebraic effects

abstract class __Cont(next, resumed) with
  fun resume(value)

class __Return(value)

fun __handleEffect(cur, handler, handlerTailList) =
  let handlerCont = cur.nextHandler
  while handlerCont is __Cont and handlerCont.nextHandler !== cur.handler then
    set handlerCont = handlerCont.nextHandler
  else ()
  if handlerCont then
    let savedNext = handlerCont.next
    set cur = cur.handlerFun(__resume(cur, handlerCont, handlerCont))
    if savedNext !== handlerCont.next then
      set handlerCont.next.next = savedNext
    else ()
    if cur is __Cont then
      cur
    else if cur is __Return then
      cur
    else
      __resume(handlerCont, undefined, undefined)(cur)
  else if handler === cur.handler then
    let savedNext = handlerTailList.next
    set cur = cur.handlerFun(__resume(cur, handlerTailList, handlerCont))
    if savedNext !== handlerTailList.next then
      set handlerTailList.next.next = savedNext
    else ()
    cur
  else cur

fun __resume(cur, tail, handlerCont)(value) =
  let nextHandler = cur.nextHandler
  let cont = cur.next
  while
    cont is __Cont then
      value = cont.resume(value)
      if value is __Cont then
        set value.tail = tail
        set value.tailHandler.nextHandler = nextHandler
        return value
      else if value is __Return then
        return value
      else
        set cont = cont.next
    nextHandler !== handlerCont then
      set cont = nextHandler.next
      set nextHandler = nextHandler.nextHandler
    else value

