:NewParser
:ParseOnly

:GraphInterp
:GraphOpt
class True
class False
fun fib(n) = if n < 2 then n else fib(n-1) + fib(n-2)
fib(20)
//│ |#class| |True|↵|#class| |False|↵|#fun| |fib|(|n|)| |#=| |#if| |n| |<| |2| |#then| |n| |#else| |fib|(|n|-|1|)| |+| |fib|(|n|-|2|)|↵|fib|(|20|)|
//│ Parsed: {class True {}; class False {}; fun fib = (n,) => if (<(n,)(2,)) then n else +(fib(-(n,)(1,),),)(fib(-(n,)(2,),),); fib(20,)}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, fib, [n%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%0 = <(n%0,2) -- #28
//│   in if x%0 -- #27
//│     true => jump j%0(n%0) -- #5
//│     false => let x%2 = -(n%0,1) -- #26
//│       in let* (x%3) = fib(x%2) -- #25
//│         in let x%4 = -(n%0,2) -- #24
//│           in let* (x%5) = fib(x%4) -- #23
//│             in let x%6 = +(x%3,x%5) -- #22
//│               in jump j%0(x%6) -- #21
//│ )
//│ Def(1, j%0, [x%1], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%1 -- #3
//│ )
//│ },
//│ let* (x%7) = fib(20) -- #34
//│   in x%7 -- #33)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, fib, [n%0], [{<EDirect@fib:#26-let x%2 = ...>,<EDirect@fib:#28-let x%0 = ...>,<EDirect@fib:#35-...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: Some(0),
//│ 1, 
//│ let x%0 = <(n%0,2) -- #28
//│   in if x%0 -- #27
//│     true => n%0 -- #35
//│     false => let x%2 = -(n%0,1) -- #26
//│       in let* (x%3) = fib(x%2) -- #25
//│         in let x%4 = -(n%0,2) -- #24
//│           in let* (x%5) = fib(x%4) -- #23
//│             in let x%6 = +(x%3,x%5) -- #22
//│               in x%6 -- #36
//│ )
//│ },
//│ let* (x%7) = fib(20) -- #34
//│   in x%7 -- #33)
//│ 
//│ Interpreted ------------------------------
//│ 6765
//│ 
//│ 
//│ Interpreted ------------------------------
//│ 6765
//│ 
//│ 
//│ 
//│ Fuel used: 1

:GraphInterp
:GraphOpt
class True
class False
fun odd(x) = if x == 0 then False else even(x-1)
fun even(x) = if x == 0 then True else odd(x-1)
fun foo() = odd(10)
foo()
//│ |#class| |True|↵|#class| |False|↵|#fun| |odd|(|x|)| |#=| |#if| |x| |==| |0| |#then| |False| |#else| |even|(|x|-|1|)|↵|#fun| |even|(|x|)| |#=| |#if| |x| |==| |0| |#then| |True| |#else| |odd|(|x|-|1|)|↵|#fun| |foo|(||)| |#=| |odd|(|10|)|↵|foo|(||)|
//│ Parsed: {class True {}; class False {}; fun odd = (x,) => if (==(x,)(0,)) then False else even(-(x,)(1,),); fun even = (x,) => if (==(x,)(0,)) then True else odd(-(x,)(1,),); fun foo = () => odd(10,); foo()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, odd, [x%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%1 = ==(x%0,0) -- #18
//│   in if x%1 -- #17
//│     true => let x%3 = False() -- #6
//│       in jump j%0(x%3) -- #5
//│     false => let x%4 = -(x%0,1) -- #16
//│       in let* (x%5) = even(x%4) -- #15
//│         in jump j%0(x%5) -- #14
//│ )
//│ Def(1, j%0, [x%2], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%2 -- #3
//│ )
//│ Def(2, even, [x%6], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%7 = ==(x%6,0) -- #37
//│   in if x%7 -- #36
//│     true => let x%9 = True() -- #25
//│       in jump j%1(x%9) -- #24
//│     false => let x%10 = -(x%6,1) -- #35
//│       in let* (x%11) = odd(x%10) -- #34
//│         in jump j%1(x%11) -- #33
//│ )
//│ Def(3, j%1, [x%8], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%8 -- #22
//│ )
//│ Def(4, foo, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%12) = odd(10) -- #43
//│   in x%12 -- #42
//│ )
//│ },
//│ let* (x%13) = foo() -- #47
//│   in x%13 -- #46)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, odd, [x%0], [{<EDirect@odd:#16-let x%4 = ...>,<EDirect@odd:#18-let x%1 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(1),
//│ 1, 
//│ let x%1 = ==(x%0,0) -- #18
//│   in if x%1 -- #17
//│     true => let x%3 = False() -- #6
//│       in x%3 -- #48
//│     false => let x%4 = -(x%0,1) -- #16
//│       in let* (x%5) = even(x%4) -- #15
//│         in x%5 -- #49
//│ )
//│ Def(2, even, [x%6], [{<EDirect@even:#35-let x%10 = ...>,<EDirect@even:#37-let x%7 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(1),
//│ 1, 
//│ let x%7 = ==(x%6,0) -- #37
//│   in if x%7 -- #36
//│     true => let x%9 = True() -- #25
//│       in x%9 -- #50
//│     false => let x%10 = -(x%6,1) -- #35
//│       in let* (x%11) = odd(x%10) -- #34
//│         in x%11 -- #51
//│ )
//│ Def(4, foo, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%12) = odd(10) -- #43
//│   in x%12 -- #42
//│ )
//│ },
//│ let* (x%13) = foo() -- #47
//│   in x%13 -- #46)
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ 
//│ Fuel used: 1

:GraphInterp
:GraphOpt
class True
class False
class A
class B(b)
fun not(x) =
  if x then False else True
fun foo(x) =
  if x then A
       else B(foo(not(x)))
fun main() = foo(False)
main()
//│ |#class| |True|↵|#class| |False|↵|#class| |A|↵|#class| |B|(|b|)|↵|#fun| |not|(|x|)| |#=|→|#if| |x| |#then| |False| |#else| |True|←|↵|#fun| |foo|(|x|)| |#=|→|#if| |x| |#then| |A|→|#else| |B|(|foo|(|not|(|x|)|)|)|←|←|↵|#fun| |main|(||)| |#=| |foo|(|False|)|↵|main|(||)|
//│ Parsed: {class True {}; class False {}; class A {}; class B(b,) {}; fun not = (x,) => {if (x) then False else True}; fun foo = (x,) => {if (x) then A else B(foo(not(x,),),)}; fun main = () => foo(False,); main()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(0, not, [x%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x%0 -- #8
//│   true => let x%2 = False() -- #4
//│     in jump j%0(x%2) -- #3
//│   false => let x%3 = True() -- #7
//│     in jump j%0(x%3) -- #6
//│ )
//│ Def(1, j%0, [x%1], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%1 -- #1
//│ )
//│ Def(2, foo, [x%4], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x%4 -- #30
//│   true => let x%6 = A() -- #13
//│     in jump j%1(x%6) -- #12
//│   false => let* (x%7) = not(x%4) -- #29
//│     in let* (x%8) = foo(x%7) -- #28
//│       in let x%9 = B(x%8) -- #27
//│         in jump j%1(x%9) -- #26
//│ )
//│ Def(3, j%1, [x%5], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%5 -- #10
//│ )
//│ Def(4, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%10 = False() -- #37
//│   in let* (x%11) = foo(x%10) -- #36
//│     in x%11 -- #35
//│ )
//│ },
//│ let* (x%12) = main() -- #41
//│   in x%12 -- #40)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(0, not, [x%0], [{<EDestruct@not:#8-if x%0 ...>,<EDirect@not:#8-if x%0 ...>}],
//│ S: None,
//│ I: [[Some(ICtor(False))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ if x%0 -- #8
//│   true => let x%2 = False() -- #4
//│     in x%2 -- #42
//│   false => let x%3 = True() -- #7
//│     in x%3 -- #43
//│ )
//│ Def(2, foo, [x%4], [{<EDestruct@foo:#30-if x%4 ...>,<EDirect@foo:#29-let* (x%7) = not ...>,<EDirect@foo:#30-if x%4 ...>,<EIndirectDestruct@foo:#29-let* (x%7) = not ...>}],
//│ S: None,
//│ I: [[Some(ICtor(False))],[Some(IMix(ICtor(False),ICtor(True)))]],
//│ R: [Some(IMix(ICtor(A),ICtor(B)))],
//│ Rec: Some(1),
//│ 1, 
//│ if x%4 -- #30
//│   true => let x%6 = A() -- #13
//│     in x%6 -- #44
//│   false => let* (x%7) = not(x%4) -- #29
//│     in let* (x%8) = foo(x%7) -- #28
//│       in let x%9 = B(x%8) -- #27
//│         in x%9 -- #45
//│ )
//│ Def(4, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(A),ICtor(B)))],
//│ Rec: None,
//│ 1, 
//│ let x%10 = False() -- #37
//│   in let* (x%11) = foo(x%10) -- #36
//│     in x%11 -- #35
//│ )
//│ },
//│ let* (x%12) = main() -- #41
//│   in x%12 -- #40)
//│ 
//│ Interpreted ------------------------------
//│ B(A())
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(2, foo, [x%4], [{<EDestruct@foo:#54-if x%4 ...>,<EDirect@foo:#53-jump foo$D%1 ...>,<EDirect@foo:#54-if x%4 ...>}],
//│ S: None,
//│ I: [[Some(ICtor(True))]],
//│ R: [Some(IMix(ICtor(A),ICtor(B)))],
//│ Rec: Some(1),
//│ 1, 
//│ if x%4 -- #54
//│   true => let x%6 = A() -- #67
//│     in x%6 -- #44
//│   false => jump foo$D%1(x%4) -- #53
//│ )
//│ Def(4, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(ICtor(B))],
//│ Rec: None,
//│ 1, 
//│ let x%10 = False() -- #37
//│   in let* (x%11) = foo$D%1(x%10) -- #58
//│     in x%11 -- #35
//│ )
//│ Def(10, foo$D%1, [x%4], [{}],
//│ S: None,
//│ I: [[Some(ICtor(False))]],
//│ R: [Some(ICtor(B))],
//│ Rec: Some(1),
//│ 1, 
//│ let x%3 = True() -- #65
//│   in let* (x%8) = foo(x%3) -- #28
//│     in let x%9 = B(x%8) -- #27
//│       in x%9 -- #45
//│ )
//│ },
//│ let* (x%12) = main() -- #41
//│   in x%12 -- #40)
//│ 
//│ Interpreted ------------------------------
//│ B(A())
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(4, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(ICtor(B))],
//│ Rec: None,
//│ 1, 
//│ let x%10 = False() -- #37
//│   in let* (x%11) = foo$D%1(x%10) -- #58
//│     in x%11 -- #35
//│ )
//│ Def(10, foo$D%1, [x%4], [{}],
//│ S: None,
//│ I: [[Some(ICtor(False))]],
//│ R: [Some(ICtor(B))],
//│ Rec: None,
//│ 1, 
//│ let x%6 = A() -- #79
//│   in let x%9 = B(x%6) -- #27
//│     in x%9 -- #45
//│ )
//│ },
//│ let* (x%12) = main() -- #41
//│   in x%12 -- #40)
//│ 
//│ Interpreted ------------------------------
//│ B(A())
//│ 
//│ 
//│ Interpreted ------------------------------
//│ B(A())
//│ 
//│ 
//│ 
//│ Fuel used: 3

:GraphInterp
:GraphOpt
class True
class False
class A()
class B(b)
fun aaa() =
  let m = 1
  let n = 2
  let p = 3
  let q = 4
  m + n - p + q
fun bbb() =
  let x = aaa()
  x * 100 + 4
fun not(x) =
  if x then False else True
fun foo(x) =
  if x then A
       else B(foo(not(x)))
fun main() =
  let x = foo(False)
  if x is
    A then aaa()
    B(b1) then bbb()
main()
//│ |#class| |True|↵|#class| |False|↵|#class| |A|(||)|↵|#class| |B|(|b|)|↵|#fun| |aaa|(||)| |#=|→|#let| |m| |#=| |1|↵|#let| |n| |#=| |2|↵|#let| |p| |#=| |3|↵|#let| |q| |#=| |4|↵|m| |+| |n| |-| |p| |+| |q|←|↵|#fun| |bbb|(||)| |#=|→|#let| |x| |#=| |aaa|(||)|↵|x| |*| |100| |+| |4|←|↵|#fun| |not|(|x|)| |#=|→|#if| |x| |#then| |False| |#else| |True|←|↵|#fun| |foo|(|x|)| |#=|→|#if| |x| |#then| |A|→|#else| |B|(|foo|(|not|(|x|)|)|)|←|←|↵|#fun| |main|(||)| |#=|→|#let| |x| |#=| |foo|(|False|)|↵|#if| |x| |is|→|A| |#then| |aaa|(||)|↵|B|(|b1|)| |#then| |bbb|(||)|←|←|↵|main|(||)|
//│ Parsed: {class True {}; class False {}; class A() {}; class B(b,) {}; fun aaa = () => {let m = 1; let n = 2; let p = 3; let q = 4; +(-(+(m,)(n,),)(p,),)(q,)}; fun bbb = () => {let x = aaa(); +(*(x,)(100,),)(4,)}; fun not = (x,) => {if (x) then False else True}; fun foo = (x,) => {if (x) then A else B(foo(not(x,),),)}; fun main = () => {let x = foo(False,); if x is ‹(A) then aaa(); (B(b1,)) then bbb()›}; main()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(0, aaa, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%0 = 1 -- #17
//│   in let x%1 = 2 -- #16
//│     in let x%2 = 3 -- #15
//│       in let x%3 = 4 -- #14
//│         in let x%4 = +(x%0,x%1) -- #13
//│           in let x%5 = -(x%4,x%2) -- #12
//│             in let x%6 = +(x%5,x%3) -- #11
//│               in x%6 -- #10
//│ )
//│ Def(1, bbb, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%7) = aaa() -- #28
//│   in let x%8 = *(x%7,100) -- #27
//│     in let x%9 = +(x%8,4) -- #26
//│       in x%9 -- #25
//│ )
//│ Def(2, not, [x%10], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x%10 -- #37
//│   true => let x%12 = False() -- #33
//│     in jump j%0(x%12) -- #32
//│   false => let x%13 = True() -- #36
//│     in jump j%0(x%13) -- #35
//│ )
//│ Def(3, j%0, [x%11], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%11 -- #30
//│ )
//│ Def(4, foo, [x%14], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x%14 -- #59
//│   true => let x%16 = A() -- #42
//│     in jump j%1(x%16) -- #41
//│   false => let* (x%17) = not(x%14) -- #58
//│     in let* (x%18) = foo(x%17) -- #57
//│       in let x%19 = B(x%18) -- #56
//│         in jump j%1(x%19) -- #55
//│ )
//│ Def(5, j%1, [x%15], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%15 -- #39
//│ )
//│ Def(6, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%20 = False() -- #82
//│   in let* (x%21) = foo(x%20) -- #81
//│     in case x%21 of -- #80
//│       A => let* (x%23) = aaa() -- #71
//│         in jump j%2(x%23) -- #70
//│       B => let x%24 = x%21.b -- #79
//│         in let* (x%25) = bbb() -- #78
//│           in jump j%2(x%25) -- #77
//│ )
//│ Def(7, j%2, [x%22], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%22 -- #66
//│ )
//│ },
//│ let* (x%26) = main() -- #86
//│   in x%26 -- #85)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(0, aaa, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%4 = +(1,2) -- #13
//│   in let x%5 = -(x%4,3) -- #12
//│     in let x%6 = +(x%5,4) -- #11
//│       in x%6 -- #10
//│ )
//│ Def(1, bbb, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%7) = aaa() -- #28
//│   in let x%8 = *(x%7,100) -- #27
//│     in let x%9 = +(x%8,4) -- #26
//│       in x%9 -- #25
//│ )
//│ Def(2, not, [x%10], [{<EDestruct@not:#37-if x%10 ...>,<EDirect@not:#37-if x%10 ...>}],
//│ S: None,
//│ I: [[Some(ICtor(False))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ if x%10 -- #37
//│   true => let x%12 = False() -- #33
//│     in x%12 -- #89
//│   false => let x%13 = True() -- #36
//│     in x%13 -- #90
//│ )
//│ Def(4, foo, [x%14], [{<EDestruct@foo:#59-if x%14 ...>,<EDirect@foo:#58-let* (x%17) = not ...>,<EDirect@foo:#59-if x%14 ...>,<EIndirectDestruct@foo:#58-let* (x%17) = not ...>}],
//│ S: None,
//│ I: [[Some(ICtor(False))],[Some(IMix(ICtor(False),ICtor(True)))]],
//│ R: [Some(IMix(ICtor(A),ICtor(B)))],
//│ Rec: Some(1),
//│ 1, 
//│ if x%14 -- #59
//│   true => let x%16 = A() -- #42
//│     in x%16 -- #91
//│   false => let* (x%17) = not(x%14) -- #58
//│     in let* (x%18) = foo(x%17) -- #57
//│       in let x%19 = B(x%18) -- #56
//│         in x%19 -- #92
//│ )
//│ Def(6, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%20 = False() -- #82
//│   in let* (x%21) = foo(x%20) -- #81
//│     in case x%21 of -- #80
//│       A => let* (x%23) = aaa() -- #71
//│         in x%23 -- #87
//│       B => let* (x%25) = bbb() -- #78
//│         in x%25 -- #88
//│ )
//│ },
//│ let* (x%26) = main() -- #86
//│   in x%26 -- #85)
//│ 
//│ Interpreted ------------------------------
//│ 404
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(0, aaa, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%4 = +(1,2) -- #13
//│   in let x%5 = -(x%4,3) -- #12
//│     in let x%6 = +(x%5,4) -- #11
//│       in x%6 -- #10
//│ )
//│ Def(1, bbb, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%7) = aaa() -- #28
//│   in let x%8 = *(x%7,100) -- #27
//│     in let x%9 = +(x%8,4) -- #26
//│       in x%9 -- #25
//│ )
//│ Def(4, foo, [x%14], [{<EDestruct@foo:#96-if x%14 ...>,<EDirect@foo:#95-jump foo$D%1 ...>,<EDirect@foo:#96-if x%14 ...>}],
//│ S: None,
//│ I: [[Some(ICtor(True))]],
//│ R: [Some(IMix(ICtor(A),ICtor(B)))],
//│ Rec: Some(2),
//│ 1, 
//│ if x%14 -- #96
//│   true => let x%16 = A() -- #115
//│     in x%16 -- #91
//│   false => jump foo$D%1(x%14) -- #95
//│ )
//│ Def(6, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%20 = False() -- #82
//│   in let* (x%21) = foo$D%1(x%20) -- #105
//│     in case x%21 of -- #80
//│       A => let* (x%23) = aaa() -- #71
//│         in x%23 -- #87
//│       B => let* (x%25) = bbb() -- #78
//│         in x%25 -- #88
//│ )
//│ Def(10, foo$D%1, [x%14], [{}],
//│ S: None,
//│ I: [[Some(ICtor(False))]],
//│ R: [Some(ICtor(B))],
//│ Rec: Some(2),
//│ 1, 
//│ let x%13 = True() -- #109
//│   in let* (x%18) = foo(x%13) -- #57
//│     in let x%19 = B(x%18) -- #56
//│       in x%19 -- #92
//│ )
//│ },
//│ let* (x%26) = main() -- #86
//│   in x%26 -- #85)
//│ 
//│ Interpreted ------------------------------
//│ 404
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(0, aaa, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%4 = +(1,2) -- #13
//│   in let x%5 = -(x%4,3) -- #12
//│     in let x%6 = +(x%5,4) -- #11
//│       in x%6 -- #10
//│ )
//│ Def(1, bbb, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%7) = aaa() -- #28
//│   in let x%8 = *(x%7,100) -- #27
//│     in let x%9 = +(x%8,4) -- #26
//│       in x%9 -- #25
//│ )
//│ Def(6, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%20 = False() -- #82
//│   in let* (x%21) = foo$D%1(x%20) -- #105
//│     in case x%21 of -- #80
//│       A => let* (x%23) = aaa() -- #71
//│         in x%23 -- #87
//│       B => let* (x%25) = bbb() -- #78
//│         in x%25 -- #88
//│ )
//│ Def(10, foo$D%1, [x%14], [{}],
//│ S: None,
//│ I: [[Some(ICtor(False))]],
//│ R: [Some(ICtor(B))],
//│ Rec: None,
//│ 1, 
//│ let x%16 = A() -- #126
//│   in let x%19 = B(x%16) -- #56
//│     in x%19 -- #92
//│ )
//│ },
//│ let* (x%26) = main() -- #86
//│   in x%26 -- #85)
//│ 
//│ Interpreted ------------------------------
//│ 404
//│ 
//│ 
//│ Interpreted ------------------------------
//│ 404
//│ 
//│ 
//│ 
//│ Fuel used: 3


:GraphInterp
:GraphOpt
class True
class False
class S(s)
class O
fun odd(x) =
  if x is
    O then False
    S(s) then even(s)
fun even(x) =
  if x is
    O then True
    S(s) then odd(s)
fun foo() = odd(S(S(S(O))))
foo()
//│ |#class| |True|↵|#class| |False|↵|#class| |S|(|s|)|↵|#class| |O|↵|#fun| |odd|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |False|↵|S|(|s|)| |#then| |even|(|s|)|←|←|↵|#fun| |even|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |True|↵|S|(|s|)| |#then| |odd|(|s|)|←|←|↵|#fun| |foo|(||)| |#=| |odd|(|S|(|S|(|S|(|O|)|)|)|)|↵|foo|(||)|
//│ Parsed: {class True {}; class False {}; class S(s,) {}; class O {}; fun odd = (x,) => {if x is ‹(O) then False; (S(s,)) then even(s,)›}; fun even = (x,) => {if x is ‹(O) then True; (S(s,)) then odd(s,)›}; fun foo = () => odd(S(S(S(O,),),),); foo()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x%0 of -- #15
//│   O => let x%2 = False() -- #4
//│     in jump j%0(x%2) -- #3
//│   S => let x%3 = x%0.s -- #14
//│     in let* (x%4) = even(x%3) -- #13
//│       in jump j%0(x%4) -- #12
//│ )
//│ Def(1, j%0, [x%1], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%1 -- #1
//│ )
//│ Def(2, even, [x%5], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x%5 of -- #31
//│   O => let x%7 = True() -- #20
//│     in jump j%1(x%7) -- #19
//│   S => let x%8 = x%5.s -- #30
//│     in let* (x%9) = odd(x%8) -- #29
//│       in jump j%1(x%9) -- #28
//│ )
//│ Def(3, j%1, [x%6], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%6 -- #17
//│ )
//│ Def(4, foo, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%10 = O() -- #50
//│   in let x%11 = S(x%10) -- #49
//│     in let x%12 = S(x%11) -- #48
//│       in let x%13 = S(x%12) -- #47
//│         in let* (x%14) = odd(x%13) -- #46
//│           in x%14 -- #45
//│ )
//│ },
//│ let* (x%15) = foo() -- #54
//│   in x%15 -- #53)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0], [{<EDestruct@odd:#15-case x%0 of ...>,<EDirect@odd:#15-case x%0 of ...>,<ESelect(s)@odd:#14-let x%3 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(S))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(1),
//│ 1, 
//│ case x%0 of -- #15
//│   O => let x%2 = False() -- #4
//│     in x%2 -- #55
//│   S => let x%3 = x%0.s -- #14
//│     in let* (x%4) = even(x%3) -- #13
//│       in x%4 -- #56
//│ )
//│ Def(2, even, [x%5], [{<EDestruct@even:#31-case x%5 of ...>,<EDirect@even:#31-case x%5 of ...>,<ESelect(s)@even:#30-let x%8 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(1),
//│ 1, 
//│ case x%5 of -- #31
//│   O => let x%7 = True() -- #20
//│     in x%7 -- #57
//│   S => let x%8 = x%5.s -- #30
//│     in let* (x%9) = odd(x%8) -- #29
//│       in x%9 -- #58
//│ )
//│ Def(4, foo, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let x%10 = O() -- #50
//│   in let x%11 = S(x%10) -- #49
//│     in let x%12 = S(x%11) -- #48
//│       in let x%13 = S(x%12) -- #47
//│         in let* (x%14) = odd(x%13) -- #46
//│           in x%14 -- #45
//│ )
//│ },
//│ let* (x%15) = foo() -- #54
//│   in x%15 -- #53)
//│ 
//│ Interpreted ------------------------------
//│ True()
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0], [{<EDestruct@odd:#62-case x%0 of ...>,<EDirect@odd:#62-case x%0 of ...>,<ESelect(s)@odd:#69-let x%18 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(1),
//│ 1, 
//│ case x%0 of -- #62
//│   O => let x%2 = False() -- #66
//│     in x%2 -- #55
//│   S => let x%18 = x%0.s -- #69
//│     in let* (x%4) = even(x%18) -- #72
//│       in x%4 -- #71
//│ )
//│ Def(2, even, [x%5], [{<EDestruct@even:#31-case x%5 of ...>,<EDirect@even:#31-case x%5 of ...>,<ESelect(s)@even:#30-let x%8 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(S))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(1),
//│ 1, 
//│ case x%5 of -- #31
//│   O => let x%7 = True() -- #20
//│     in x%7 -- #57
//│   S => let x%8 = x%5.s -- #30
//│     in let* (x%9) = odd(x%8) -- #29
//│       in x%9 -- #58
//│ )
//│ Def(4, foo, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let x%10 = O() -- #50
//│   in let x%11 = S(x%10) -- #49
//│     in let x%12 = S(x%11) -- #48
//│       in let* (x%14) = even(x%12) -- #74
//│         in x%14 -- #45
//│ )
//│ },
//│ let* (x%15) = foo() -- #54
//│   in x%15 -- #53)
//│ 
//│ Interpreted ------------------------------
//│ True()
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0], [{<EDestruct@odd:#62-case x%0 of ...>,<EDirect@odd:#62-case x%0 of ...>,<ESelect(s)@odd:#69-let x%18 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(S))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(1),
//│ 1, 
//│ case x%0 of -- #62
//│   O => let x%2 = False() -- #66
//│     in x%2 -- #55
//│   S => let x%18 = x%0.s -- #69
//│     in let* (x%4) = even(x%18) -- #72
//│       in x%4 -- #71
//│ )
//│ Def(2, even, [x%5], [{<EDestruct@even:#79-case x%5 of ...>,<EDirect@even:#79-case x%5 of ...>,<ESelect(s)@even:#86-let x%22 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(1),
//│ 1, 
//│ case x%5 of -- #79
//│   O => let x%7 = True() -- #83
//│     in x%7 -- #57
//│   S => let x%22 = x%5.s -- #86
//│     in let* (x%9) = odd(x%22) -- #89
//│       in x%9 -- #88
//│ )
//│ Def(4, foo, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let x%10 = O() -- #50
//│   in let x%11 = S(x%10) -- #49
//│     in let* (x%14) = odd(x%11) -- #91
//│       in x%14 -- #45
//│ )
//│ },
//│ let* (x%15) = foo() -- #54
//│   in x%15 -- #53)
//│ 
//│ Interpreted ------------------------------
//│ True()
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0], [{<EDestruct@odd:#96-case x%0 of ...>,<EDirect@odd:#96-case x%0 of ...>,<ESelect(s)@odd:#103-let x%26 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(1),
//│ 1, 
//│ case x%0 of -- #96
//│   O => let x%2 = False() -- #100
//│     in x%2 -- #55
//│   S => let x%26 = x%0.s -- #103
//│     in let* (x%4) = even(x%26) -- #106
//│       in x%4 -- #105
//│ )
//│ Def(2, even, [x%5], [{<EDestruct@even:#79-case x%5 of ...>,<EDirect@even:#79-case x%5 of ...>,<ESelect(s)@even:#86-let x%22 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(O))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(1),
//│ 1, 
//│ case x%5 of -- #79
//│   O => let x%7 = True() -- #83
//│     in x%7 -- #57
//│   S => let x%22 = x%5.s -- #86
//│     in let* (x%9) = odd(x%22) -- #89
//│       in x%9 -- #88
//│ )
//│ Def(4, foo, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let x%10 = O() -- #50
//│   in let* (x%14) = even(x%10) -- #108
//│     in x%14 -- #45
//│ )
//│ },
//│ let* (x%15) = foo() -- #54
//│   in x%15 -- #53)
//│ 
//│ Interpreted ------------------------------
//│ True()
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(4, foo, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(ICtor(True))],
//│ Rec: None,
//│ 1, 
//│ let x%7 = True() -- #121
//│   in x%7 -- #45
//│ )
//│ },
//│ let* (x%15) = foo() -- #54
//│   in x%15 -- #53)
//│ 
//│ Interpreted ------------------------------
//│ True()
//│ 
//│ 
//│ Interpreted ------------------------------
//│ True()
//│ 
//│ 
//│ 
//│ Fuel used: 5

:GraphInterp
:GraphOpt
class True
class False
class S(s)
class O
fun odd(x) =
  if x is
    O then False
    S(s) then even(s)
fun even(x) =
  if x is
    O then True
    S(s) then odd(s)
fun mk(n) = if n > 0 then S(mk(n - 1)) else O
fun foo() = odd(mk(10))
foo() 
//│ |#class| |True|↵|#class| |False|↵|#class| |S|(|s|)|↵|#class| |O|↵|#fun| |odd|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |False|↵|S|(|s|)| |#then| |even|(|s|)|←|←|↵|#fun| |even|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |True|↵|S|(|s|)| |#then| |odd|(|s|)|←|←|↵|#fun| |mk|(|n|)| |#=| |#if| |n| |>| |0| |#then| |S|(|mk|(|n| |-| |1|)|)| |#else| |O|↵|#fun| |foo|(||)| |#=| |odd|(|mk|(|10|)|)|↵|foo|(||)| |
//│ Parsed: {class True {}; class False {}; class S(s,) {}; class O {}; fun odd = (x,) => {if x is ‹(O) then False; (S(s,)) then even(s,)›}; fun even = (x,) => {if x is ‹(O) then True; (S(s,)) then odd(s,)›}; fun mk = (n,) => if (>(n,)(0,)) then S(mk(-(n,)(1,),),) else O; fun foo = () => odd(mk(10,),); foo()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x%0 of -- #15
//│   O => let x%2 = False() -- #4
//│     in jump j%0(x%2) -- #3
//│   S => let x%3 = x%0.s -- #14
//│     in let* (x%4) = even(x%3) -- #13
//│       in jump j%0(x%4) -- #12
//│ )
//│ Def(1, j%0, [x%1], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%1 -- #1
//│ )
//│ Def(2, even, [x%5], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x%5 of -- #31
//│   O => let x%7 = True() -- #20
//│     in jump j%1(x%7) -- #19
//│   S => let x%8 = x%5.s -- #30
//│     in let* (x%9) = odd(x%8) -- #29
//│       in jump j%1(x%9) -- #28
//│ )
//│ Def(3, j%1, [x%6], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%6 -- #17
//│ )
//│ Def(4, mk, [n%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%10 = >(n%0,0) -- #54
//│   in if x%10 -- #53
//│     true => let x%12 = -(n%0,1) -- #49
//│       in let* (x%13) = mk(x%12) -- #48
//│         in let x%14 = S(x%13) -- #47
//│           in jump j%2(x%14) -- #46
//│     false => let x%15 = O() -- #52
//│       in jump j%2(x%15) -- #51
//│ )
//│ Def(5, j%2, [x%11], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%11 -- #35
//│ )
//│ Def(6, foo, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%16) = mk(10) -- #65
//│   in let* (x%17) = odd(x%16) -- #64
//│     in x%17 -- #63
//│ )
//│ },
//│ let* (x%18) = foo() -- #69
//│   in x%18 -- #68)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0], [{<EDestruct@odd:#15-case x%0 of ...>,<EDirect@odd:#15-case x%0 of ...>,<ESelect(s)@odd:#14-let x%3 = ...>}],
//│ S: None,
//│ I: [[Some(IMix(ICtor(O),ICtor(S)))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(2),
//│ 1, 
//│ case x%0 of -- #15
//│   O => let x%2 = False() -- #4
//│     in x%2 -- #70
//│   S => let x%3 = x%0.s -- #14
//│     in let* (x%4) = even(x%3) -- #13
//│       in x%4 -- #71
//│ )
//│ Def(2, even, [x%5], [{<EDestruct@even:#31-case x%5 of ...>,<EDirect@even:#31-case x%5 of ...>,<ESelect(s)@even:#30-let x%8 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(2),
//│ 1, 
//│ case x%5 of -- #31
//│   O => let x%7 = True() -- #20
//│     in x%7 -- #72
//│   S => let x%8 = x%5.s -- #30
//│     in let* (x%9) = odd(x%8) -- #29
//│       in x%9 -- #73
//│ )
//│ Def(4, mk, [n%0], [{<EDirect@mk:#49-let x%12 = ...>,<EDirect@mk:#54-let x%10 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(O),ICtor(S)))],
//│ Rec: Some(1),
//│ 1, 
//│ let x%10 = >(n%0,0) -- #54
//│   in if x%10 -- #53
//│     true => let x%12 = -(n%0,1) -- #49
//│       in let* (x%13) = mk(x%12) -- #48
//│         in let x%14 = S(x%13) -- #47
//│           in x%14 -- #74
//│     false => let x%15 = O() -- #52
//│       in x%15 -- #75
//│ )
//│ Def(6, foo, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%16) = mk(10) -- #65
//│   in let* (x%17) = odd(x%16) -- #64
//│     in x%17 -- #63
//│ )
//│ },
//│ let* (x%18) = foo() -- #69
//│   in x%18 -- #68)
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0], [{<EDestruct@odd:#15-case x%0 of ...>,<EDirect@odd:#15-case x%0 of ...>,<ESelect(s)@odd:#14-let x%3 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(O))],[Some(ICtor(S))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(2),
//│ 1, 
//│ case x%0 of -- #15
//│   O => let x%2 = False() -- #4
//│     in x%2 -- #70
//│   S => let x%3 = x%0.s -- #14
//│     in let* (x%4) = even(x%3) -- #13
//│       in x%4 -- #71
//│ )
//│ Def(2, even, [x%5], [{<EDestruct@even:#31-case x%5 of ...>,<EDirect@even:#31-case x%5 of ...>,<ESelect(s)@even:#30-let x%8 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(2),
//│ 1, 
//│ case x%5 of -- #31
//│   O => let x%7 = True() -- #20
//│     in x%7 -- #72
//│   S => let x%8 = x%5.s -- #30
//│     in let* (x%9) = odd(x%8) -- #29
//│       in x%9 -- #73
//│ )
//│ Def(4, mk, [n%0], [{<EDirect@mk:#80-let* (x%19,x%20) = mk$P%0 ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(O),ICtor(S)))],
//│ Rec: Some(1),
//│ 1, 
//│ let* (x%19,x%20) = mk$P%0(n%0) -- #80
//│   in if x%20 -- #79
//│     true => jump mk$D%0(x%19) -- #77
//│     false => let x%15 = O() -- #96
//│       in x%15 -- #75
//│ )
//│ Def(6, foo, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%21,x%22) = mk$P%0(10) -- #86
//│   in if x%22 -- #85
//│     true => let* (x%23) = mk$D%0(x%21) -- #82
//│       in let* (x%17) = odd(x%23) -- #88
//│         in x%17 -- #87
//│     false => let x%15 = O() -- #95
//│       in let* (x%17) = odd(x%15) -- #92
//│         in x%17 -- #91
//│ )
//│ Def(7, mk$P%0, [n%0], [{<EDirect@mk$P%0:#54-let x%10 = ...>,<EDirect@mk$P%0:#76-...>}],
//│ S: None,
//│ I: [],
//│ R: [None,None],
//│ Rec: None,
//│ 2, 
//│ let x%10 = >(n%0,0) -- #54
//│   in n%0,x%10 -- #76
//│ )
//│ Def(8, mk$D%0, [n%0], [{<EDirect@mk$D%0:#49-let x%12 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(ICtor(S))],
//│ Rec: Some(1),
//│ 1, 
//│ let x%12 = -(n%0,1) -- #49
//│   in let* (x%13) = mk(x%12) -- #48
//│     in let x%14 = S(x%13) -- #47
//│       in x%14 -- #74
//│ )
//│ },
//│ let* (x%18) = foo() -- #69
//│   in x%18 -- #68)
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0], [{<EDestruct@odd:#100-case x%0 of ...>,<EDirect@odd:#100-case x%0 of ...>,<ESelect(s)@odd:#113-let x%28 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(2),
//│ 1, 
//│ case x%0 of -- #100
//│   O => let x%2 = False() -- #106
//│     in x%2 -- #70
//│   S => let x%28 = x%0.s -- #113
//│     in let* (x%4) = even(x%28) -- #116
//│       in x%4 -- #115
//│ )
//│ Def(2, even, [x%5], [{<EDestruct@even:#31-case x%5 of ...>,<EDirect@even:#31-case x%5 of ...>,<ESelect(s)@even:#30-let x%8 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(2),
//│ 1, 
//│ case x%5 of -- #31
//│   O => let x%7 = True() -- #20
//│     in x%7 -- #72
//│   S => let x%8 = x%5.s -- #30
//│     in let* (x%9) = odd(x%8) -- #29
//│       in x%9 -- #73
//│ )
//│ Def(4, mk, [n%0], [{<EDirect@mk:#80-let* (x%19,x%20) = mk$P%0 ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(O),ICtor(S)))],
//│ Rec: Some(1),
//│ 1, 
//│ let* (x%19,x%20) = mk$P%0(n%0) -- #80
//│   in if x%20 -- #79
//│     true => jump mk$D%0(x%19) -- #77
//│     false => let x%15 = O() -- #96
//│       in x%15 -- #75
//│ )
//│ Def(6, foo, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%21,x%22) = mk$P%0(10) -- #86
//│   in if x%22 -- #85
//│     true => let* (x%23) = mk$D%0(x%21) -- #82
//│       in let x%29 = x%23.s -- #114
//│         in let* (x%17) = even(x%29) -- #118
//│           in x%17 -- #87
//│     false => let x%2 = False() -- #111
//│       in x%2 -- #91
//│ )
//│ Def(7, mk$P%0, [n%0], [{<EDirect@mk$P%0:#54-let x%10 = ...>,<EDirect@mk$P%0:#76-...>}],
//│ S: None,
//│ I: [],
//│ R: [None,None],
//│ Rec: None,
//│ 2, 
//│ let x%10 = >(n%0,0) -- #54
//│   in n%0,x%10 -- #76
//│ )
//│ Def(8, mk$D%0, [n%0], [{<EDirect@mk$D%0:#49-let x%12 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(ICtor(S))],
//│ Rec: Some(1),
//│ 1, 
//│ let x%12 = -(n%0,1) -- #49
//│   in let* (x%13) = mk(x%12) -- #48
//│     in let x%14 = S(x%13) -- #47
//│       in x%14 -- #74
//│ )
//│ },
//│ let* (x%18) = foo() -- #69
//│   in x%18 -- #68)
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ 
//│ Fuel used: 3

:GraphInterp
:GraphOpt
class True
class False
class S(s)
class O
fun odd(x) =
  if x is
    O then False
    S(s) then even(s)
fun even(x) =
  if x is
    O then True
    S(s) then odd(s)
fun mk(n) = if n > 0 then S(mk(n - 1)) else O
fun foo() = odd(S(S(mk(10))))
foo()
//│ |#class| |True|↵|#class| |False|↵|#class| |S|(|s|)|↵|#class| |O|↵|#fun| |odd|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |False|↵|S|(|s|)| |#then| |even|(|s|)|←|←|↵|#fun| |even|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |True|↵|S|(|s|)| |#then| |odd|(|s|)|←|←|↵|#fun| |mk|(|n|)| |#=| |#if| |n| |>| |0| |#then| |S|(|mk|(|n| |-| |1|)|)| |#else| |O|↵|#fun| |foo|(||)| |#=| |odd|(|S|(|S|(|mk|(|10|)|)|)|)|↵|foo|(||)|
//│ Parsed: {class True {}; class False {}; class S(s,) {}; class O {}; fun odd = (x,) => {if x is ‹(O) then False; (S(s,)) then even(s,)›}; fun even = (x,) => {if x is ‹(O) then True; (S(s,)) then odd(s,)›}; fun mk = (n,) => if (>(n,)(0,)) then S(mk(-(n,)(1,),),) else O; fun foo = () => odd(S(S(mk(10,),),),); foo()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x%0 of -- #15
//│   O => let x%2 = False() -- #4
//│     in jump j%0(x%2) -- #3
//│   S => let x%3 = x%0.s -- #14
//│     in let* (x%4) = even(x%3) -- #13
//│       in jump j%0(x%4) -- #12
//│ )
//│ Def(1, j%0, [x%1], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%1 -- #1
//│ )
//│ Def(2, even, [x%5], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x%5 of -- #31
//│   O => let x%7 = True() -- #20
//│     in jump j%1(x%7) -- #19
//│   S => let x%8 = x%5.s -- #30
//│     in let* (x%9) = odd(x%8) -- #29
//│       in jump j%1(x%9) -- #28
//│ )
//│ Def(3, j%1, [x%6], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%6 -- #17
//│ )
//│ Def(4, mk, [n%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%10 = >(n%0,0) -- #54
//│   in if x%10 -- #53
//│     true => let x%12 = -(n%0,1) -- #49
//│       in let* (x%13) = mk(x%12) -- #48
//│         in let x%14 = S(x%13) -- #47
//│           in jump j%2(x%14) -- #46
//│     false => let x%15 = O() -- #52
//│       in jump j%2(x%15) -- #51
//│ )
//│ Def(5, j%2, [x%11], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%11 -- #35
//│ )
//│ Def(6, foo, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%16) = mk(10) -- #73
//│   in let x%17 = S(x%16) -- #72
//│     in let x%18 = S(x%17) -- #71
//│       in let* (x%19) = odd(x%18) -- #70
//│         in x%19 -- #69
//│ )
//│ },
//│ let* (x%20) = foo() -- #77
//│   in x%20 -- #76)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0], [{<EDestruct@odd:#15-case x%0 of ...>,<EDirect@odd:#15-case x%0 of ...>,<ESelect(s)@odd:#14-let x%3 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(S))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(2),
//│ 1, 
//│ case x%0 of -- #15
//│   O => let x%2 = False() -- #4
//│     in x%2 -- #78
//│   S => let x%3 = x%0.s -- #14
//│     in let* (x%4) = even(x%3) -- #13
//│       in x%4 -- #79
//│ )
//│ Def(2, even, [x%5], [{<EDestruct@even:#31-case x%5 of ...>,<EDirect@even:#31-case x%5 of ...>,<ESelect(s)@even:#30-let x%8 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(2),
//│ 1, 
//│ case x%5 of -- #31
//│   O => let x%7 = True() -- #20
//│     in x%7 -- #80
//│   S => let x%8 = x%5.s -- #30
//│     in let* (x%9) = odd(x%8) -- #29
//│       in x%9 -- #81
//│ )
//│ Def(4, mk, [n%0], [{<EDirect@mk:#49-let x%12 = ...>,<EDirect@mk:#54-let x%10 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(O),ICtor(S)))],
//│ Rec: Some(1),
//│ 1, 
//│ let x%10 = >(n%0,0) -- #54
//│   in if x%10 -- #53
//│     true => let x%12 = -(n%0,1) -- #49
//│       in let* (x%13) = mk(x%12) -- #48
//│         in let x%14 = S(x%13) -- #47
//│           in x%14 -- #82
//│     false => let x%15 = O() -- #52
//│       in x%15 -- #83
//│ )
//│ Def(6, foo, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%16) = mk(10) -- #73
//│   in let x%17 = S(x%16) -- #72
//│     in let x%18 = S(x%17) -- #71
//│       in let* (x%19) = odd(x%18) -- #70
//│         in x%19 -- #69
//│ )
//│ },
//│ let* (x%20) = foo() -- #77
//│   in x%20 -- #76)
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0], [{<EDestruct@odd:#87-case x%0 of ...>,<EDirect@odd:#87-case x%0 of ...>,<ESelect(s)@odd:#94-let x%23 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(2),
//│ 1, 
//│ case x%0 of -- #87
//│   O => let x%2 = False() -- #91
//│     in x%2 -- #78
//│   S => let x%23 = x%0.s -- #94
//│     in let* (x%4) = even(x%23) -- #97
//│       in x%4 -- #96
//│ )
//│ Def(2, even, [x%5], [{<EDestruct@even:#31-case x%5 of ...>,<EDirect@even:#31-case x%5 of ...>,<ESelect(s)@even:#30-let x%8 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(S))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(2),
//│ 1, 
//│ case x%5 of -- #31
//│   O => let x%7 = True() -- #20
//│     in x%7 -- #80
//│   S => let x%8 = x%5.s -- #30
//│     in let* (x%9) = odd(x%8) -- #29
//│       in x%9 -- #81
//│ )
//│ Def(4, mk, [n%0], [{<EDirect@mk:#49-let x%12 = ...>,<EDirect@mk:#54-let x%10 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(O),ICtor(S)))],
//│ Rec: Some(1),
//│ 1, 
//│ let x%10 = >(n%0,0) -- #54
//│   in if x%10 -- #53
//│     true => let x%12 = -(n%0,1) -- #49
//│       in let* (x%13) = mk(x%12) -- #48
//│         in let x%14 = S(x%13) -- #47
//│           in x%14 -- #82
//│     false => let x%15 = O() -- #52
//│       in x%15 -- #83
//│ )
//│ Def(6, foo, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%16) = mk(10) -- #73
//│   in let x%17 = S(x%16) -- #72
//│     in let* (x%19) = even(x%17) -- #99
//│       in x%19 -- #69
//│ )
//│ },
//│ let* (x%20) = foo() -- #77
//│   in x%20 -- #76)
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0], [{<EDestruct@odd:#87-case x%0 of ...>,<EDirect@odd:#87-case x%0 of ...>,<ESelect(s)@odd:#94-let x%23 = ...>}],
//│ S: None,
//│ I: [[Some(IMix(ICtor(O),ICtor(S)))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(2),
//│ 1, 
//│ case x%0 of -- #87
//│   O => let x%2 = False() -- #91
//│     in x%2 -- #78
//│   S => let x%23 = x%0.s -- #94
//│     in let* (x%4) = even(x%23) -- #97
//│       in x%4 -- #96
//│ )
//│ Def(2, even, [x%5], [{<EDestruct@even:#104-case x%5 of ...>,<EDirect@even:#104-case x%5 of ...>,<ESelect(s)@even:#112-let x%28 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(2),
//│ 1, 
//│ case x%5 of -- #104
//│   O => let x%7 = True() -- #109
//│     in x%7 -- #80
//│   S => let x%28 = x%5.s -- #112
//│     in let* (x%9) = odd(x%28) -- #116
//│       in x%9 -- #115
//│ )
//│ Def(4, mk, [n%0], [{<EDirect@mk:#49-let x%12 = ...>,<EDirect@mk:#54-let x%10 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(O),ICtor(S)))],
//│ Rec: Some(1),
//│ 1, 
//│ let x%10 = >(n%0,0) -- #54
//│   in if x%10 -- #53
//│     true => let x%12 = -(n%0,1) -- #49
//│       in let* (x%13) = mk(x%12) -- #48
//│         in let x%14 = S(x%13) -- #47
//│           in x%14 -- #82
//│     false => let x%15 = O() -- #52
//│       in x%15 -- #83
//│ )
//│ Def(6, foo, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%16) = mk(10) -- #73
//│   in let* (x%19) = odd(x%16) -- #113
//│     in x%19 -- #69
//│ )
//│ },
//│ let* (x%20) = foo() -- #77
//│   in x%20 -- #76)
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0], [{<EDestruct@odd:#87-case x%0 of ...>,<EDirect@odd:#87-case x%0 of ...>,<ESelect(s)@odd:#94-let x%23 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(O))],[Some(ICtor(S))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(2),
//│ 1, 
//│ case x%0 of -- #87
//│   O => let x%2 = False() -- #91
//│     in x%2 -- #78
//│   S => let x%23 = x%0.s -- #94
//│     in let* (x%4) = even(x%23) -- #97
//│       in x%4 -- #96
//│ )
//│ Def(2, even, [x%5], [{<EDestruct@even:#104-case x%5 of ...>,<EDirect@even:#104-case x%5 of ...>,<ESelect(s)@even:#112-let x%28 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(2),
//│ 1, 
//│ case x%5 of -- #104
//│   O => let x%7 = True() -- #109
//│     in x%7 -- #80
//│   S => let x%28 = x%5.s -- #112
//│     in let* (x%9) = odd(x%28) -- #116
//│       in x%9 -- #115
//│ )
//│ Def(4, mk, [n%0], [{<EDirect@mk:#122-let* (x%29,x%30) = mk$P%0 ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(O),ICtor(S)))],
//│ Rec: Some(1),
//│ 1, 
//│ let* (x%29,x%30) = mk$P%0(n%0) -- #122
//│   in if x%30 -- #121
//│     true => jump mk$D%0(x%29) -- #119
//│     false => let x%15 = O() -- #138
//│       in x%15 -- #83
//│ )
//│ Def(6, foo, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%31,x%32) = mk$P%0(10) -- #128
//│   in if x%32 -- #127
//│     true => let* (x%33) = mk$D%0(x%31) -- #124
//│       in let* (x%19) = odd(x%33) -- #130
//│         in x%19 -- #129
//│     false => let x%15 = O() -- #137
//│       in let* (x%19) = odd(x%15) -- #134
//│         in x%19 -- #133
//│ )
//│ Def(15, mk$P%0, [n%0], [{<EDirect@mk$P%0:#118-...>,<EDirect@mk$P%0:#54-let x%10 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None,None],
//│ Rec: None,
//│ 2, 
//│ let x%10 = >(n%0,0) -- #54
//│   in n%0,x%10 -- #118
//│ )
//│ Def(16, mk$D%0, [n%0], [{<EDirect@mk$D%0:#49-let x%12 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(ICtor(S))],
//│ Rec: Some(1),
//│ 1, 
//│ let x%12 = -(n%0,1) -- #49
//│   in let* (x%13) = mk(x%12) -- #48
//│     in let x%14 = S(x%13) -- #47
//│       in x%14 -- #82
//│ )
//│ },
//│ let* (x%20) = foo() -- #77
//│   in x%20 -- #76)
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0], [{<EDestruct@odd:#142-case x%0 of ...>,<EDirect@odd:#142-case x%0 of ...>,<ESelect(s)@odd:#155-let x%38 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(2),
//│ 1, 
//│ case x%0 of -- #142
//│   O => let x%2 = False() -- #148
//│     in x%2 -- #78
//│   S => let x%38 = x%0.s -- #155
//│     in let* (x%4) = even(x%38) -- #158
//│       in x%4 -- #157
//│ )
//│ Def(2, even, [x%5], [{<EDestruct@even:#104-case x%5 of ...>,<EDirect@even:#104-case x%5 of ...>,<ESelect(s)@even:#112-let x%28 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(2),
//│ 1, 
//│ case x%5 of -- #104
//│   O => let x%7 = True() -- #109
//│     in x%7 -- #80
//│   S => let x%28 = x%5.s -- #112
//│     in let* (x%9) = odd(x%28) -- #116
//│       in x%9 -- #115
//│ )
//│ Def(4, mk, [n%0], [{<EDirect@mk:#122-let* (x%29,x%30) = mk$P%0 ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(O),ICtor(S)))],
//│ Rec: Some(1),
//│ 1, 
//│ let* (x%29,x%30) = mk$P%0(n%0) -- #122
//│   in if x%30 -- #121
//│     true => jump mk$D%0(x%29) -- #119
//│     false => let x%15 = O() -- #138
//│       in x%15 -- #83
//│ )
//│ Def(6, foo, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%31,x%32) = mk$P%0(10) -- #128
//│   in if x%32 -- #127
//│     true => let* (x%33) = mk$D%0(x%31) -- #124
//│       in let x%39 = x%33.s -- #156
//│         in let* (x%19) = even(x%39) -- #160
//│           in x%19 -- #129
//│     false => let x%2 = False() -- #153
//│       in x%2 -- #133
//│ )
//│ Def(15, mk$P%0, [n%0], [{<EDirect@mk$P%0:#118-...>,<EDirect@mk$P%0:#54-let x%10 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None,None],
//│ Rec: None,
//│ 2, 
//│ let x%10 = >(n%0,0) -- #54
//│   in n%0,x%10 -- #118
//│ )
//│ Def(16, mk$D%0, [n%0], [{<EDirect@mk$D%0:#49-let x%12 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(ICtor(S))],
//│ Rec: Some(1),
//│ 1, 
//│ let x%12 = -(n%0,1) -- #49
//│   in let* (x%13) = mk(x%12) -- #48
//│     in let x%14 = S(x%13) -- #47
//│       in x%14 -- #82
//│ )
//│ },
//│ let* (x%20) = foo() -- #77
//│   in x%20 -- #76)
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ 
//│ Fuel used: 5

:GraphInterp
:GraphOpt
class True
class False
class S(s)
class O
fun odd(x) =
  if x is
    O then False
    S(s) then even(s)
fun even(x) =
  if x is
    O then True
    S(s) then odd(s)
fun foo() = odd(if 10 > 0 then S(O) else O)
fun bar() = if 10 > 0 then odd(S(O)) else odd(O)
fun main() =
  foo()
  bar()
main()
//│ |#class| |True|↵|#class| |False|↵|#class| |S|(|s|)|↵|#class| |O|↵|#fun| |odd|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |False|↵|S|(|s|)| |#then| |even|(|s|)|←|←|↵|#fun| |even|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |True|↵|S|(|s|)| |#then| |odd|(|s|)|←|←|↵|#fun| |foo|(||)| |#=| |odd|(|#if| |10| |>| |0| |#then| |S|(|O|)| |#else| |O|)|↵|#fun| |bar|(||)| |#=| |#if| |10| |>| |0| |#then| |odd|(|S|(|O|)|)| |#else| |odd|(|O|)|↵|#fun| |main|(||)| |#=|→|foo|(||)|↵|bar|(||)|←|↵|main|(||)|
//│ Parsed: {class True {}; class False {}; class S(s,) {}; class O {}; fun odd = (x,) => {if x is ‹(O) then False; (S(s,)) then even(s,)›}; fun even = (x,) => {if x is ‹(O) then True; (S(s,)) then odd(s,)›}; fun foo = () => odd(if (>(10,)(0,)) then S(O,) else O,); fun bar = () => if (>(10,)(0,)) then odd(S(O,),) else odd(O,); fun main = () => {foo(); bar()}; main()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x%0 of -- #15
//│   O => let x%2 = False() -- #4
//│     in jump j%0(x%2) -- #3
//│   S => let x%3 = x%0.s -- #14
//│     in let* (x%4) = even(x%3) -- #13
//│       in jump j%0(x%4) -- #12
//│ )
//│ Def(1, j%0, [x%1], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%1 -- #1
//│ )
//│ Def(2, even, [x%5], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x%5 of -- #31
//│   O => let x%7 = True() -- #20
//│     in jump j%1(x%7) -- #19
//│   S => let x%8 = x%5.s -- #30
//│     in let* (x%9) = odd(x%8) -- #29
//│       in jump j%1(x%9) -- #28
//│ )
//│ Def(3, j%1, [x%6], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%6 -- #17
//│ )
//│ Def(4, foo, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%10 = >(10,0) -- #52
//│   in if x%10 -- #51
//│     true => let x%13 = O() -- #47
//│       in let x%14 = S(x%13) -- #46
//│         in jump j%2(x%14) -- #45
//│     false => let x%15 = O() -- #50
//│       in jump j%2(x%15) -- #49
//│ )
//│ Def(5, j%2, [x%11], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%12) = odd(x%11) -- #40
//│   in x%12 -- #39
//│ )
//│ Def(6, bar, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%16 = >(10,0) -- #78
//│   in if x%16 -- #77
//│     true => let x%18 = O() -- #68
//│       in let x%19 = S(x%18) -- #67
//│         in let* (x%20) = odd(x%19) -- #66
//│           in jump j%3(x%20) -- #65
//│     false => let x%21 = O() -- #76
//│       in let* (x%22) = odd(x%21) -- #75
//│         in jump j%3(x%22) -- #74
//│ )
//│ Def(7, j%3, [x%17], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%17 -- #56
//│ )
//│ Def(8, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%23) = foo() -- #86
//│   in let* (x%24) = bar() -- #85
//│     in x%24 -- #84
//│ )
//│ },
//│ let* (x%25) = main() -- #90
//│   in x%25 -- #89)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0], [{<EDestruct@odd:#15-case x%0 of ...>,<EDirect@odd:#15-case x%0 of ...>,<ESelect(s)@odd:#14-let x%3 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(S))],[Some(ICtor(O))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(2),
//│ 1, 
//│ case x%0 of -- #15
//│   O => let x%2 = False() -- #4
//│     in x%2 -- #91
//│   S => let x%3 = x%0.s -- #14
//│     in let* (x%4) = even(x%3) -- #13
//│       in x%4 -- #92
//│ )
//│ Def(2, even, [x%5], [{<EDestruct@even:#31-case x%5 of ...>,<EDirect@even:#31-case x%5 of ...>,<ESelect(s)@even:#30-let x%8 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(2),
//│ 1, 
//│ case x%5 of -- #31
//│   O => let x%7 = True() -- #20
//│     in x%7 -- #95
//│   S => let x%8 = x%5.s -- #30
//│     in let* (x%9) = odd(x%8) -- #29
//│       in x%9 -- #96
//│ )
//│ Def(6, bar, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let x%16 = >(10,0) -- #78
//│   in if x%16 -- #77
//│     true => let x%18 = O() -- #68
//│       in let x%19 = S(x%18) -- #67
//│         in let* (x%20) = odd(x%19) -- #66
//│           in x%20 -- #93
//│     false => let x%21 = O() -- #76
//│       in let* (x%22) = odd(x%21) -- #75
//│         in x%22 -- #94
//│ )
//│ Def(8, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%24) = bar() -- #85
//│   in x%24 -- #84
//│ )
//│ },
//│ let* (x%25) = main() -- #90
//│   in x%25 -- #89)
//│ 
//│ Interpreted ------------------------------
//│ True()
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0], [{<EDestruct@odd:#106-case x%0 of ...>,<EDirect@odd:#106-case x%0 of ...>,<ESelect(s)@odd:#119-let x%29 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(2),
//│ 1, 
//│ case x%0 of -- #106
//│   O => let x%2 = False() -- #112
//│     in x%2 -- #91
//│   S => let x%29 = x%0.s -- #119
//│     in let* (x%4) = even(x%29) -- #122
//│       in x%4 -- #121
//│ )
//│ Def(2, even, [x%5], [{<EDestruct@even:#31-case x%5 of ...>,<EDirect@even:#31-case x%5 of ...>,<ESelect(s)@even:#30-let x%8 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(O))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(2),
//│ 1, 
//│ case x%5 of -- #31
//│   O => let x%7 = True() -- #20
//│     in x%7 -- #95
//│   S => let x%8 = x%5.s -- #30
//│     in let* (x%9) = odd(x%8) -- #29
//│       in x%9 -- #96
//│ )
//│ Def(6, bar, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let x%16 = >(10,0) -- #78
//│   in if x%16 -- #77
//│     true => let x%18 = O() -- #68
//│       in let* (x%20) = even(x%18) -- #124
//│         in x%20 -- #93
//│     false => let x%2 = False() -- #117
//│       in x%2 -- #94
//│ )
//│ Def(8, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%24) = bar() -- #85
//│   in x%24 -- #84
//│ )
//│ },
//│ let* (x%25) = main() -- #90
//│   in x%25 -- #89)
//│ 
//│ Interpreted ------------------------------
//│ True()
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(6, bar, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let x%16 = >(10,0) -- #78
//│   in if x%16 -- #77
//│     true => let x%7 = True() -- #135
//│       in x%7 -- #93
//│     false => let x%2 = False() -- #117
//│       in x%2 -- #94
//│ )
//│ Def(8, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%24) = bar() -- #85
//│   in x%24 -- #84
//│ )
//│ },
//│ let* (x%25) = main() -- #90
//│   in x%25 -- #89)
//│ 
//│ Interpreted ------------------------------
//│ True()
//│ 
//│ 
//│ Interpreted ------------------------------
//│ True()
//│ 
//│ 
//│ 
//│ Fuel used: 3

:GraphInterp
:GraphOpt
class True
class False
class A()
class B(b)
fun aaa() =
  let m = 1
  let n = 2
  let p = 3
  let q = 4
  m + n - p + q
fun bbb() =
  let x = aaa()
  x * 100 + 4
fun not(x) =
  if x then False else True
fun foo(x) =
  if x then A else B(foo(not(x)))
fun main(flag) =
  let x = foo(flag)
  if x is
    A then aaa()
    B(b1) then bbb()
main(False)
//│ |#class| |True|↵|#class| |False|↵|#class| |A|(||)|↵|#class| |B|(|b|)|↵|#fun| |aaa|(||)| |#=|→|#let| |m| |#=| |1|↵|#let| |n| |#=| |2|↵|#let| |p| |#=| |3|↵|#let| |q| |#=| |4|↵|m| |+| |n| |-| |p| |+| |q|←|↵|#fun| |bbb|(||)| |#=|→|#let| |x| |#=| |aaa|(||)|↵|x| |*| |100| |+| |4|←|↵|#fun| |not|(|x|)| |#=|→|#if| |x| |#then| |False| |#else| |True|←|↵|#fun| |foo|(|x|)| |#=|→|#if| |x| |#then| |A| |#else| |B|(|foo|(|not|(|x|)|)|)|←|↵|#fun| |main|(|flag|)| |#=|→|#let| |x| |#=| |foo|(|flag|)|↵|#if| |x| |is|→|A| |#then| |aaa|(||)|↵|B|(|b1|)| |#then| |bbb|(||)|←|←|↵|main|(|False|)|
//│ Parsed: {class True {}; class False {}; class A() {}; class B(b,) {}; fun aaa = () => {let m = 1; let n = 2; let p = 3; let q = 4; +(-(+(m,)(n,),)(p,),)(q,)}; fun bbb = () => {let x = aaa(); +(*(x,)(100,),)(4,)}; fun not = (x,) => {if (x) then False else True}; fun foo = (x,) => {if (x) then A else B(foo(not(x,),),)}; fun main = (flag,) => {let x = foo(flag,); if x is ‹(A) then aaa(); (B(b1,)) then bbb()›}; main(False,)}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(0, aaa, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%0 = 1 -- #17
//│   in let x%1 = 2 -- #16
//│     in let x%2 = 3 -- #15
//│       in let x%3 = 4 -- #14
//│         in let x%4 = +(x%0,x%1) -- #13
//│           in let x%5 = -(x%4,x%2) -- #12
//│             in let x%6 = +(x%5,x%3) -- #11
//│               in x%6 -- #10
//│ )
//│ Def(1, bbb, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%7) = aaa() -- #28
//│   in let x%8 = *(x%7,100) -- #27
//│     in let x%9 = +(x%8,4) -- #26
//│       in x%9 -- #25
//│ )
//│ Def(2, not, [x%10], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x%10 -- #37
//│   true => let x%12 = False() -- #33
//│     in jump j%0(x%12) -- #32
//│   false => let x%13 = True() -- #36
//│     in jump j%0(x%13) -- #35
//│ )
//│ Def(3, j%0, [x%11], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%11 -- #30
//│ )
//│ Def(4, foo, [x%14], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x%14 -- #59
//│   true => let x%16 = A() -- #42
//│     in jump j%1(x%16) -- #41
//│   false => let* (x%17) = not(x%14) -- #58
//│     in let* (x%18) = foo(x%17) -- #57
//│       in let x%19 = B(x%18) -- #56
//│         in jump j%1(x%19) -- #55
//│ )
//│ Def(5, j%1, [x%15], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%15 -- #39
//│ )
//│ Def(6, main, [flag%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%20) = foo(flag%0) -- #81
//│   in case x%20 of -- #80
//│     A => let* (x%22) = aaa() -- #71
//│       in jump j%2(x%22) -- #70
//│     B => let x%23 = x%20.b -- #79
//│       in let* (x%24) = bbb() -- #78
//│         in jump j%2(x%24) -- #77
//│ )
//│ Def(7, j%2, [x%21], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%21 -- #66
//│ )
//│ },
//│ let x%25 = False() -- #88
//│   in let* (x%26) = main(x%25) -- #87
//│     in x%26 -- #86)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(0, aaa, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%4 = +(1,2) -- #13
//│   in let x%5 = -(x%4,3) -- #12
//│     in let x%6 = +(x%5,4) -- #11
//│       in x%6 -- #10
//│ )
//│ Def(1, bbb, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%7) = aaa() -- #28
//│   in let x%8 = *(x%7,100) -- #27
//│     in let x%9 = +(x%8,4) -- #26
//│       in x%9 -- #25
//│ )
//│ Def(2, not, [x%10], [{<EDestruct@not:#37-if x%10 ...>,<EDirect@not:#37-if x%10 ...>}],
//│ S: None,
//│ I: [[Some(ICtor(False))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ if x%10 -- #37
//│   true => let x%12 = False() -- #33
//│     in x%12 -- #91
//│   false => let x%13 = True() -- #36
//│     in x%13 -- #92
//│ )
//│ Def(4, foo, [x%14], [{<EDestruct@foo:#59-if x%14 ...>,<EDirect@foo:#58-let* (x%17) = not ...>,<EDirect@foo:#59-if x%14 ...>,<EIndirectDestruct@foo:#58-let* (x%17) = not ...>}],
//│ S: None,
//│ I: [[Some(IMix(ICtor(False),ICtor(True)))]],
//│ R: [Some(IMix(ICtor(A),ICtor(B)))],
//│ Rec: Some(1),
//│ 1, 
//│ if x%14 -- #59
//│   true => let x%16 = A() -- #42
//│     in x%16 -- #93
//│   false => let* (x%17) = not(x%14) -- #58
//│     in let* (x%18) = foo(x%17) -- #57
//│       in let x%19 = B(x%18) -- #56
//│         in x%19 -- #94
//│ )
//│ Def(6, main, [flag%0], [{<EDirect@main:#81-let* (x%20) = foo ...>,<EIndirectDestruct@main:#81-let* (x%20) = foo ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%20) = foo(flag%0) -- #81
//│   in case x%20 of -- #80
//│     A => let* (x%22) = aaa() -- #71
//│       in x%22 -- #89
//│     B => let* (x%24) = bbb() -- #78
//│       in x%24 -- #90
//│ )
//│ },
//│ let x%25 = False() -- #88
//│   in let* (x%26) = main(x%25) -- #87
//│     in x%26 -- #86)
//│ 
//│ Interpreted ------------------------------
//│ 404
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(0, aaa, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%4 = +(1,2) -- #13
//│   in let x%5 = -(x%4,3) -- #12
//│     in let x%6 = +(x%5,4) -- #11
//│       in x%6 -- #10
//│ )
//│ Def(1, bbb, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%7) = aaa() -- #28
//│   in let x%8 = *(x%7,100) -- #27
//│     in let x%9 = +(x%8,4) -- #26
//│       in x%9 -- #25
//│ )
//│ Def(4, foo, [x%14], [{<EDestruct@foo:#98-if x%14 ...>,<EDirect@foo:#97-jump foo$D%1 ...>,<EDirect@foo:#98-if x%14 ...>}],
//│ S: None,
//│ I: [[Some(ICtor(True))]],
//│ R: [Some(IMix(ICtor(A),ICtor(B)))],
//│ Rec: Some(3),
//│ 1, 
//│ if x%14 -- #98
//│   true => let x%16 = A() -- #124
//│     in x%16 -- #93
//│   false => jump foo$D%1(x%14) -- #97
//│ )
//│ Def(6, main, [flag%0], [{<EDestruct@main:#111-if flag%0 ...>,<EDirect@main:#110-let* (x%32) = foo$D%1 ...>,<EDirect@main:#111-if flag%0 ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if flag%0 -- #111
//│   true => let x%16 = A() -- #119
//│     in jump main$M%0(x%16) -- #107
//│   false => let* (x%32) = foo$D%1(flag%0) -- #110
//│     in jump main$M%0(x%32) -- #109
//│ )
//│ Def(10, foo$D%1, [x%14], [{}],
//│ S: None,
//│ I: [[Some(ICtor(False))]],
//│ R: [Some(ICtor(B))],
//│ Rec: Some(3),
//│ 1, 
//│ let x%13 = True() -- #115
//│   in let* (x%18) = foo(x%13) -- #57
//│     in let x%19 = B(x%18) -- #56
//│       in x%19 -- #94
//│ )
//│ Def(14, main$M%0, [x%20], [{<EDestruct@main$M%0:#80-case x%20 of ...>,<EDirect@main$M%0:#80-case x%20 of ...>}],
//│ S: None,
//│ I: [[Some(ICtor(A))],[Some(ICtor(B))]],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x%20 of -- #80
//│   A => let* (x%22) = aaa() -- #71
//│     in x%22 -- #89
//│   B => let* (x%24) = bbb() -- #78
//│     in x%24 -- #90
//│ )
//│ },
//│ let x%25 = False() -- #88
//│   in let* (x%26) = main(x%25) -- #87
//│     in x%26 -- #86)
//│ 
//│ Interpreted ------------------------------
//│ 404
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(0, aaa, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%4 = +(1,2) -- #13
//│   in let x%5 = -(x%4,3) -- #12
//│     in let x%6 = +(x%5,4) -- #11
//│       in x%6 -- #10
//│ )
//│ Def(1, bbb, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%7) = aaa() -- #28
//│   in let x%8 = *(x%7,100) -- #27
//│     in let x%9 = +(x%8,4) -- #26
//│       in x%9 -- #25
//│ )
//│ Def(6, main, [flag%0], [{<EDestruct@main:#111-if flag%0 ...>,<EDirect@main:#111-if flag%0 ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if flag%0 -- #111
//│   true => let* (x%22) = aaa() -- #152
//│     in x%22 -- #151
//│   false => let* (x%24) = bbb() -- #155
//│     in x%24 -- #154
//│ )
//│ },
//│ let x%25 = False() -- #88
//│   in let* (x%26) = main(x%25) -- #87
//│     in x%26 -- #86)
//│ 
//│ Interpreted ------------------------------
//│ 404
//│ 
//│ 
//│ Interpreted ------------------------------
//│ 404
//│ 
//│ 
//│ 
//│ Fuel used: 3


:GraphInterp
:GraphOpt
class True
class False
class Cons(h, t)
class Nil
class Some(x)
class None
fun head_opt(l) =
  if l is
    Nil then None
    Cons(h, t) then Some(h)
fun is_none(o) =
  if o is
    None then True
    Some(x) then False
fun is_empty(l) =
  is_none(head_opt(l))
fun main() =
  is_empty(Cons(1, Cons(2, Nil)))
main()
//│ |#class| |True|↵|#class| |False|↵|#class| |Cons|(|h|,| |t|)|↵|#class| |Nil|↵|#class| |Some|(|x|)|↵|#class| |None|↵|#fun| |head_opt|(|l|)| |#=|→|#if| |l| |is|→|Nil| |#then| |None|↵|Cons|(|h|,| |t|)| |#then| |Some|(|h|)|←|←|↵|#fun| |is_none|(|o|)| |#=|→|#if| |o| |is|→|None| |#then| |True|↵|Some|(|x|)| |#then| |False|←|←|↵|#fun| |is_empty|(|l|)| |#=|→|is_none|(|head_opt|(|l|)|)|←|↵|#fun| |main|(||)| |#=|→|is_empty|(|Cons|(|1|,| |Cons|(|2|,| |Nil|)|)|)|←|↵|main|(||)|
//│ Parsed: {class True {}; class False {}; class Cons(h, t,) {}; class Nil {}; class Some(x,) {}; class None {}; fun head_opt = (l,) => {if l is ‹(Nil) then None; (Cons(h, t,)) then Some(h,)›}; fun is_none = (o,) => {if o is ‹(None) then True; (Some(x,)) then False›}; fun is_empty = (l,) => {is_none(head_opt(l,),)}; fun main = () => {is_empty(Cons(1, Cons(2, Nil,),),)}; main()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(0, head_opt, [l%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case l%0 of -- #17
//│   Nil => let x%1 = None() -- #4
//│     in jump j%0(x%1) -- #3
//│   Cons => let x%2 = l%0.t -- #16
//│     in let x%3 = l%0.h -- #15
//│       in let x%4 = Some(x%3) -- #14
//│         in jump j%0(x%4) -- #13
//│ )
//│ Def(1, j%0, [x%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%0 -- #1
//│ )
//│ Def(2, is_none, [o%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case o%0 of -- #29
//│   None => let x%6 = True() -- #22
//│     in jump j%1(x%6) -- #21
//│   Some => let x%7 = o%0.x -- #28
//│     in let x%8 = False() -- #27
//│       in jump j%1(x%8) -- #26
//│ )
//│ Def(3, j%1, [x%5], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%5 -- #19
//│ )
//│ Def(4, is_empty, [l%1], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%9) = head_opt(l%1) -- #40
//│   in let* (x%10) = is_none(x%9) -- #39
//│     in x%10 -- #38
//│ )
//│ Def(5, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%11 = Nil() -- #59
//│   in let x%12 = Cons(2,x%11) -- #58
//│     in let x%13 = Cons(1,x%12) -- #57
//│       in let* (x%14) = is_empty(x%13) -- #56
//│         in x%14 -- #55
//│ )
//│ },
//│ let* (x%15) = main() -- #63
//│   in x%15 -- #62)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(0, head_opt, [l%0], [{<EDestruct@head_opt:#17-case l%0 of ...>,<EDirect@head_opt:#17-case l%0 of ...>,<ESelect(h)@head_opt:#15-let x%3 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(None),ICtor(Some)))],
//│ Rec: None,
//│ 1, 
//│ case l%0 of -- #17
//│   Nil => let x%1 = None() -- #4
//│     in x%1 -- #64
//│   Cons => let x%3 = l%0.h -- #15
//│     in let x%4 = Some(x%3) -- #14
//│       in x%4 -- #65
//│ )
//│ Def(2, is_none, [o%0], [{<EDestruct@is_none:#29-case o%0 of ...>,<EDirect@is_none:#29-case o%0 of ...>}],
//│ S: None,
//│ I: [[Some(IMix(ICtor(None),ICtor(Some)))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ case o%0 of -- #29
//│   None => let x%6 = True() -- #22
//│     in x%6 -- #66
//│   Some => let x%8 = False() -- #27
//│     in x%8 -- #67
//│ )
//│ Def(4, is_empty, [l%1], [{<EDirect@is_empty:#40-let* (x%9) = head_opt ...>,<EIndirectDestruct@is_empty:#40-let* (x%9) = head_opt ...>,<ESelect(h)@head_opt:#15-let x%3 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(Cons))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%9) = head_opt(l%1) -- #40
//│   in let* (x%10) = is_none(x%9) -- #39
//│     in x%10 -- #38
//│ )
//│ Def(5, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let x%11 = Nil() -- #59
//│   in let x%12 = Cons(2,x%11) -- #58
//│     in let x%13 = Cons(1,x%12) -- #57
//│       in let* (x%14) = is_empty(x%13) -- #56
//│         in x%14 -- #55
//│ )
//│ },
//│ let* (x%15) = main() -- #63
//│   in x%15 -- #62)
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(0, head_opt, [l%0], [{<EDestruct@head_opt:#71-case l%0 of ...>,<EDirect@head_opt:#71-case l%0 of ...>,<ESelect(h)@head_opt:#91-let x%21 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(Cons))]],
//│ R: [Some(IMix(ICtor(None),ICtor(Some)))],
//│ Rec: None,
//│ 1, 
//│ case l%0 of -- #71
//│   Nil => let x%1 = None() -- #80
//│     in x%1 -- #64
//│   Cons => let x%21 = l%0.h -- #91
//│     in let x%4 = Some(x%21) -- #92
//│       in x%4 -- #65
//│ )
//│ Def(2, is_none, [o%0], [{<EDestruct@is_none:#29-case o%0 of ...>,<EDirect@is_none:#29-case o%0 of ...>}],
//│ S: None,
//│ I: [[Some(IMix(ICtor(None),ICtor(Some)))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ case o%0 of -- #29
//│   None => let x%6 = True() -- #22
//│     in x%6 -- #66
//│   Some => let x%8 = False() -- #27
//│     in x%8 -- #67
//│ )
//│ Def(5, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let x%11 = Nil() -- #59
//│   in let x%12 = Cons(2,x%11) -- #58
//│     in let x%13 = Cons(1,x%12) -- #57
//│       in let* (x%20) = head_opt(x%13) -- #78
//│         in let* (x%14) = is_none(x%20) -- #82
//│           in x%14 -- #55
//│ )
//│ },
//│ let* (x%15) = main() -- #63
//│   in x%15 -- #62)
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(2, is_none, [o%0], [{<EDestruct@is_none:#29-case o%0 of ...>,<EDirect@is_none:#29-case o%0 of ...>}],
//│ S: None,
//│ I: [[Some(ICtor(Some))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ case o%0 of -- #29
//│   None => let x%6 = True() -- #22
//│     in x%6 -- #66
//│   Some => let x%8 = False() -- #27
//│     in x%8 -- #67
//│ )
//│ Def(5, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let x%4 = Some(1) -- #106
//│   in let* (x%14) = is_none(x%4) -- #82
//│     in x%14 -- #55
//│ )
//│ },
//│ let* (x%15) = main() -- #63
//│   in x%15 -- #62)
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(5, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(ICtor(False))],
//│ Rec: None,
//│ 1, 
//│ let x%8 = False() -- #117
//│   in x%8 -- #55
//│ )
//│ },
//│ let* (x%15) = main() -- #63
//│   in x%15 -- #62)
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ 
//│ Fuel used: 4

:GraphInterp
:GraphOpt
class True
class False
class Cons(h, t)
class Nil
class Some(x)
class None
fun mk_list(n) =
  if n == 0 then Nil else Cons(n, mk_list(n - 1))
fun head_opt(l) =
  if l is
    Nil then None
    Cons(h, t) then Some(h)
fun is_none(o) =
  if o is
    None then True
    Some(x) then False
fun is_empty(l) =
  is_none(head_opt(l))
fun main() =
  is_empty(mk_list(10))
main()
//│ |#class| |True|↵|#class| |False|↵|#class| |Cons|(|h|,| |t|)|↵|#class| |Nil|↵|#class| |Some|(|x|)|↵|#class| |None|↵|#fun| |mk_list|(|n|)| |#=|→|#if| |n| |==| |0| |#then| |Nil| |#else| |Cons|(|n|,| |mk_list|(|n| |-| |1|)|)|←|↵|#fun| |head_opt|(|l|)| |#=|→|#if| |l| |is|→|Nil| |#then| |None|↵|Cons|(|h|,| |t|)| |#then| |Some|(|h|)|←|←|↵|#fun| |is_none|(|o|)| |#=|→|#if| |o| |is|→|None| |#then| |True|↵|Some|(|x|)| |#then| |False|←|←|↵|#fun| |is_empty|(|l|)| |#=|→|is_none|(|head_opt|(|l|)|)|←|↵|#fun| |main|(||)| |#=|→|is_empty|(|mk_list|(|10|)|)|←|↵|main|(||)|
//│ Parsed: {class True {}; class False {}; class Cons(h, t,) {}; class Nil {}; class Some(x,) {}; class None {}; fun mk_list = (n,) => {if (==(n,)(0,)) then Nil else Cons(n, mk_list(-(n,)(1,),),)}; fun head_opt = (l,) => {if l is ‹(Nil) then None; (Cons(h, t,)) then Some(h,)›}; fun is_none = (o,) => {if o is ‹(None) then True; (Some(x,)) then False›}; fun is_empty = (l,) => {is_none(head_opt(l,),)}; fun main = () => {is_empty(mk_list(10,),)}; main()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(0, mk_list, [n%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%0 = ==(n%0,0) -- #24
//│   in if x%0 -- #23
//│     true => let x%2 = Nil() -- #6
//│       in jump j%0(x%2) -- #5
//│     false => let x%3 = -(n%0,1) -- #22
//│       in let* (x%4) = mk_list(x%3) -- #21
//│         in let x%5 = Cons(n%0,x%4) -- #20
//│           in jump j%0(x%5) -- #19
//│ )
//│ Def(1, j%0, [x%1], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%1 -- #3
//│ )
//│ Def(2, head_opt, [l%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case l%0 of -- #42
//│   Nil => let x%7 = None() -- #29
//│     in jump j%1(x%7) -- #28
//│   Cons => let x%8 = l%0.t -- #41
//│     in let x%9 = l%0.h -- #40
//│       in let x%10 = Some(x%9) -- #39
//│         in jump j%1(x%10) -- #38
//│ )
//│ Def(3, j%1, [x%6], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%6 -- #26
//│ )
//│ Def(4, is_none, [o%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case o%0 of -- #54
//│   None => let x%12 = True() -- #47
//│     in jump j%2(x%12) -- #46
//│   Some => let x%13 = o%0.x -- #53
//│     in let x%14 = False() -- #52
//│       in jump j%2(x%14) -- #51
//│ )
//│ Def(5, j%2, [x%11], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%11 -- #44
//│ )
//│ Def(6, is_empty, [l%1], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%15) = head_opt(l%1) -- #65
//│   in let* (x%16) = is_none(x%15) -- #64
//│     in x%16 -- #63
//│ )
//│ Def(7, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%17) = mk_list(10) -- #76
//│   in let* (x%18) = is_empty(x%17) -- #75
//│     in x%18 -- #74
//│ )
//│ },
//│ let* (x%19) = main() -- #80
//│   in x%19 -- #79)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(0, mk_list, [n%0], [{<EDirect@mk_list:#22-let x%3 = ...>,<EDirect@mk_list:#24-let x%0 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(Cons),ICtor(Nil)))],
//│ Rec: Some(4),
//│ 1, 
//│ let x%0 = ==(n%0,0) -- #24
//│   in if x%0 -- #23
//│     true => let x%2 = Nil() -- #6
//│       in x%2 -- #81
//│     false => let x%3 = -(n%0,1) -- #22
//│       in let* (x%4) = mk_list(x%3) -- #21
//│         in let x%5 = Cons(n%0,x%4) -- #20
//│           in x%5 -- #82
//│ )
//│ Def(2, head_opt, [l%0], [{<EDestruct@head_opt:#42-case l%0 of ...>,<EDirect@head_opt:#42-case l%0 of ...>,<ESelect(h)@head_opt:#40-let x%9 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(None),ICtor(Some)))],
//│ Rec: None,
//│ 1, 
//│ case l%0 of -- #42
//│   Nil => let x%7 = None() -- #29
//│     in x%7 -- #83
//│   Cons => let x%9 = l%0.h -- #40
//│     in let x%10 = Some(x%9) -- #39
//│       in x%10 -- #84
//│ )
//│ Def(4, is_none, [o%0], [{<EDestruct@is_none:#54-case o%0 of ...>,<EDirect@is_none:#54-case o%0 of ...>}],
//│ S: None,
//│ I: [[Some(IMix(ICtor(None),ICtor(Some)))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ case o%0 of -- #54
//│   None => let x%12 = True() -- #47
//│     in x%12 -- #85
//│   Some => let x%14 = False() -- #52
//│     in x%14 -- #86
//│ )
//│ Def(6, is_empty, [l%1], [{<EDirect@is_empty:#65-let* (x%15) = head_opt ...>,<EIndirectDestruct@is_empty:#65-let* (x%15) = head_opt ...>,<ESelect(h)@head_opt:#40-let x%9 = ...>}],
//│ S: None,
//│ I: [[Some(IMix(ICtor(Cons),ICtor(Nil)))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%15) = head_opt(l%1) -- #65
//│   in let* (x%16) = is_none(x%15) -- #64
//│     in x%16 -- #63
//│ )
//│ Def(7, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%17) = mk_list(10) -- #76
//│   in let* (x%18) = is_empty(x%17) -- #75
//│     in x%18 -- #74
//│ )
//│ },
//│ let* (x%19) = main() -- #80
//│   in x%19 -- #79)
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(0, mk_list, [n%0], [{<EDirect@mk_list:#91-let* (x%20,x%21) = mk_list$P%0 ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(Cons),ICtor(Nil)))],
//│ Rec: Some(3),
//│ 1, 
//│ let* (x%20,x%21) = mk_list$P%0(n%0) -- #91
//│   in if x%21 -- #90
//│     true => let x%2 = Nil() -- #109
//│       in x%2 -- #81
//│     false => jump mk_list$D%1(x%20) -- #89
//│ )
//│ Def(4, is_none, [o%0], [{<EDestruct@is_none:#54-case o%0 of ...>,<EDirect@is_none:#54-case o%0 of ...>}],
//│ S: None,
//│ I: [[Some(ICtor(Some))],[Some(ICtor(None))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ case o%0 of -- #54
//│   None => let x%12 = True() -- #47
//│     in x%12 -- #85
//│   Some => let x%14 = False() -- #52
//│     in x%14 -- #86
//│ )
//│ Def(6, is_empty, [l%1], [{<EDestruct@is_empty:#101-case l%1 of ...>,<EDirect@is_empty:#101-case l%1 of ...>,<ESelect(h)@is_empty:#131-let x%30 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(Nil))],[Some(ICtor(Cons))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ case l%1 of -- #101
//│   Cons => let x%30 = l%1.h -- #131
//│     in let x%10 = Some(x%30) -- #134
//│       in let* (x%16) = is_none(x%10) -- #111
//│         in x%16 -- #110
//│   Nil => let x%7 = None() -- #118
//│     in let* (x%16) = is_none(x%7) -- #115
//│       in x%16 -- #114
//│ )
//│ Def(7, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%26,x%27) = mk_list$P%0(10) -- #108
//│   in if x%27 -- #107
//│     true => let x%2 = Nil() -- #127
//│       in let* (x%18) = is_empty(x%2) -- #124
//│         in x%18 -- #123
//│     false => let* (x%29) = mk_list$D%1(x%26) -- #106
//│       in let* (x%18) = is_empty(x%29) -- #129
//│         in x%18 -- #128
//│ )
//│ Def(8, mk_list$P%0, [n%0], [{<EDirect@mk_list$P%0:#24-let x%0 = ...>,<EDirect@mk_list$P%0:#87-...>}],
//│ S: None,
//│ I: [],
//│ R: [None,None],
//│ Rec: None,
//│ 2, 
//│ let x%0 = ==(n%0,0) -- #24
//│   in n%0,x%0 -- #87
//│ )
//│ Def(10, mk_list$D%1, [n%0], [{<EDirect@mk_list$D%1:#22-let x%3 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(ICtor(Cons))],
//│ Rec: Some(3),
//│ 1, 
//│ let x%3 = -(n%0,1) -- #22
//│   in let* (x%4) = mk_list(x%3) -- #21
//│     in let x%5 = Cons(n%0,x%4) -- #20
//│       in x%5 -- #82
//│ )
//│ },
//│ let* (x%19) = main() -- #80
//│   in x%19 -- #79)
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(7, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%26,x%27) = mk_list$P%0(10) -- #108
//│   in if x%27 -- #107
//│     true => let x%12 = True() -- #169
//│       in x%12 -- #123
//│     false => let x%14 = False() -- #172
//│       in x%14 -- #128
//│ )
//│ Def(8, mk_list$P%0, [n%0], [{<EDirect@mk_list$P%0:#24-let x%0 = ...>,<EDirect@mk_list$P%0:#87-...>}],
//│ S: None,
//│ I: [],
//│ R: [None,None],
//│ Rec: None,
//│ 2, 
//│ let x%0 = ==(n%0,0) -- #24
//│   in n%0,x%0 -- #87
//│ )
//│ },
//│ let* (x%19) = main() -- #80
//│   in x%19 -- #79)
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ 
//│ Fuel used: 3

:GraphInterp
:GraphOpt
class True
class False
class Cons(h, t)
class Nil
class Some(x)
class None
fun mk_list(n) =
  if n == 0 then Nil else Cons(n, mk_list(n - 1))
fun last_opt(l) =
  if l is
    Nil then None
    Cons(h, t) then
      if t is
        Nil then Some(h)
        Cons(h2, t2) then last_opt(t)
fun main() =
  last_opt(mk_list(10))
main()
//│ |#class| |True|↵|#class| |False|↵|#class| |Cons|(|h|,| |t|)|↵|#class| |Nil|↵|#class| |Some|(|x|)|↵|#class| |None|↵|#fun| |mk_list|(|n|)| |#=|→|#if| |n| |==| |0| |#then| |Nil| |#else| |Cons|(|n|,| |mk_list|(|n| |-| |1|)|)|←|↵|#fun| |last_opt|(|l|)| |#=|→|#if| |l| |is|→|Nil| |#then| |None|↵|Cons|(|h|,| |t|)| |#then|→|#if| |t| |is|→|Nil| |#then| |Some|(|h|)|↵|Cons|(|h2|,| |t2|)| |#then| |last_opt|(|t|)|←|←|←|←|↵|#fun| |main|(||)| |#=|→|last_opt|(|mk_list|(|10|)|)|←|↵|main|(||)|
//│ Parsed: {class True {}; class False {}; class Cons(h, t,) {}; class Nil {}; class Some(x,) {}; class None {}; fun mk_list = (n,) => {if (==(n,)(0,)) then Nil else Cons(n, mk_list(-(n,)(1,),),)}; fun last_opt = (l,) => {if l is ‹(Nil) then None; (Cons(h, t,)) then {if t is ‹(Nil) then Some(h,); (Cons(h2, t2,)) then last_opt(t,)›}›}; fun main = () => {last_opt(mk_list(10,),)}; main()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(0, mk_list, [n%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%0 = ==(n%0,0) -- #24
//│   in if x%0 -- #23
//│     true => let x%2 = Nil() -- #6
//│       in jump j%0(x%2) -- #5
//│     false => let x%3 = -(n%0,1) -- #22
//│       in let* (x%4) = mk_list(x%3) -- #21
//│         in let x%5 = Cons(n%0,x%4) -- #20
//│           in jump j%0(x%5) -- #19
//│ )
//│ Def(1, j%0, [x%1], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%1 -- #3
//│ )
//│ Def(2, last_opt, [l%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case l%0 of -- #59
//│   Nil => let x%7 = None() -- #29
//│     in jump j%1(x%7) -- #28
//│   Cons => let x%8 = l%0.t -- #58
//│     in let x%9 = l%0.h -- #57
//│       in case x%8 of -- #56
//│         Nil => let x%11 = Some(x%9) -- #42
//│           in jump j%2(x%11) -- #41
//│         Cons => let x%12 = x%8.t -- #55
//│           in let x%13 = x%8.h -- #54
//│             in let* (x%14) = last_opt(x%8) -- #53
//│               in jump j%2(x%14) -- #52
//│ )
//│ Def(3, j%1, [x%6], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%6 -- #26
//│ )
//│ Def(4, j%2, [x%10], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j%1(x%10) -- #36
//│ )
//│ Def(5, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%15) = mk_list(10) -- #70
//│   in let* (x%16) = last_opt(x%15) -- #69
//│     in x%16 -- #68
//│ )
//│ },
//│ let* (x%17) = main() -- #74
//│   in x%17 -- #73)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(0, mk_list, [n%0], [{<EDirect@mk_list:#22-let x%3 = ...>,<EDirect@mk_list:#24-let x%0 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(Cons),ICtor(Nil)))],
//│ Rec: Some(1),
//│ 1, 
//│ let x%0 = ==(n%0,0) -- #24
//│   in if x%0 -- #23
//│     true => let x%2 = Nil() -- #6
//│       in x%2 -- #75
//│     false => let x%3 = -(n%0,1) -- #22
//│       in let* (x%4) = mk_list(x%3) -- #21
//│         in let x%5 = Cons(n%0,x%4) -- #20
//│           in x%5 -- #76
//│ )
//│ Def(2, last_opt, [l%0], [{<EDestruct@last_opt:#59-case l%0 of ...>,<EDirect@last_opt:#59-case l%0 of ...>,<ESelect(h)@last_opt:#57-let x%9 = ...>,<ESelect(t)@last_opt:#58-let x%8 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(Cons))],[Some(IMix(ICtor(Cons),ICtor(Nil)))]],
//│ R: [Some(IMix(ICtor(None),ICtor(Some)))],
//│ Rec: Some(2),
//│ 1, 
//│ case l%0 of -- #59
//│   Nil => let x%7 = None() -- #29
//│     in x%7 -- #77
//│   Cons => let x%8 = l%0.t -- #58
//│     in let x%9 = l%0.h -- #57
//│       in case x%8 of -- #56
//│         Nil => let x%11 = Some(x%9) -- #42
//│           in x%11 -- #83
//│         Cons => let* (x%14) = last_opt(x%8) -- #53
//│           in x%14 -- #84
//│ )
//│ Def(5, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(None),ICtor(Some)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%15) = mk_list(10) -- #70
//│   in let* (x%16) = last_opt(x%15) -- #69
//│     in x%16 -- #68
//│ )
//│ },
//│ let* (x%17) = main() -- #74
//│   in x%17 -- #73)
//│ 
//│ Interpreted ------------------------------
//│ Some(1)
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(0, mk_list, [n%0], [{<EDirect@mk_list:#89-let* (x%18,x%19) = mk_list$P%0 ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(Cons),ICtor(Nil)))],
//│ Rec: Some(1),
//│ 1, 
//│ let* (x%18,x%19) = mk_list$P%0(n%0) -- #89
//│   in if x%19 -- #88
//│     true => let x%2 = Nil() -- #103
//│       in x%2 -- #75
//│     false => jump mk_list$D%1(x%18) -- #87
//│ )
//│ Def(2, last_opt, [l%0], [{<EDestruct@last_opt:#93-case l%0 of ...>,<EDirect@last_opt:#93-case l%0 of ...>,<ESelect(h)@last_opt:#119-let x%28 = ...>,<ESelect(t)@last_opt:#118-let x%29 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(Nil))],[Some(ICtor(Cons))]],
//│ R: [Some(IMix(ICtor(None),ICtor(Some)))],
//│ Rec: None,
//│ 1, 
//│ case l%0 of -- #93
//│   Nil => let x%7 = None() -- #113
//│     in x%7 -- #77
//│   Cons => let x%28 = l%0.h -- #119
//│     in let x%29 = l%0.t -- #118
//│       in jump last_opt$D%1$S%0(x%28,x%29) -- #92
//│ )
//│ Def(5, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(None),ICtor(Some)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%21,x%22) = mk_list$P%0(10) -- #100
//│   in if x%22 -- #99
//│     true => let x%2 = Nil() -- #109
//│       in let* (x%16) = last_opt(x%2) -- #106
//│         in x%16 -- #105
//│     false => let* (x%24) = mk_list$D%1(x%21) -- #98
//│       in let* (x%16) = last_opt(x%24) -- #111
//│         in x%16 -- #110
//│ )
//│ Def(6, mk_list$P%0, [n%0], [{<EDirect@mk_list$P%0:#24-let x%0 = ...>,<EDirect@mk_list$P%0:#85-...>}],
//│ S: None,
//│ I: [],
//│ R: [None,None],
//│ Rec: None,
//│ 2, 
//│ let x%0 = ==(n%0,0) -- #24
//│   in n%0,x%0 -- #85
//│ )
//│ Def(8, mk_list$D%1, [n%0], [{<EDirect@mk_list$D%1:#22-let x%3 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(ICtor(Cons))],
//│ Rec: Some(1),
//│ 1, 
//│ let x%3 = -(n%0,1) -- #22
//│   in let* (x%4) = mk_list(x%3) -- #21
//│     in let x%5 = Cons(n%0,x%4) -- #20
//│       in x%5 -- #76
//│ )
//│ Def(13, last_opt$D%1$S%0, [l%0_h,l%0_t], [{<EDirect@last_opt$D%1$S%0:#42-let x%11 = ...>},{<EDestruct@last_opt$D%1$S%0:#56-case l%0_t of ...>,<EDirect@last_opt$D%1$S%0:#56-case l%0_t of ...>,<ESelect(h)@last_opt$D%1$S%0:#117-let x%26 = ...>,<ESelect(t)@last_opt$D%1$S%0:#116-let x%27 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(Some)))],
//│ Rec: Some(3),
//│ 1, 
//│ case l%0_t of -- #56
//│   Nil => let x%11 = Some(l%0_h) -- #42
//│     in x%11 -- #83
//│   Cons => let x%26 = l%0_t.h -- #117
//│     in let x%27 = l%0_t.t -- #116
//│       in let* (x%14) = last_opt$D%1$S%0(x%26,x%27) -- #101
//│         in x%14 -- #84
//│ )
//│ },
//│ let* (x%17) = main() -- #74
//│   in x%17 -- #73)
//│ 
//│ Interpreted ------------------------------
//│ Some(1)
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(0, mk_list, [n%0], [{<EDirect@mk_list:#89-let* (x%18,x%19) = mk_list$P%0 ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(Cons),ICtor(Nil)))],
//│ Rec: Some(1),
//│ 1, 
//│ let* (x%18,x%19) = mk_list$P%0(n%0) -- #89
//│   in if x%19 -- #88
//│     true => let x%2 = Nil() -- #103
//│       in x%2 -- #75
//│     false => jump mk_list$D%1(x%18) -- #87
//│ )
//│ Def(5, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(None),ICtor(Some)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%21,x%22) = mk_list$P%0(10) -- #100
//│   in if x%22 -- #99
//│     true => let x%7 = None() -- #133
//│       in x%7 -- #105
//│     false => let* (x%24) = mk_list$D%1(x%21) -- #98
//│       in let x%35 = x%24.h -- #139
//│         in let x%36 = x%24.t -- #138
//│           in let* (x%16) = last_opt$D%1$S%0(x%35,x%36) -- #140
//│             in x%16 -- #110
//│ )
//│ Def(6, mk_list$P%0, [n%0], [{<EDirect@mk_list$P%0:#24-let x%0 = ...>,<EDirect@mk_list$P%0:#85-...>}],
//│ S: None,
//│ I: [],
//│ R: [None,None],
//│ Rec: None,
//│ 2, 
//│ let x%0 = ==(n%0,0) -- #24
//│   in n%0,x%0 -- #85
//│ )
//│ Def(8, mk_list$D%1, [n%0], [{<EDirect@mk_list$D%1:#22-let x%3 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(ICtor(Cons))],
//│ Rec: Some(1),
//│ 1, 
//│ let x%3 = -(n%0,1) -- #22
//│   in let* (x%4) = mk_list(x%3) -- #21
//│     in let x%5 = Cons(n%0,x%4) -- #20
//│       in x%5 -- #76
//│ )
//│ Def(13, last_opt$D%1$S%0, [l%0_h,l%0_t], [{<EDirect@last_opt$D%1$S%0:#42-let x%11 = ...>},{<EDestruct@last_opt$D%1$S%0:#56-case l%0_t of ...>,<EDirect@last_opt$D%1$S%0:#56-case l%0_t of ...>,<ESelect(h)@last_opt$D%1$S%0:#117-let x%26 = ...>,<ESelect(t)@last_opt$D%1$S%0:#116-let x%27 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(Some)))],
//│ Rec: Some(2),
//│ 1, 
//│ case l%0_t of -- #56
//│   Nil => let x%11 = Some(l%0_h) -- #42
//│     in x%11 -- #83
//│   Cons => let x%26 = l%0_t.h -- #117
//│     in let x%27 = l%0_t.t -- #116
//│       in let* (x%14) = last_opt$D%1$S%0(x%26,x%27) -- #101
//│         in x%14 -- #84
//│ )
//│ },
//│ let* (x%17) = main() -- #74
//│   in x%17 -- #73)
//│ 
//│ Interpreted ------------------------------
//│ Some(1)
//│ 
//│ 
//│ Interpreted ------------------------------
//│ Some(1)
//│ 
//│ 
//│ 
//│ Fuel used: 3

:GraphInterp
:GraphOptVerbose
class True
class False
class Cons(h, t)
class Nil
class Some(x)
class None
fun is_some(o) =
  if o is
    Some(x) then True
    None then False
fun e0(w) =
  w + 8 + 9 + 10
fun e1(a, c) =
  a + 1 + 2 + 3 + 4
fun e3(c) =
  let m = 4
  let n = 5
  let p = 6
  let q = 7
  if c then m + n + p + q else m + n - p + q // 4 + 5 + 6 + 7 = 22; 4 + 5 - 6 + 7 = 10 
fun e2(x) =
  x + 12 + 13 + 14
fun f(x) =
  let c1 = is_some(x)
  let z = e3(c1)
  let w = if x is
    Some(a) then e1(a, z)
    None then e2(z)
  e0(w)
fun main() =
  f(Some(2)) + f(None)
main()
//│ |#class| |True|↵|#class| |False|↵|#class| |Cons|(|h|,| |t|)|↵|#class| |Nil|↵|#class| |Some|(|x|)|↵|#class| |None|↵|#fun| |is_some|(|o|)| |#=|→|#if| |o| |is|→|Some|(|x|)| |#then| |True|↵|None| |#then| |False|←|←|↵|#fun| |e0|(|w|)| |#=|→|w| |+| |8| |+| |9| |+| |10|←|↵|#fun| |e1|(|a|,| |c|)| |#=|→|a| |+| |1| |+| |2| |+| |3| |+| |4|←|↵|#fun| |e3|(|c|)| |#=|→|#let| |m| |#=| |4|↵|#let| |n| |#=| |5|↵|#let| |p| |#=| |6|↵|#let| |q| |#=| |7|↵|#if| |c| |#then| |m| |+| |n| |+| |p| |+| |q| |#else| |m| |+| |n| |-| |p| |+| |q| |/* 4 + 5 + 6 + 7 = 22; 4 + 5 - 6 + 7 = 10 */|←|↵|#fun| |e2|(|x|)| |#=|→|x| |+| |12| |+| |13| |+| |14|←|↵|#fun| |f|(|x|)| |#=|→|#let| |c1| |#=| |is_some|(|x|)|↵|#let| |z| |#=| |e3|(|c1|)|↵|#let| |w| |#=| |#if| |x| |is|→|Some|(|a|)| |#then| |e1|(|a|,| |z|)|↵|None| |#then| |e2|(|z|)|←|↵|e0|(|w|)|←|↵|#fun| |main|(||)| |#=|→|f|(|Some|(|2|)|)| |+| |f|(|None|)|←|↵|main|(||)|
//│ Parsed: {class True {}; class False {}; class Cons(h, t,) {}; class Nil {}; class Some(x,) {}; class None {}; fun is_some = (o,) => {if o is ‹(Some(x,)) then True; (None) then False›}; fun e0 = (w,) => {+(+(+(w,)(8,),)(9,),)(10,)}; fun e1 = (a, c,) => {+(+(+(+(a,)(1,),)(2,),)(3,),)(4,)}; fun e3 = (c,) => {let m = 4; let n = 5; let p = 6; let q = 7; if (c) then +(+(+(m,)(n,),)(p,),)(q,) else +(-(+(m,)(n,),)(p,),)(q,)}; fun e2 = (x,) => {+(+(+(x,)(12,),)(13,),)(14,)}; fun f = (x,) => {let c1 = is_some(x,); let z = e3(c1,); let w = if x is ‹(Some(a,)) then e1(a, z,); (None) then e2(z,)›; e0(w,)}; fun main = () => {+(f(Some(2,),),)(f(None,),)}; main()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(0, is_some, [o%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case o%0 of -- #11
//│   Some => let x%1 = o%0.x -- #7
//│     in let x%2 = True() -- #6
//│       in jump j%0(x%2) -- #5
//│   None => let x%3 = False() -- #10
//│     in jump j%0(x%3) -- #9
//│ )
//│ Def(1, j%0, [x%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%0 -- #1
//│ )
//│ Def(2, e0, [w%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%4 = +(w%0,8) -- #21
//│   in let x%5 = +(x%4,9) -- #20
//│     in let x%6 = +(x%5,10) -- #19
//│       in x%6 -- #18
//│ )
//│ Def(3, e1, [a%0,c%0], [{},{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%7 = +(a%0,1) -- #34
//│   in let x%8 = +(x%7,2) -- #33
//│     in let x%9 = +(x%8,3) -- #32
//│       in let x%10 = +(x%9,4) -- #31
//│         in x%10 -- #30
//│ )
//│ Def(4, e3, [c%1], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%11 = 4 -- #67
//│   in let x%12 = 5 -- #66
//│     in let x%13 = 6 -- #65
//│       in let x%14 = 7 -- #64
//│         in if c%1 -- #63
//│           true => let x%16 = +(x%11,x%12) -- #51
//│             in let x%17 = +(x%16,x%13) -- #50
//│               in let x%18 = +(x%17,x%14) -- #49
//│                 in jump j%1(x%18) -- #48
//│           false => let x%19 = +(x%11,x%12) -- #62
//│             in let x%20 = -(x%19,x%13) -- #61
//│               in let x%21 = +(x%20,x%14) -- #60
//│                 in jump j%1(x%21) -- #59
//│ )
//│ Def(5, j%1, [x%15], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%15 -- #40
//│ )
//│ Def(6, e2, [x%22], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%23 = +(x%22,12) -- #77
//│   in let x%24 = +(x%23,13) -- #76
//│     in let x%25 = +(x%24,14) -- #75
//│       in x%25 -- #74
//│ )
//│ Def(7, f, [x%26], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%27) = is_some(x%26) -- #117
//│   in let* (x%28) = e3(x%27) -- #116
//│     in case x%26 of -- #115
//│       Some => let x%31 = x%26.x -- #107
//│         in let* (x%32) = e1(x%31,x%28) -- #106
//│           in jump j%2(x%32) -- #105
//│       None => let* (x%33) = e2(x%28) -- #114
//│         in jump j%2(x%33) -- #113
//│ )
//│ Def(8, j%2, [x%29], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%30) = e0(x%29) -- #95
//│   in x%30 -- #94
//│ )
//│ Def(9, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%34 = Some(2) -- #136
//│   in let* (x%35) = f(x%34) -- #135
//│     in let x%36 = None() -- #134
//│       in let* (x%37) = f(x%36) -- #133
//│         in let x%38 = +(x%35,x%37) -- #132
//│           in x%38 -- #131
//│ )
//│ },
//│ let* (x%39) = main() -- #140
//│   in x%39 -- #139)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(0, is_some, [o%0], [{<EDestruct@is_some:#11-case o%0 of ...>,<EDirect@is_some:#11-case o%0 of ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ case o%0 of -- #11
//│   Some => let x%2 = True() -- #6
//│     in x%2 -- #141
//│   None => let x%3 = False() -- #10
//│     in x%3 -- #142
//│ )
//│ Def(2, e0, [w%0], [{<EDirect@e0:#21-let x%4 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%4 = +(w%0,8) -- #21
//│   in let x%5 = +(x%4,9) -- #20
//│     in let x%6 = +(x%5,10) -- #19
//│       in x%6 -- #18
//│ )
//│ Def(3, e1, [a%0,c%0], [{<EDirect@e1:#34-let x%7 = ...>},{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%7 = +(a%0,1) -- #34
//│   in let x%8 = +(x%7,2) -- #33
//│     in let x%9 = +(x%8,3) -- #32
//│       in let x%10 = +(x%9,4) -- #31
//│         in x%10 -- #30
//│ )
//│ Def(4, e3, [c%1], [{<EDestruct@e3:#63-if c%1 ...>,<EDirect@e3:#63-if c%1 ...>}],
//│ S: None,
//│ I: [[Some(IMix(ICtor(False),ICtor(True)))]],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if c%1 -- #63
//│   true => let x%16 = +(4,5) -- #51
//│     in let x%17 = +(x%16,6) -- #50
//│       in let x%18 = +(x%17,7) -- #49
//│         in x%18 -- #149
//│   false => let x%19 = +(4,5) -- #62
//│     in let x%20 = -(x%19,6) -- #61
//│       in let x%21 = +(x%20,7) -- #60
//│         in x%21 -- #150
//│ )
//│ Def(6, e2, [x%22], [{<EDirect@e2:#77-let x%23 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%23 = +(x%22,12) -- #77
//│   in let x%24 = +(x%23,13) -- #76
//│     in let x%25 = +(x%24,14) -- #75
//│       in x%25 -- #74
//│ )
//│ Def(7, f, [x%26], [{<EDestruct@f:#115-case x%26 of ...>,<EDirect@f:#115-case x%26 of ...>,<EDirect@f:#117-let* (x%27) = is_some ...>,<EIndirectDestruct@f:#117-let* (x%27) = is_some ...>,<ESelect(x)@f:#107-let x%31 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(Some))],[Some(ICtor(None))]],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%27) = is_some(x%26) -- #117
//│   in let* (x%28) = e3(x%27) -- #116
//│     in case x%26 of -- #115
//│       Some => let x%31 = x%26.x -- #107
//│         in let* (x%32) = e1(x%31,x%28) -- #106
//│           in let* (x%30) = e0(x%32) -- #144
//│             in x%30 -- #143
//│       None => let* (x%33) = e2(x%28) -- #114
//│         in let* (x%30) = e0(x%33) -- #147
//│           in x%30 -- #146
//│ )
//│ Def(9, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%34 = Some(2) -- #136
//│   in let* (x%35) = f(x%34) -- #135
//│     in let x%36 = None() -- #134
//│       in let* (x%37) = f(x%36) -- #133
//│         in let x%38 = +(x%35,x%37) -- #132
//│           in x%38 -- #131
//│ )
//│ },
//│ let* (x%39) = main() -- #140
//│   in x%39 -- #139)
//│ 
//│ Interpreted ------------------------------
//│ 115
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(2, e0, [w%0], [{<EDirect@e0:#21-let x%4 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%4 = +(w%0,8) -- #21
//│   in let x%5 = +(x%4,9) -- #20
//│     in let x%6 = +(x%5,10) -- #19
//│       in x%6 -- #18
//│ )
//│ Def(3, e1, [a%0,c%0], [{<EDirect@e1:#34-let x%7 = ...>},{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%7 = +(a%0,1) -- #34
//│   in let x%8 = +(x%7,2) -- #33
//│     in let x%9 = +(x%8,3) -- #32
//│       in let x%10 = +(x%9,4) -- #31
//│         in x%10 -- #30
//│ )
//│ Def(4, e3, [c%1], [{<EDestruct@e3:#63-if c%1 ...>,<EDirect@e3:#63-if c%1 ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if c%1 -- #63
//│   true => let x%16 = +(4,5) -- #51
//│     in let x%17 = +(x%16,6) -- #50
//│       in let x%18 = +(x%17,7) -- #49
//│         in x%18 -- #149
//│   false => let x%19 = +(4,5) -- #62
//│     in let x%20 = -(x%19,6) -- #61
//│       in let x%21 = +(x%20,7) -- #60
//│         in x%21 -- #150
//│ )
//│ Def(6, e2, [x%22], [{<EDirect@e2:#77-let x%23 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%23 = +(x%22,12) -- #77
//│   in let x%24 = +(x%23,13) -- #76
//│     in let x%25 = +(x%24,14) -- #75
//│       in x%25 -- #74
//│ )
//│ Def(9, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%34 = Some(2) -- #136
//│   in let* (x%43,x%44) = f$P%0(x%34) -- #162
//│     in let* (x%35) = f$D%0(x%43,x%44) -- #161
//│       in let x%36 = None() -- #134
//│         in let* (x%48,x%49) = f$P%0(x%36) -- #170
//│           in let* (x%37) = f$D%1(x%49) -- #169
//│             in let x%38 = +(x%35,x%37) -- #132
//│               in x%38 -- #131
//│ )
//│ Def(13, f$P%0, [x%26], [{<EDestruct@f$P%0:#167-case x%26 of ...>,<EDirect@f$P%0:#163-jump f$P%0$M%0 ...>,<EDirect@f$P%0:#167-case x%26 of ...>}],
//│ S: None,
//│ I: [[Some(ICtor(Some))],[Some(ICtor(None))]],
//│ R: [None,None],
//│ Rec: None,
//│ 2, 
//│ case x%26 of -- #167
//│   Some => let x%2 = True() -- #176
//│     in jump f$P%0$M%0(x%2,x%26) -- #163
//│   None => let x%3 = False() -- #179
//│     in jump f$P%0$M%0(x%3,x%26) -- #165
//│ )
//│ Def(14, f$D%0, [x%26,x%28], [{<ESelect(x)@f$D%0:#107-let x%31 = ...>},{<EDirect@f$D%0:#106-let* (x%32) = e1 ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%31 = x%26.x -- #107
//│   in let* (x%32) = e1(x%31,x%28) -- #106
//│     in let* (x%30) = e0(x%32) -- #144
//│       in x%30 -- #143
//│ )
//│ Def(15, f$D%1, [x%28], [{<EDirect@f$D%1:#114-let* (x%33) = e2 ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%33) = e2(x%28) -- #114
//│   in let* (x%30) = e0(x%33) -- #147
//│     in x%30 -- #146
//│ )
//│ Def(16, f$P%0$M%0, [x%27,x%26], [{<EDirect@f$P%0$M%0:#116-let* (x%28) = e3 ...>,<EIndirectDestruct@f$P%0$M%0:#116-let* (x%28) = e3 ...>},{<EDirect@f$P%0$M%0:#156-...>}],
//│ S: None,
//│ I: [[Some(ICtor(Some)),Some(ICtor(True))],[Some(ICtor(False)),Some(ICtor(None))]],
//│ R: [None,None],
//│ Rec: None,
//│ 2, 
//│ let* (x%28) = e3(x%27) -- #116
//│   in x%26,x%28 -- #156
//│ )
//│ },
//│ let* (x%39) = main() -- #140
//│   in x%39 -- #139)
//│ 
//│ Interpreted ------------------------------
//│ 115
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(2, e0, [w%0], [{<EDirect@e0:#21-let x%4 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%4 = +(w%0,8) -- #21
//│   in let x%5 = +(x%4,9) -- #20
//│     in let x%6 = +(x%5,10) -- #19
//│       in x%6 -- #18
//│ )
//│ Def(3, e1, [a%0,c%0], [{<EDirect@e1:#34-let x%7 = ...>},{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%7 = +(a%0,1) -- #34
//│   in let x%8 = +(x%7,2) -- #33
//│     in let x%9 = +(x%8,3) -- #32
//│       in let x%10 = +(x%9,4) -- #31
//│         in x%10 -- #30
//│ )
//│ Def(4, e3, [c%1], [{<EDestruct@e3:#63-if c%1 ...>,<EDirect@e3:#63-if c%1 ...>}],
//│ S: None,
//│ I: [[Some(ICtor(True))],[Some(ICtor(False))]],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if c%1 -- #63
//│   true => let x%16 = +(4,5) -- #51
//│     in let x%17 = +(x%16,6) -- #50
//│       in let x%18 = +(x%17,7) -- #49
//│         in x%18 -- #149
//│   false => let x%19 = +(4,5) -- #62
//│     in let x%20 = -(x%19,6) -- #61
//│       in let x%21 = +(x%20,7) -- #60
//│         in x%21 -- #150
//│ )
//│ Def(6, e2, [x%22], [{<EDirect@e2:#77-let x%23 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%23 = +(x%22,12) -- #77
//│   in let x%24 = +(x%23,13) -- #76
//│     in let x%25 = +(x%24,14) -- #75
//│       in x%25 -- #74
//│ )
//│ Def(9, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%34 = Some(2) -- #136
//│   in let* (x%43,x%44) = f$P%0$D%0(x%34) -- #190
//│     in let* (x%35) = f$D%0(x%43,x%44) -- #161
//│       in let x%36 = None() -- #134
//│         in let* (x%48,x%49) = f$P%0$D%1(x%36) -- #204
//│           in let* (x%37) = f$D%1(x%49) -- #169
//│             in let x%38 = +(x%35,x%37) -- #132
//│               in x%38 -- #131
//│ )
//│ Def(14, f$D%0, [x%26,x%28], [{<ESelect(x)@f$D%0:#107-let x%31 = ...>},{<EDirect@f$D%0:#106-let* (x%32) = e1 ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%31 = x%26.x -- #107
//│   in let* (x%32) = e1(x%31,x%28) -- #106
//│     in let* (x%30) = e0(x%32) -- #144
//│       in x%30 -- #143
//│ )
//│ Def(15, f$D%1, [x%28], [{<EDirect@f$D%1:#114-let* (x%33) = e2 ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%33) = e2(x%28) -- #114
//│   in let* (x%30) = e0(x%33) -- #147
//│     in x%30 -- #146
//│ )
//│ Def(18, f$P%0$D%0, [x%26], [{<EDirect@f$P%0$D%0:#208-...>}],
//│ S: None,
//│ I: [[Some(ICtor(Some))]],
//│ R: [None,None],
//│ Rec: None,
//│ 2, 
//│ let x%2 = True() -- #176
//│   in let* (x%57) = e3(x%2) -- #193
//│     in x%26,x%57 -- #208
//│ )
//│ Def(19, f$P%0$D%1, [x%26], [{<EDirect@f$P%0$D%1:#214-...>}],
//│ S: None,
//│ I: [[Some(ICtor(None))]],
//│ R: [None,None],
//│ Rec: None,
//│ 2, 
//│ let x%3 = False() -- #179
//│   in let* (x%60) = e3(x%3) -- #196
//│     in x%26,x%60 -- #214
//│ )
//│ },
//│ let* (x%39) = main() -- #140
//│   in x%39 -- #139)
//│ 
//│ Interpreted ------------------------------
//│ 115
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(2, e0, [w%0], [{<EDirect@e0:#21-let x%4 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%4 = +(w%0,8) -- #21
//│   in let x%5 = +(x%4,9) -- #20
//│     in let x%6 = +(x%5,10) -- #19
//│       in x%6 -- #18
//│ )
//│ Def(3, e1, [a%0,c%0], [{<EDirect@e1:#34-let x%7 = ...>},{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%7 = +(a%0,1) -- #34
//│   in let x%8 = +(x%7,2) -- #33
//│     in let x%9 = +(x%8,3) -- #32
//│       in let x%10 = +(x%9,4) -- #31
//│         in x%10 -- #30
//│ )
//│ Def(6, e2, [x%22], [{<EDirect@e2:#77-let x%23 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%23 = +(x%22,12) -- #77
//│   in let x%24 = +(x%23,13) -- #76
//│     in let x%25 = +(x%24,14) -- #75
//│       in x%25 -- #74
//│ )
//│ Def(9, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%34 = Some(2) -- #136
//│   in let* (x%43,x%44) = f$P%0$D%0(x%34) -- #190
//│     in let* (x%35) = f$D%0(x%43,x%44) -- #161
//│       in let x%36 = None() -- #134
//│         in let* (x%48,x%49) = f$P%0$D%1(x%36) -- #204
//│           in let* (x%37) = f$D%1(x%49) -- #169
//│             in let x%38 = +(x%35,x%37) -- #132
//│               in x%38 -- #131
//│ )
//│ Def(14, f$D%0, [x%26,x%28], [{<ESelect(x)@f$D%0:#107-let x%31 = ...>},{<EDirect@f$D%0:#106-let* (x%32) = e1 ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%31 = x%26.x -- #107
//│   in let* (x%32) = e1(x%31,x%28) -- #106
//│     in let* (x%30) = e0(x%32) -- #144
//│       in x%30 -- #143
//│ )
//│ Def(15, f$D%1, [x%28], [{<EDirect@f$D%1:#114-let* (x%33) = e2 ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%33) = e2(x%28) -- #114
//│   in let* (x%30) = e0(x%33) -- #147
//│     in x%30 -- #146
//│ )
//│ Def(18, f$P%0$D%0, [x%26], [{<EDirect@f$P%0$D%0:#208-...>}],
//│ S: None,
//│ I: [[Some(ICtor(Some))]],
//│ R: [None,None],
//│ Rec: None,
//│ 2, 
//│ let* (x%57) = e3$D%0() -- #229
//│   in x%26,x%57 -- #208
//│ )
//│ Def(19, f$P%0$D%1, [x%26], [{<EDirect@f$P%0$D%1:#214-...>}],
//│ S: None,
//│ I: [[Some(ICtor(None))]],
//│ R: [None,None],
//│ Rec: None,
//│ 2, 
//│ let* (x%60) = e3$D%1() -- #231
//│   in x%26,x%60 -- #214
//│ )
//│ Def(23, e3$D%0, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%16 = +(4,5) -- #51
//│   in let x%17 = +(x%16,6) -- #50
//│     in let x%18 = +(x%17,7) -- #49
//│       in x%18 -- #149
//│ )
//│ Def(24, e3$D%1, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%19 = +(4,5) -- #62
//│   in let x%20 = -(x%19,6) -- #61
//│     in let x%21 = +(x%20,7) -- #60
//│       in x%21 -- #150
//│ )
//│ },
//│ let* (x%39) = main() -- #140
//│   in x%39 -- #139)
//│ 
//│ Interpreted ------------------------------
//│ 115
//│ 
//│ 
//│ Interpreted ------------------------------
//│ 115
//│ 
//│ 
//│ 
//│ Fuel used: 4


:GraphOpt
class True
class False
class Cons(h, t)
class Nil
class Some(x)
class None
fun is_some(o) =
  if o is
    Some(x) then True
    None then False
fun e0(w) =
  w + 8 + 9 + 10
fun e1(a, z) =
  if a > 0 then f(Some(z - 1)) else z
fun e3(c) =
  let m = 4
  let n = 5
  let p = 6
  let q = 7
  if c then m + n + p + q else m + n - p + q
fun e2(x) =
  x + 12 + 13 + 14
fun f(x) =
  let c1 = is_some(x)
  let z = e3(c1)
  let w = if x is
    Some(a) then e1(a, z)
    None then e2(z)
  e0(w)
fun main() =
  f(Some(2)) + f(None)
main()
//│ |#class| |True|↵|#class| |False|↵|#class| |Cons|(|h|,| |t|)|↵|#class| |Nil|↵|#class| |Some|(|x|)|↵|#class| |None|↵|#fun| |is_some|(|o|)| |#=|→|#if| |o| |is|→|Some|(|x|)| |#then| |True|↵|None| |#then| |False|←|←|↵|#fun| |e0|(|w|)| |#=|→|w| |+| |8| |+| |9| |+| |10|←|↵|#fun| |e1|(|a|,| |z|)| |#=|→|#if| |a| |>| |0| |#then| |f|(|Some|(|z| |-| |1|)|)| |#else| |z|←|↵|#fun| |e3|(|c|)| |#=|→|#let| |m| |#=| |4|↵|#let| |n| |#=| |5|↵|#let| |p| |#=| |6|↵|#let| |q| |#=| |7|↵|#if| |c| |#then| |m| |+| |n| |+| |p| |+| |q| |#else| |m| |+| |n| |-| |p| |+| |q|←|↵|#fun| |e2|(|x|)| |#=|→|x| |+| |12| |+| |13| |+| |14|←|↵|#fun| |f|(|x|)| |#=|→|#let| |c1| |#=| |is_some|(|x|)|↵|#let| |z| |#=| |e3|(|c1|)|↵|#let| |w| |#=| |#if| |x| |is|→|Some|(|a|)| |#then| |e1|(|a|,| |z|)|↵|None| |#then| |e2|(|z|)|←|↵|e0|(|w|)|←|↵|#fun| |main|(||)| |#=|→|f|(|Some|(|2|)|)| |+| |f|(|None|)|←|↵|main|(||)|
//│ Parsed: {class True {}; class False {}; class Cons(h, t,) {}; class Nil {}; class Some(x,) {}; class None {}; fun is_some = (o,) => {if o is ‹(Some(x,)) then True; (None) then False›}; fun e0 = (w,) => {+(+(+(w,)(8,),)(9,),)(10,)}; fun e1 = (a, z,) => {if (>(a,)(0,)) then f(Some(-(z,)(1,),),) else z}; fun e3 = (c,) => {let m = 4; let n = 5; let p = 6; let q = 7; if (c) then +(+(+(m,)(n,),)(p,),)(q,) else +(-(+(m,)(n,),)(p,),)(q,)}; fun e2 = (x,) => {+(+(+(x,)(12,),)(13,),)(14,)}; fun f = (x,) => {let c1 = is_some(x,); let z = e3(c1,); let w = if x is ‹(Some(a,)) then e1(a, z,); (None) then e2(z,)›; e0(w,)}; fun main = () => {+(f(Some(2,),),)(f(None,),)}; main()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(0, is_some, [o%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case o%0 of -- #11
//│   Some => let x%1 = o%0.x -- #7
//│     in let x%2 = True() -- #6
//│       in jump j%0(x%2) -- #5
//│   None => let x%3 = False() -- #10
//│     in jump j%0(x%3) -- #9
//│ )
//│ Def(1, j%0, [x%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%0 -- #1
//│ )
//│ Def(2, e0, [w%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%4 = +(w%0,8) -- #21
//│   in let x%5 = +(x%4,9) -- #20
//│     in let x%6 = +(x%5,10) -- #19
//│       in x%6 -- #18
//│ )
//│ Def(3, e1, [a%0,z%0], [{},{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%7 = >(a%0,0) -- #43
//│   in if x%7 -- #42
//│     true => let x%9 = -(z%0,1) -- #39
//│       in let x%10 = Some(x%9) -- #38
//│         in let* (x%11) = f(x%10) -- #37
//│           in jump j%1(x%11) -- #36
//│     false => jump j%1(z%0) -- #41
//│ )
//│ Def(4, j%1, [x%8], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%8 -- #25
//│ )
//│ Def(5, e3, [c%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%12 = 4 -- #76
//│   in let x%13 = 5 -- #75
//│     in let x%14 = 6 -- #74
//│       in let x%15 = 7 -- #73
//│         in if c%0 -- #72
//│           true => let x%17 = +(x%12,x%13) -- #60
//│             in let x%18 = +(x%17,x%14) -- #59
//│               in let x%19 = +(x%18,x%15) -- #58
//│                 in jump j%2(x%19) -- #57
//│           false => let x%20 = +(x%12,x%13) -- #71
//│             in let x%21 = -(x%20,x%14) -- #70
//│               in let x%22 = +(x%21,x%15) -- #69
//│                 in jump j%2(x%22) -- #68
//│ )
//│ Def(6, j%2, [x%16], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%16 -- #49
//│ )
//│ Def(7, e2, [x%23], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%24 = +(x%23,12) -- #86
//│   in let x%25 = +(x%24,13) -- #85
//│     in let x%26 = +(x%25,14) -- #84
//│       in x%26 -- #83
//│ )
//│ Def(8, f, [x%27], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%28) = is_some(x%27) -- #126
//│   in let* (x%29) = e3(x%28) -- #125
//│     in case x%27 of -- #124
//│       Some => let x%32 = x%27.x -- #116
//│         in let* (x%33) = e1(x%32,x%29) -- #115
//│           in jump j%3(x%33) -- #114
//│       None => let* (x%34) = e2(x%29) -- #123
//│         in jump j%3(x%34) -- #122
//│ )
//│ Def(9, j%3, [x%30], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%31) = e0(x%30) -- #104
//│   in x%31 -- #103
//│ )
//│ Def(10, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%35 = Some(2) -- #145
//│   in let* (x%36) = f(x%35) -- #144
//│     in let x%37 = None() -- #143
//│       in let* (x%38) = f(x%37) -- #142
//│         in let x%39 = +(x%36,x%38) -- #141
//│           in x%39 -- #140
//│ )
//│ },
//│ let* (x%40) = main() -- #149
//│   in x%40 -- #148)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(0, is_some, [o%0], [{<EDestruct@is_some:#11-case o%0 of ...>,<EDirect@is_some:#11-case o%0 of ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ case o%0 of -- #11
//│   Some => let x%2 = True() -- #6
//│     in x%2 -- #150
//│   None => let x%3 = False() -- #10
//│     in x%3 -- #151
//│ )
//│ Def(2, e0, [w%0], [{<EDirect@e0:#21-let x%4 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%4 = +(w%0,8) -- #21
//│   in let x%5 = +(x%4,9) -- #20
//│     in let x%6 = +(x%5,10) -- #19
//│       in x%6 -- #18
//│ )
//│ Def(3, e1, [a%0,z%0], [{<EDirect@e1:#43-let x%7 = ...>},{<EDirect@e1:#39-let x%9 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: Some(1),
//│ 1, 
//│ let x%7 = >(a%0,0) -- #43
//│   in if x%7 -- #42
//│     true => let x%9 = -(z%0,1) -- #39
//│       in let x%10 = Some(x%9) -- #38
//│         in let* (x%11) = f(x%10) -- #37
//│           in x%11 -- #154
//│     false => z%0 -- #155
//│ )
//│ Def(5, e3, [c%0], [{<EDestruct@e3:#72-if c%0 ...>,<EDirect@e3:#72-if c%0 ...>}],
//│ S: None,
//│ I: [[Some(IMix(ICtor(False),ICtor(True)))]],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if c%0 -- #72
//│   true => let x%17 = +(4,5) -- #60
//│     in let x%18 = +(x%17,6) -- #59
//│       in let x%19 = +(x%18,7) -- #58
//│         in x%19 -- #152
//│   false => let x%20 = +(4,5) -- #71
//│     in let x%21 = -(x%20,6) -- #70
//│       in let x%22 = +(x%21,7) -- #69
//│         in x%22 -- #153
//│ )
//│ Def(7, e2, [x%23], [{<EDirect@e2:#86-let x%24 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%24 = +(x%23,12) -- #86
//│   in let x%25 = +(x%24,13) -- #85
//│     in let x%26 = +(x%25,14) -- #84
//│       in x%26 -- #83
//│ )
//│ Def(8, f, [x%27], [{<EDestruct@f:#124-case x%27 of ...>,<EDirect@f:#124-case x%27 of ...>,<EDirect@f:#126-let* (x%28) = is_some ...>,<EIndirectDestruct@f:#126-let* (x%28) = is_some ...>,<ESelect(x)@f:#116-let x%32 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(Some))],[Some(ICtor(None))]],
//│ R: [None],
//│ Rec: Some(1),
//│ 1, 
//│ let* (x%28) = is_some(x%27) -- #126
//│   in let* (x%29) = e3(x%28) -- #125
//│     in case x%27 of -- #124
//│       Some => let x%32 = x%27.x -- #116
//│         in let* (x%33) = e1(x%32,x%29) -- #115
//│           in let* (x%31) = e0(x%33) -- #157
//│             in x%31 -- #156
//│       None => let* (x%34) = e2(x%29) -- #123
//│         in let* (x%31) = e0(x%34) -- #160
//│           in x%31 -- #159
//│ )
//│ Def(10, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%35 = Some(2) -- #145
//│   in let* (x%36) = f(x%35) -- #144
//│     in let x%37 = None() -- #143
//│       in let* (x%38) = f(x%37) -- #142
//│         in let x%39 = +(x%36,x%38) -- #141
//│           in x%39 -- #140
//│ )
//│ },
//│ let* (x%40) = main() -- #149
//│   in x%40 -- #148)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(2, e0, [w%0], [{<EDirect@e0:#21-let x%4 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%4 = +(w%0,8) -- #21
//│   in let x%5 = +(x%4,9) -- #20
//│     in let x%6 = +(x%5,10) -- #19
//│       in x%6 -- #18
//│ )
//│ Def(3, e1, [a%0,z%0], [{<EDirect@e1:#43-let x%7 = ...>},{<EDirect@e1:#39-let x%9 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: Some(1),
//│ 1, 
//│ let x%7 = >(a%0,0) -- #43
//│   in if x%7 -- #42
//│     true => let x%9 = -(z%0,1) -- #39
//│       in let x%10 = Some(x%9) -- #38
//│         in let* (x%49,x%50) = f$P%0(x%10) -- #181
//│           in let* (x%11) = f$D%0(x%49,x%50) -- #180
//│             in x%11 -- #154
//│     false => z%0 -- #155
//│ )
//│ Def(5, e3, [c%0], [{<EDestruct@e3:#72-if c%0 ...>,<EDirect@e3:#72-if c%0 ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if c%0 -- #72
//│   true => let x%17 = +(4,5) -- #60
//│     in let x%18 = +(x%17,6) -- #59
//│       in let x%19 = +(x%18,7) -- #58
//│         in x%19 -- #152
//│   false => let x%20 = +(4,5) -- #71
//│     in let x%21 = -(x%20,6) -- #70
//│       in let x%22 = +(x%21,7) -- #69
//│         in x%22 -- #153
//│ )
//│ Def(7, e2, [x%23], [{<EDirect@e2:#86-let x%24 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%24 = +(x%23,12) -- #86
//│   in let x%25 = +(x%24,13) -- #85
//│     in let x%26 = +(x%25,14) -- #84
//│       in x%26 -- #83
//│ )
//│ Def(10, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%35 = Some(2) -- #145
//│   in let* (x%44,x%45) = f$P%0(x%35) -- #173
//│     in let* (x%36) = f$D%0(x%44,x%45) -- #172
//│       in let x%37 = None() -- #143
//│         in let* (x%51,x%52) = f$P%0(x%37) -- #183
//│           in let* (x%38) = f$D%1(x%52) -- #182
//│             in let x%39 = +(x%36,x%38) -- #141
//│               in x%39 -- #140
//│ )
//│ Def(14, f$P%0, [x%27], [{<EDestruct@f$P%0:#178-case x%27 of ...>,<EDirect@f$P%0:#174-jump f$P%0$M%0 ...>,<EDirect@f$P%0:#178-case x%27 of ...>}],
//│ S: None,
//│ I: [[Some(ICtor(Some))],[Some(ICtor(None))]],
//│ R: [None,None],
//│ Rec: None,
//│ 2, 
//│ case x%27 of -- #178
//│   Some => let x%2 = True() -- #189
//│     in jump f$P%0$M%0(x%2,x%27) -- #174
//│   None => let x%3 = False() -- #192
//│     in jump f$P%0$M%0(x%3,x%27) -- #176
//│ )
//│ Def(15, f$D%0, [x%27,x%29], [{<ESelect(x)@f$D%0:#116-let x%32 = ...>},{<EDirect@f$D%0:#115-let* (x%33) = e1 ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: Some(1),
//│ 1, 
//│ let x%32 = x%27.x -- #116
//│   in let* (x%33) = e1(x%32,x%29) -- #115
//│     in let* (x%31) = e0(x%33) -- #157
//│       in x%31 -- #156
//│ )
//│ Def(16, f$D%1, [x%29], [{<EDirect@f$D%1:#123-let* (x%34) = e2 ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%34) = e2(x%29) -- #123
//│   in let* (x%31) = e0(x%34) -- #160
//│     in x%31 -- #159
//│ )
//│ Def(17, f$P%0$M%0, [x%28,x%27], [{<EDirect@f$P%0$M%0:#125-let* (x%29) = e3 ...>,<EIndirectDestruct@f$P%0$M%0:#125-let* (x%29) = e3 ...>},{<EDirect@f$P%0$M%0:#167-...>}],
//│ S: None,
//│ I: [[Some(ICtor(Some)),Some(ICtor(True))],[Some(ICtor(False)),Some(ICtor(None))]],
//│ R: [None,None],
//│ Rec: None,
//│ 2, 
//│ let* (x%29) = e3(x%28) -- #125
//│   in x%27,x%29 -- #167
//│ )
//│ },
//│ let* (x%40) = main() -- #149
//│   in x%40 -- #148)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(2, e0, [w%0], [{<EDirect@e0:#21-let x%4 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%4 = +(w%0,8) -- #21
//│   in let x%5 = +(x%4,9) -- #20
//│     in let x%6 = +(x%5,10) -- #19
//│       in x%6 -- #18
//│ )
//│ Def(3, e1, [a%0,z%0], [{<EDirect@e1:#43-let x%7 = ...>},{<EDirect@e1:#39-let x%9 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: Some(1),
//│ 1, 
//│ let x%7 = >(a%0,0) -- #43
//│   in if x%7 -- #42
//│     true => let x%9 = -(z%0,1) -- #39
//│       in let x%10 = Some(x%9) -- #38
//│         in let* (x%49,x%50) = f$P%0$D%0(x%10) -- #208
//│           in let* (x%11) = f$D%0(x%49,x%50) -- #180
//│             in x%11 -- #154
//│     false => z%0 -- #155
//│ )
//│ Def(5, e3, [c%0], [{<EDestruct@e3:#72-if c%0 ...>,<EDirect@e3:#72-if c%0 ...>}],
//│ S: None,
//│ I: [[Some(ICtor(False))],[Some(ICtor(True))]],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if c%0 -- #72
//│   true => let x%17 = +(4,5) -- #60
//│     in let x%18 = +(x%17,6) -- #59
//│       in let x%19 = +(x%18,7) -- #58
//│         in x%19 -- #152
//│   false => let x%20 = +(4,5) -- #71
//│     in let x%21 = -(x%20,6) -- #70
//│       in let x%22 = +(x%21,7) -- #69
//│         in x%22 -- #153
//│ )
//│ Def(7, e2, [x%23], [{<EDirect@e2:#86-let x%24 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%24 = +(x%23,12) -- #86
//│   in let x%25 = +(x%24,13) -- #85
//│     in let x%26 = +(x%25,14) -- #84
//│       in x%26 -- #83
//│ )
//│ Def(10, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%35 = Some(2) -- #145
//│   in let* (x%44,x%45) = f$P%0$D%0(x%35) -- #203
//│     in let* (x%36) = f$D%0(x%44,x%45) -- #172
//│       in let x%37 = None() -- #143
//│         in let* (x%51,x%52) = f$P%0$D%1(x%37) -- #219
//│           in let* (x%38) = f$D%1(x%52) -- #182
//│             in let x%39 = +(x%36,x%38) -- #141
//│               in x%39 -- #140
//│ )
//│ Def(15, f$D%0, [x%27,x%29], [{<ESelect(x)@f$D%0:#116-let x%32 = ...>},{<EDirect@f$D%0:#115-let* (x%33) = e1 ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: Some(1),
//│ 1, 
//│ let x%32 = x%27.x -- #116
//│   in let* (x%33) = e1(x%32,x%29) -- #115
//│     in let* (x%31) = e0(x%33) -- #157
//│       in x%31 -- #156
//│ )
//│ Def(16, f$D%1, [x%29], [{<EDirect@f$D%1:#123-let* (x%34) = e2 ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%34) = e2(x%29) -- #123
//│   in let* (x%31) = e0(x%34) -- #160
//│     in x%31 -- #159
//│ )
//│ Def(19, f$P%0$D%0, [x%27], [{<EDirect@f$P%0$D%0:#230-...>}],
//│ S: None,
//│ I: [[Some(ICtor(Some))]],
//│ R: [None,None],
//│ Rec: None,
//│ 2, 
//│ let x%2 = True() -- #189
//│   in let* (x%64) = e3(x%2) -- #211
//│     in x%27,x%64 -- #230
//│ )
//│ Def(20, f$P%0$D%1, [x%27], [{<EDirect@f$P%0$D%1:#223-...>}],
//│ S: None,
//│ I: [[Some(ICtor(None))]],
//│ R: [None,None],
//│ Rec: None,
//│ 2, 
//│ let x%3 = False() -- #192
//│   in let* (x%60) = e3(x%3) -- #206
//│     in x%27,x%60 -- #223
//│ )
//│ },
//│ let* (x%40) = main() -- #149
//│   in x%40 -- #148)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(2, e0, [w%0], [{<EDirect@e0:#21-let x%4 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%4 = +(w%0,8) -- #21
//│   in let x%5 = +(x%4,9) -- #20
//│     in let x%6 = +(x%5,10) -- #19
//│       in x%6 -- #18
//│ )
//│ Def(3, e1, [a%0,z%0], [{<EDirect@e1:#43-let x%7 = ...>},{<EDirect@e1:#39-let x%9 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: Some(1),
//│ 1, 
//│ let x%7 = >(a%0,0) -- #43
//│   in if x%7 -- #42
//│     true => let x%9 = -(z%0,1) -- #39
//│       in let x%10 = Some(x%9) -- #38
//│         in let* (x%49,x%50) = f$P%0$D%0(x%10) -- #208
//│           in let* (x%11) = f$D%0(x%49,x%50) -- #180
//│             in x%11 -- #154
//│     false => z%0 -- #155
//│ )
//│ Def(7, e2, [x%23], [{<EDirect@e2:#86-let x%24 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%24 = +(x%23,12) -- #86
//│   in let x%25 = +(x%24,13) -- #85
//│     in let x%26 = +(x%25,14) -- #84
//│       in x%26 -- #83
//│ )
//│ Def(10, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%35 = Some(2) -- #145
//│   in let* (x%44,x%45) = f$P%0$D%0(x%35) -- #203
//│     in let* (x%36) = f$D%0(x%44,x%45) -- #172
//│       in let x%37 = None() -- #143
//│         in let* (x%51,x%52) = f$P%0$D%1(x%37) -- #219
//│           in let* (x%38) = f$D%1(x%52) -- #182
//│             in let x%39 = +(x%36,x%38) -- #141
//│               in x%39 -- #140
//│ )
//│ Def(15, f$D%0, [x%27,x%29], [{<ESelect(x)@f$D%0:#116-let x%32 = ...>},{<EDirect@f$D%0:#115-let* (x%33) = e1 ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: Some(1),
//│ 1, 
//│ let x%32 = x%27.x -- #116
//│   in let* (x%33) = e1(x%32,x%29) -- #115
//│     in let* (x%31) = e0(x%33) -- #157
//│       in x%31 -- #156
//│ )
//│ Def(16, f$D%1, [x%29], [{<EDirect@f$D%1:#123-let* (x%34) = e2 ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%34) = e2(x%29) -- #123
//│   in let* (x%31) = e0(x%34) -- #160
//│     in x%31 -- #159
//│ )
//│ Def(19, f$P%0$D%0, [x%27], [{<EDirect@f$P%0$D%0:#230-...>}],
//│ S: None,
//│ I: [[Some(ICtor(Some))]],
//│ R: [None,None],
//│ Rec: None,
//│ 2, 
//│ let* (x%64) = e3$D%0() -- #247
//│   in x%27,x%64 -- #230
//│ )
//│ Def(20, f$P%0$D%1, [x%27], [{<EDirect@f$P%0$D%1:#223-...>}],
//│ S: None,
//│ I: [[Some(ICtor(None))]],
//│ R: [None,None],
//│ Rec: None,
//│ 2, 
//│ let* (x%60) = e3$D%1() -- #245
//│   in x%27,x%60 -- #223
//│ )
//│ Def(24, e3$D%0, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%17 = +(4,5) -- #60
//│   in let x%18 = +(x%17,6) -- #59
//│     in let x%19 = +(x%18,7) -- #58
//│       in x%19 -- #152
//│ )
//│ Def(25, e3$D%1, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%20 = +(4,5) -- #71
//│   in let x%21 = -(x%20,6) -- #70
//│     in let x%22 = +(x%21,7) -- #69
//│       in x%22 -- #153
//│ )
//│ },
//│ let* (x%40) = main() -- #149
//│   in x%40 -- #148)
//│ 
//│ 
//│ Fuel used: 4
