:NewParser
:ParseOnly

:GraphInterp
:GraphOpt
class True
class False
fun fib(n) = if n < 2 then n else fib(n-1) + fib(n-2)
fib(20)
//│ |#class| |True|↵|#class| |False|↵|#fun| |fib|(|n|)| |#=| |#if| |n| |<| |2| |#then| |n| |#else| |fib|(|n|-|1|)| |+| |fib|(|n|-|2|)|↵|fib|(|20|)|
//│ Parsed: {class True {}; class False {}; fun fib = (n,) => if (<(n,)(2,)) then n else +(fib(-(n,)(1,),),)(fib(-(n,)(2,),),); fib(20,)}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, fib, [n%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%0 = <(n%0,2) -- #x
//│   in if x%0 -- #x
//│     true => jump j%0(n%0) -- #x
//│     false => let x%1 = -(n%0,1) -- #x
//│       in let* (x%2) = fib(x%1) -- #x
//│         in let x%3 = -(n%0,2) -- #x
//│           in let* (x%4) = fib(x%3) -- #x
//│             in let x%5 = +(x%2,x%4) -- #x
//│               in jump j%0(x%5) -- #x
//│ )
//│ Def(1, @join j%0, [x%6], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%6
//│ )
//│ },
//│ let* (x%7) = fib(20) -- #x
//│   in x%7)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, fib, [n%0], [{<EDirect@fib:...>,<EDirect@fib:let x%0 = ...>,<EDirect@fib:let x%1 = ...>,<EDirect@fib:let x%3 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: Some(0),
//│ 1, 
//│ let x%0 = <(n%0,2) -- #x
//│   in if x%0 -- #x
//│     true => n%0
//│     false => let x%1 = -(n%0,1) -- #x
//│       in let* (x%2) = fib(x%1) -- #x
//│         in let x%3 = -(n%0,2) -- #x
//│           in let* (x%4) = fib(x%3) -- #x
//│             in let x%5 = +(x%2,x%4) -- #x
//│               in x%5
//│ )
//│ },
//│ let* (x%7) = fib(20) -- #x
//│   in x%7)
//│ 
//│ Interpreted ------------------------------
//│ 6765
//│ 
//│ 
//│ 
//│ Interpreted ------------------------------
//│ 6765
//│ 
//│ 
//│ Fuel used: 1

:GraphInterp
:GraphOpt
class True
class False
fun odd(x) = if x == 0 then False else even(x-1)
fun even(x) = if x == 0 then True else odd(x-1)
fun foo() = odd(10)
foo()
//│ |#class| |True|↵|#class| |False|↵|#fun| |odd|(|x|)| |#=| |#if| |x| |==| |0| |#then| |False| |#else| |even|(|x|-|1|)|↵|#fun| |even|(|x|)| |#=| |#if| |x| |==| |0| |#then| |True| |#else| |odd|(|x|-|1|)|↵|#fun| |foo|(||)| |#=| |odd|(|10|)|↵|foo|(||)|
//│ Parsed: {class True {}; class False {}; fun odd = (x,) => if (==(x,)(0,)) then False else even(-(x,)(1,),); fun even = (x,) => if (==(x,)(0,)) then True else odd(-(x,)(1,),); fun foo = () => odd(10,); foo()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, odd, [x%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%1 = ==(x%0,0) -- #x
//│   in if x%1 -- #x
//│     true => let x%2 = False() -- #x
//│       in jump j%0(x%2) -- #x
//│     false => let x%3 = -(x%0,1) -- #x
//│       in let* (x%4) = even(x%3) -- #x
//│         in jump j%0(x%4) -- #x
//│ )
//│ Def(1, @join j%0, [x%5], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%5
//│ )
//│ Def(2, even, [x%6], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%7 = ==(x%6,0) -- #x
//│   in if x%7 -- #x
//│     true => let x%8 = True() -- #x
//│       in jump j%1(x%8) -- #x
//│     false => let x%9 = -(x%6,1) -- #x
//│       in let* (x%10) = odd(x%9) -- #x
//│         in jump j%1(x%10) -- #x
//│ )
//│ Def(3, @join j%1, [x%11], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%11
//│ )
//│ Def(4, foo, [], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%12) = odd(10) -- #x
//│   in x%12
//│ )
//│ },
//│ let* (x%13) = foo() -- #x
//│   in x%13)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, odd, [x%0], [{<EDirect@odd:let x%1 = ...>,<EDirect@odd:let x%3 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(1),
//│ 1, 
//│ let x%1 = ==(x%0,0) -- #x
//│   in if x%1 -- #x
//│     true => let x%2 = False() -- #x
//│       in x%2
//│     false => let x%3 = -(x%0,1) -- #x
//│       in let* (x%4) = even(x%3) -- #x
//│         in x%4
//│ )
//│ Def(2, even, [x%6], [{<EDirect@even:let x%7 = ...>,<EDirect@even:let x%9 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(1),
//│ 1, 
//│ let x%7 = ==(x%6,0) -- #x
//│   in if x%7 -- #x
//│     true => let x%8 = True() -- #x
//│       in x%8
//│     false => let x%9 = -(x%6,1) -- #x
//│       in let* (x%10) = odd(x%9) -- #x
//│         in x%10
//│ )
//│ Def(4, foo, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%12) = odd(10) -- #x
//│   in x%12
//│ )
//│ },
//│ let* (x%13) = foo() -- #x
//│   in x%13)
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ Fuel used: 1

:GraphInterp
:GraphOpt
class True
class False
class A
class B(b)
fun not(x) =
  if x then False else True
fun foo(x) =
  if x then A
       else B(foo(not(x)))
fun main() = foo(False)
main()
//│ |#class| |True|↵|#class| |False|↵|#class| |A|↵|#class| |B|(|b|)|↵|#fun| |not|(|x|)| |#=|→|#if| |x| |#then| |False| |#else| |True|←|↵|#fun| |foo|(|x|)| |#=|→|#if| |x| |#then| |A|→|#else| |B|(|foo|(|not|(|x|)|)|)|←|←|↵|#fun| |main|(||)| |#=| |foo|(|False|)|↵|main|(||)|
//│ Parsed: {class True {}; class False {}; class A {}; class B(b,) {}; fun not = (x,) => {if (x) then False else True}; fun foo = (x,) => {if (x) then A else B(foo(not(x,),),)}; fun main = () => foo(False,); main()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(0, not, [x%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x%0 -- #x
//│   true => let x%1 = False() -- #x
//│     in jump j%0(x%1) -- #x
//│   false => let x%2 = True() -- #x
//│     in jump j%0(x%2) -- #x
//│ )
//│ Def(1, @join j%0, [x%3], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%3
//│ )
//│ Def(2, foo, [x%4], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x%4 -- #x
//│   true => let x%5 = A() -- #x
//│     in jump j%1(x%5) -- #x
//│   false => let* (x%6) = not(x%4) -- #x
//│     in let* (x%7) = foo(x%6) -- #x
//│       in let x%8 = B(x%7) -- #x
//│         in jump j%1(x%8) -- #x
//│ )
//│ Def(3, @join j%1, [x%9], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%9
//│ )
//│ Def(4, main, [], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%10 = False() -- #x
//│   in let* (x%11) = foo(x%10) -- #x
//│     in x%11
//│ )
//│ },
//│ let* (x%12) = main() -- #x
//│   in x%12)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(0, not, [x%0], [{<EDestruct@not:if x%0 ...>,<EDirect@not:if x%0 ...>}],
//│ S: None,
//│ I: [[Some(ICtor(False))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ if x%0 -- #x
//│   true => let x%1 = False() -- #x
//│     in x%1
//│   false => let x%2 = True() -- #x
//│     in x%2
//│ )
//│ Def(2, foo, [x%4], [{<EDestruct@foo:if x%4 ...>,<EDirect@foo:if x%4 ...>,<EDirect@foo:let* (x%6) = not ...>,<EIndirectDestruct@foo:let* (x%6) = not ...>}],
//│ S: None,
//│ I: [[Some(ICtor(False))],[Some(IMix(ICtor(False),ICtor(True)))]],
//│ R: [Some(IMix(ICtor(A),ICtor(B)))],
//│ Rec: Some(1),
//│ 1, 
//│ if x%4 -- #x
//│   true => let x%5 = A() -- #x
//│     in x%5
//│   false => let* (x%6) = not(x%4) -- #x
//│     in let* (x%7) = foo(x%6) -- #x
//│       in let x%8 = B(x%7) -- #x
//│         in x%8
//│ )
//│ Def(4, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(A),ICtor(B)))],
//│ Rec: None,
//│ 1, 
//│ let x%10 = False() -- #x
//│   in let* (x%11) = foo(x%10) -- #x
//│     in x%11
//│ )
//│ },
//│ let* (x%12) = main() -- #x
//│   in x%12)
//│ 
//│ Interpreted ------------------------------
//│ B(A())
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(2, foo, [x%4], [{<EDestruct@foo:if x%4 ...>,<EDirect@foo:if x%4 ...>}],
//│ S: None,
//│ I: [[Some(ICtor(False))],[Some(ICtor(True))]],
//│ R: [Some(IMix(ICtor(A),ICtor(B)))],
//│ Rec: Some(1),
//│ 1, 
//│ if x%4 -- #x
//│   true => let x%5 = A() -- #x
//│     in x%5
//│   false => let x%2 = True() -- #x
//│     in let* (x%7) = foo(x%2) -- #x
//│       in let x%8 = B(x%7) -- #x
//│         in x%8
//│ )
//│ Def(4, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(A),ICtor(B)))],
//│ Rec: None,
//│ 1, 
//│ let x%10 = False() -- #x
//│   in let* (x%11) = foo(x%10) -- #x
//│     in x%11
//│ )
//│ },
//│ let* (x%12) = main() -- #x
//│   in x%12)
//│ 
//│ 
//│ Interpreted ------------------------------
//│ B(A())
//│ 
//│ 
//│ Fuel used: 2

:GraphInterp
:GraphOpt
class True
class False
class A()
class B(b)
fun aaa() =
  let m = 1
  let n = 2
  let p = 3
  let q = 4
  m + n - p + q
fun bbb() =
  let x = aaa()
  x * 100 + 4
fun not(x) =
  if x then False else True
fun foo(x) =
  if x then A
       else B(foo(not(x)))
fun main() =
  let x = foo(False)
  if x is
    A then aaa()
    B(b1) then bbb()
main()
//│ |#class| |True|↵|#class| |False|↵|#class| |A|(||)|↵|#class| |B|(|b|)|↵|#fun| |aaa|(||)| |#=|→|#let| |m| |#=| |1|↵|#let| |n| |#=| |2|↵|#let| |p| |#=| |3|↵|#let| |q| |#=| |4|↵|m| |+| |n| |-| |p| |+| |q|←|↵|#fun| |bbb|(||)| |#=|→|#let| |x| |#=| |aaa|(||)|↵|x| |*| |100| |+| |4|←|↵|#fun| |not|(|x|)| |#=|→|#if| |x| |#then| |False| |#else| |True|←|↵|#fun| |foo|(|x|)| |#=|→|#if| |x| |#then| |A|→|#else| |B|(|foo|(|not|(|x|)|)|)|←|←|↵|#fun| |main|(||)| |#=|→|#let| |x| |#=| |foo|(|False|)|↵|#if| |x| |is|→|A| |#then| |aaa|(||)|↵|B|(|b1|)| |#then| |bbb|(||)|←|←|↵|main|(||)|
//│ Parsed: {class True {}; class False {}; class A() {}; class B(b,) {}; fun aaa = () => {let m = 1; let n = 2; let p = 3; let q = 4; +(-(+(m,)(n,),)(p,),)(q,)}; fun bbb = () => {let x = aaa(); +(*(x,)(100,),)(4,)}; fun not = (x,) => {if (x) then False else True}; fun foo = (x,) => {if (x) then A else B(foo(not(x,),),)}; fun main = () => {let x = foo(False,); if x is ‹(A) then aaa(); (B(b1,)) then bbb()›}; main()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(0, aaa, [], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%0 = 1 -- #x
//│   in let x%1 = 2 -- #x
//│     in let x%2 = 3 -- #x
//│       in let x%3 = 4 -- #x
//│         in let x%4 = +(x%0,x%1) -- #x
//│           in let x%5 = -(x%4,x%2) -- #x
//│             in let x%6 = +(x%5,x%3) -- #x
//│               in x%6
//│ )
//│ Def(1, bbb, [], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%7) = aaa() -- #x
//│   in let x%8 = *(x%7,100) -- #x
//│     in let x%9 = +(x%8,4) -- #x
//│       in x%9
//│ )
//│ Def(2, not, [x%10], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x%10 -- #x
//│   true => let x%11 = False() -- #x
//│     in jump j%0(x%11) -- #x
//│   false => let x%12 = True() -- #x
//│     in jump j%0(x%12) -- #x
//│ )
//│ Def(3, @join j%0, [x%13], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%13
//│ )
//│ Def(4, foo, [x%14], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x%14 -- #x
//│   true => let x%15 = A() -- #x
//│     in jump j%1(x%15) -- #x
//│   false => let* (x%16) = not(x%14) -- #x
//│     in let* (x%17) = foo(x%16) -- #x
//│       in let x%18 = B(x%17) -- #x
//│         in jump j%1(x%18) -- #x
//│ )
//│ Def(5, @join j%1, [x%19], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%19
//│ )
//│ Def(6, main, [], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%20 = False() -- #x
//│   in let* (x%21) = foo(x%20) -- #x
//│     in case x%21 of -- #x
//│       A => let* (x%22) = aaa() -- #x
//│         in jump j%2(x%22) -- #x
//│       B => let x%23 = x%21.b -- #x
//│         in let* (x%24) = bbb() -- #x
//│           in jump j%2(x%24) -- #x
//│ )
//│ Def(7, @join j%2, [x%25], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%25
//│ )
//│ },
//│ let* (x%26) = main() -- #x
//│   in x%26)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(0, aaa, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%4 = +(1,2) -- #x
//│   in let x%5 = -(x%4,3) -- #x
//│     in let x%6 = +(x%5,4) -- #x
//│       in x%6
//│ )
//│ Def(1, bbb, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%7) = aaa() -- #x
//│   in let x%8 = *(x%7,100) -- #x
//│     in let x%9 = +(x%8,4) -- #x
//│       in x%9
//│ )
//│ Def(2, not, [x%10], [{<EDestruct@not:if x%10 ...>,<EDirect@not:if x%10 ...>}],
//│ S: None,
//│ I: [[Some(ICtor(False))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ if x%10 -- #x
//│   true => let x%11 = False() -- #x
//│     in x%11
//│   false => let x%12 = True() -- #x
//│     in x%12
//│ )
//│ Def(4, foo, [x%14], [{<EDestruct@foo:if x%14 ...>,<EDirect@foo:if x%14 ...>,<EDirect@foo:let* (x%16) = not ...>,<EIndirectDestruct@foo:let* (x%16) = not ...>}],
//│ S: None,
//│ I: [[Some(ICtor(False))],[Some(IMix(ICtor(False),ICtor(True)))]],
//│ R: [Some(IMix(ICtor(A),ICtor(B)))],
//│ Rec: Some(1),
//│ 1, 
//│ if x%14 -- #x
//│   true => let x%15 = A() -- #x
//│     in x%15
//│   false => let* (x%16) = not(x%14) -- #x
//│     in let* (x%17) = foo(x%16) -- #x
//│       in let x%18 = B(x%17) -- #x
//│         in x%18
//│ )
//│ Def(6, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%20 = False() -- #x
//│   in let* (x%21) = foo(x%20) -- #x
//│     in case x%21 of -- #x
//│       A => let* (x%22) = aaa() -- #x
//│         in x%22
//│       B => let* (x%24) = bbb() -- #x
//│         in x%24
//│ )
//│ },
//│ let* (x%26) = main() -- #x
//│   in x%26)
//│ 
//│ Interpreted ------------------------------
//│ 404
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(0, aaa, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%4 = +(1,2) -- #x
//│   in let x%5 = -(x%4,3) -- #x
//│     in let x%6 = +(x%5,4) -- #x
//│       in x%6
//│ )
//│ Def(1, bbb, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%7) = aaa() -- #x
//│   in let x%8 = *(x%7,100) -- #x
//│     in let x%9 = +(x%8,4) -- #x
//│       in x%9
//│ )
//│ Def(4, foo, [x%14], [{<EDestruct@foo:if x%14 ...>,<EDirect@foo:if x%14 ...>}],
//│ S: None,
//│ I: [[Some(ICtor(False))],[Some(ICtor(True))]],
//│ R: [Some(IMix(ICtor(A),ICtor(B)))],
//│ Rec: Some(1),
//│ 1, 
//│ if x%14 -- #x
//│   true => let x%15 = A() -- #x
//│     in x%15
//│   false => let x%12 = True() -- #x
//│     in let* (x%17) = foo(x%12) -- #x
//│       in let x%18 = B(x%17) -- #x
//│         in x%18
//│ )
//│ Def(6, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%20 = False() -- #x
//│   in let* (x%21) = foo(x%20) -- #x
//│     in case x%21 of -- #x
//│       A => let* (x%22) = aaa() -- #x
//│         in x%22
//│       B => let* (x%24) = bbb() -- #x
//│         in x%24
//│ )
//│ },
//│ let* (x%26) = main() -- #x
//│   in x%26)
//│ 
//│ 
//│ Interpreted ------------------------------
//│ 404
//│ 
//│ 
//│ Fuel used: 2


:GraphInterp
:GraphOpt
class True
class False
class S(s)
class O
fun odd(x) =
  if x is
    O then False
    S(s) then even(s)
fun even(x) =
  if x is
    O then True
    S(s) then odd(s)
fun foo() = odd(S(S(S(O))))
foo()
//│ |#class| |True|↵|#class| |False|↵|#class| |S|(|s|)|↵|#class| |O|↵|#fun| |odd|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |False|↵|S|(|s|)| |#then| |even|(|s|)|←|←|↵|#fun| |even|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |True|↵|S|(|s|)| |#then| |odd|(|s|)|←|←|↵|#fun| |foo|(||)| |#=| |odd|(|S|(|S|(|S|(|O|)|)|)|)|↵|foo|(||)|
//│ Parsed: {class True {}; class False {}; class S(s,) {}; class O {}; fun odd = (x,) => {if x is ‹(O) then False; (S(s,)) then even(s,)›}; fun even = (x,) => {if x is ‹(O) then True; (S(s,)) then odd(s,)›}; fun foo = () => odd(S(S(S(O,),),),); foo()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x%0 of -- #x
//│   O => let x%1 = False() -- #x
//│     in jump j%0(x%1) -- #x
//│   S => let x%2 = x%0.s -- #x
//│     in let* (x%3) = even(x%2) -- #x
//│       in jump j%0(x%3) -- #x
//│ )
//│ Def(1, @join j%0, [x%4], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%4
//│ )
//│ Def(2, even, [x%5], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x%5 of -- #x
//│   O => let x%6 = True() -- #x
//│     in jump j%1(x%6) -- #x
//│   S => let x%7 = x%5.s -- #x
//│     in let* (x%8) = odd(x%7) -- #x
//│       in jump j%1(x%8) -- #x
//│ )
//│ Def(3, @join j%1, [x%9], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%9
//│ )
//│ Def(4, foo, [], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%10 = O() -- #x
//│   in let x%11 = S(x%10) -- #x
//│     in let x%12 = S(x%11) -- #x
//│       in let x%13 = S(x%12) -- #x
//│         in let* (x%14) = odd(x%13) -- #x
//│           in x%14
//│ )
//│ },
//│ let* (x%15) = foo() -- #x
//│   in x%15)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0], [{<EDestruct@odd:case x%0 of ...>,<EDirect@odd:case x%0 of ...>,<ESelect(s)@odd:let x%2 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(S))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(1),
//│ 1, 
//│ case x%0 of -- #x
//│   O => let x%1 = False() -- #x
//│     in x%1
//│   S => let x%2 = x%0.s -- #x
//│     in let* (x%3) = even(x%2) -- #x
//│       in x%3
//│ )
//│ Def(2, even, [x%5], [{<EDestruct@even:case x%5 of ...>,<EDirect@even:case x%5 of ...>,<ESelect(s)@even:let x%7 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(1),
//│ 1, 
//│ case x%5 of -- #x
//│   O => let x%6 = True() -- #x
//│     in x%6
//│   S => let x%7 = x%5.s -- #x
//│     in let* (x%8) = odd(x%7) -- #x
//│       in x%8
//│ )
//│ Def(4, foo, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let x%10 = O() -- #x
//│   in let x%11 = S(x%10) -- #x
//│     in let x%12 = S(x%11) -- #x
//│       in let x%13 = S(x%12) -- #x
//│         in let* (x%14) = odd(x%13) -- #x
//│           in x%14
//│ )
//│ },
//│ let* (x%15) = foo() -- #x
//│   in x%15)
//│ 
//│ Interpreted ------------------------------
//│ True()
//│ 
//│ 
//│ 
//│ Interpreted ------------------------------
//│ True()
//│ 
//│ 
//│ Fuel used: 1

:GraphInterp
:GraphOpt
class True
class False
class S(s)
class O
fun odd(x) =
  if x is
    O then False
    S(s) then even(s)
fun even(x) =
  if x is
    O then True
    S(s) then odd(s)
fun mk(n) = if n > 0 then S(mk(n - 1)) else O
fun foo() = odd(mk(10))
foo() 
//│ |#class| |True|↵|#class| |False|↵|#class| |S|(|s|)|↵|#class| |O|↵|#fun| |odd|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |False|↵|S|(|s|)| |#then| |even|(|s|)|←|←|↵|#fun| |even|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |True|↵|S|(|s|)| |#then| |odd|(|s|)|←|←|↵|#fun| |mk|(|n|)| |#=| |#if| |n| |>| |0| |#then| |S|(|mk|(|n| |-| |1|)|)| |#else| |O|↵|#fun| |foo|(||)| |#=| |odd|(|mk|(|10|)|)|↵|foo|(||)| |
//│ Parsed: {class True {}; class False {}; class S(s,) {}; class O {}; fun odd = (x,) => {if x is ‹(O) then False; (S(s,)) then even(s,)›}; fun even = (x,) => {if x is ‹(O) then True; (S(s,)) then odd(s,)›}; fun mk = (n,) => if (>(n,)(0,)) then S(mk(-(n,)(1,),),) else O; fun foo = () => odd(mk(10,),); foo()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x%0 of -- #x
//│   O => let x%1 = False() -- #x
//│     in jump j%0(x%1) -- #x
//│   S => let x%2 = x%0.s -- #x
//│     in let* (x%3) = even(x%2) -- #x
//│       in jump j%0(x%3) -- #x
//│ )
//│ Def(1, @join j%0, [x%4], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%4
//│ )
//│ Def(2, even, [x%5], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x%5 of -- #x
//│   O => let x%6 = True() -- #x
//│     in jump j%1(x%6) -- #x
//│   S => let x%7 = x%5.s -- #x
//│     in let* (x%8) = odd(x%7) -- #x
//│       in jump j%1(x%8) -- #x
//│ )
//│ Def(3, @join j%1, [x%9], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%9
//│ )
//│ Def(4, mk, [n%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%10 = >(n%0,0) -- #x
//│   in if x%10 -- #x
//│     true => let x%11 = -(n%0,1) -- #x
//│       in let* (x%12) = mk(x%11) -- #x
//│         in let x%13 = S(x%12) -- #x
//│           in jump j%2(x%13) -- #x
//│     false => let x%14 = O() -- #x
//│       in jump j%2(x%14) -- #x
//│ )
//│ Def(5, @join j%2, [x%15], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%15
//│ )
//│ Def(6, foo, [], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%16) = mk(10) -- #x
//│   in let* (x%17) = odd(x%16) -- #x
//│     in x%17
//│ )
//│ },
//│ let* (x%18) = foo() -- #x
//│   in x%18)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0], [{<EDestruct@odd:case x%0 of ...>,<EDirect@odd:case x%0 of ...>,<ESelect(s)@odd:let x%2 = ...>}],
//│ S: None,
//│ I: [[Some(IMix(ICtor(O),ICtor(S)))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(2),
//│ 1, 
//│ case x%0 of -- #x
//│   O => let x%1 = False() -- #x
//│     in x%1
//│   S => let x%2 = x%0.s -- #x
//│     in let* (x%3) = even(x%2) -- #x
//│       in x%3
//│ )
//│ Def(2, even, [x%5], [{<EDestruct@even:case x%5 of ...>,<EDirect@even:case x%5 of ...>,<ESelect(s)@even:let x%7 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(2),
//│ 1, 
//│ case x%5 of -- #x
//│   O => let x%6 = True() -- #x
//│     in x%6
//│   S => let x%7 = x%5.s -- #x
//│     in let* (x%8) = odd(x%7) -- #x
//│       in x%8
//│ )
//│ Def(4, mk, [n%0], [{<EDirect@mk:let x%10 = ...>,<EDirect@mk:let x%11 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(O),ICtor(S)))],
//│ Rec: Some(1),
//│ 1, 
//│ let x%10 = >(n%0,0) -- #x
//│   in if x%10 -- #x
//│     true => let x%11 = -(n%0,1) -- #x
//│       in let* (x%12) = mk(x%11) -- #x
//│         in let x%13 = S(x%12) -- #x
//│           in x%13
//│     false => let x%14 = O() -- #x
//│       in x%14
//│ )
//│ Def(6, foo, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%16) = mk(10) -- #x
//│   in let* (x%17) = odd(x%16) -- #x
//│     in x%17
//│ )
//│ },
//│ let* (x%18) = foo() -- #x
//│   in x%18)
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ Fuel used: 1

:GraphInterp
:GraphOpt
class True
class False
class S(s)
class O
fun odd(x) =
  if x is
    O then False
    S(s) then even(s)
fun even(x) =
  if x is
    O then True
    S(s) then odd(s)
fun mk(n) = if n > 0 then S(mk(n - 1)) else O
fun foo() = odd(S(S(mk(10))))
foo()
//│ |#class| |True|↵|#class| |False|↵|#class| |S|(|s|)|↵|#class| |O|↵|#fun| |odd|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |False|↵|S|(|s|)| |#then| |even|(|s|)|←|←|↵|#fun| |even|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |True|↵|S|(|s|)| |#then| |odd|(|s|)|←|←|↵|#fun| |mk|(|n|)| |#=| |#if| |n| |>| |0| |#then| |S|(|mk|(|n| |-| |1|)|)| |#else| |O|↵|#fun| |foo|(||)| |#=| |odd|(|S|(|S|(|mk|(|10|)|)|)|)|↵|foo|(||)|
//│ Parsed: {class True {}; class False {}; class S(s,) {}; class O {}; fun odd = (x,) => {if x is ‹(O) then False; (S(s,)) then even(s,)›}; fun even = (x,) => {if x is ‹(O) then True; (S(s,)) then odd(s,)›}; fun mk = (n,) => if (>(n,)(0,)) then S(mk(-(n,)(1,),),) else O; fun foo = () => odd(S(S(mk(10,),),),); foo()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x%0 of -- #x
//│   O => let x%1 = False() -- #x
//│     in jump j%0(x%1) -- #x
//│   S => let x%2 = x%0.s -- #x
//│     in let* (x%3) = even(x%2) -- #x
//│       in jump j%0(x%3) -- #x
//│ )
//│ Def(1, @join j%0, [x%4], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%4
//│ )
//│ Def(2, even, [x%5], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x%5 of -- #x
//│   O => let x%6 = True() -- #x
//│     in jump j%1(x%6) -- #x
//│   S => let x%7 = x%5.s -- #x
//│     in let* (x%8) = odd(x%7) -- #x
//│       in jump j%1(x%8) -- #x
//│ )
//│ Def(3, @join j%1, [x%9], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%9
//│ )
//│ Def(4, mk, [n%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%10 = >(n%0,0) -- #x
//│   in if x%10 -- #x
//│     true => let x%11 = -(n%0,1) -- #x
//│       in let* (x%12) = mk(x%11) -- #x
//│         in let x%13 = S(x%12) -- #x
//│           in jump j%2(x%13) -- #x
//│     false => let x%14 = O() -- #x
//│       in jump j%2(x%14) -- #x
//│ )
//│ Def(5, @join j%2, [x%15], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%15
//│ )
//│ Def(6, foo, [], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%16) = mk(10) -- #x
//│   in let x%17 = S(x%16) -- #x
//│     in let x%18 = S(x%17) -- #x
//│       in let* (x%19) = odd(x%18) -- #x
//│         in x%19
//│ )
//│ },
//│ let* (x%20) = foo() -- #x
//│   in x%20)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0], [{<EDestruct@odd:case x%0 of ...>,<EDirect@odd:case x%0 of ...>,<ESelect(s)@odd:let x%2 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(S))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(2),
//│ 1, 
//│ case x%0 of -- #x
//│   O => let x%1 = False() -- #x
//│     in x%1
//│   S => let x%2 = x%0.s -- #x
//│     in let* (x%3) = even(x%2) -- #x
//│       in x%3
//│ )
//│ Def(2, even, [x%5], [{<EDestruct@even:case x%5 of ...>,<EDirect@even:case x%5 of ...>,<ESelect(s)@even:let x%7 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(2),
//│ 1, 
//│ case x%5 of -- #x
//│   O => let x%6 = True() -- #x
//│     in x%6
//│   S => let x%7 = x%5.s -- #x
//│     in let* (x%8) = odd(x%7) -- #x
//│       in x%8
//│ )
//│ Def(4, mk, [n%0], [{<EDirect@mk:let x%10 = ...>,<EDirect@mk:let x%11 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(O),ICtor(S)))],
//│ Rec: Some(1),
//│ 1, 
//│ let x%10 = >(n%0,0) -- #x
//│   in if x%10 -- #x
//│     true => let x%11 = -(n%0,1) -- #x
//│       in let* (x%12) = mk(x%11) -- #x
//│         in let x%13 = S(x%12) -- #x
//│           in x%13
//│     false => let x%14 = O() -- #x
//│       in x%14
//│ )
//│ Def(6, foo, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%16) = mk(10) -- #x
//│   in let x%17 = S(x%16) -- #x
//│     in let x%18 = S(x%17) -- #x
//│       in let* (x%19) = odd(x%18) -- #x
//│         in x%19
//│ )
//│ },
//│ let* (x%20) = foo() -- #x
//│   in x%20)
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ Fuel used: 1

:GraphInterp
:GraphOpt
class True
class False
class S(s)
class O
fun odd(x) =
  if x is
    O then False
    S(s) then even(s)
fun even(x) =
  if x is
    O then True
    S(s) then odd(s)
fun foo() = odd(if 10 > 0 then S(O) else O)
fun bar() = if 10 > 0 then odd(S(O)) else odd(O)
fun main() =
  foo()
  bar()
main()
//│ |#class| |True|↵|#class| |False|↵|#class| |S|(|s|)|↵|#class| |O|↵|#fun| |odd|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |False|↵|S|(|s|)| |#then| |even|(|s|)|←|←|↵|#fun| |even|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |True|↵|S|(|s|)| |#then| |odd|(|s|)|←|←|↵|#fun| |foo|(||)| |#=| |odd|(|#if| |10| |>| |0| |#then| |S|(|O|)| |#else| |O|)|↵|#fun| |bar|(||)| |#=| |#if| |10| |>| |0| |#then| |odd|(|S|(|O|)|)| |#else| |odd|(|O|)|↵|#fun| |main|(||)| |#=|→|foo|(||)|↵|bar|(||)|←|↵|main|(||)|
//│ Parsed: {class True {}; class False {}; class S(s,) {}; class O {}; fun odd = (x,) => {if x is ‹(O) then False; (S(s,)) then even(s,)›}; fun even = (x,) => {if x is ‹(O) then True; (S(s,)) then odd(s,)›}; fun foo = () => odd(if (>(10,)(0,)) then S(O,) else O,); fun bar = () => if (>(10,)(0,)) then odd(S(O,),) else odd(O,); fun main = () => {foo(); bar()}; main()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x%0 of -- #x
//│   O => let x%1 = False() -- #x
//│     in jump j%0(x%1) -- #x
//│   S => let x%2 = x%0.s -- #x
//│     in let* (x%3) = even(x%2) -- #x
//│       in jump j%0(x%3) -- #x
//│ )
//│ Def(1, @join j%0, [x%4], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%4
//│ )
//│ Def(2, even, [x%5], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x%5 of -- #x
//│   O => let x%6 = True() -- #x
//│     in jump j%1(x%6) -- #x
//│   S => let x%7 = x%5.s -- #x
//│     in let* (x%8) = odd(x%7) -- #x
//│       in jump j%1(x%8) -- #x
//│ )
//│ Def(3, @join j%1, [x%9], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%9
//│ )
//│ Def(4, foo, [], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%10 = >(10,0) -- #x
//│   in if x%10 -- #x
//│     true => let x%11 = O() -- #x
//│       in let x%12 = S(x%11) -- #x
//│         in jump j%2(x%12) -- #x
//│     false => let x%13 = O() -- #x
//│       in jump j%2(x%13) -- #x
//│ )
//│ Def(5, @join j%2, [x%14], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%15) = odd(x%14) -- #x
//│   in x%15
//│ )
//│ Def(6, bar, [], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%16 = >(10,0) -- #x
//│   in if x%16 -- #x
//│     true => let x%17 = O() -- #x
//│       in let x%18 = S(x%17) -- #x
//│         in let* (x%19) = odd(x%18) -- #x
//│           in jump j%3(x%19) -- #x
//│     false => let x%20 = O() -- #x
//│       in let* (x%21) = odd(x%20) -- #x
//│         in jump j%3(x%21) -- #x
//│ )
//│ Def(7, @join j%3, [x%22], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%22
//│ )
//│ Def(8, main, [], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%23) = foo() -- #x
//│   in let* (x%24) = bar() -- #x
//│     in x%24
//│ )
//│ },
//│ let* (x%25) = main() -- #x
//│   in x%25)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0], [{<EDestruct@odd:case x%0 of ...>,<EDirect@odd:case x%0 of ...>,<ESelect(s)@odd:let x%2 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(S))],[Some(ICtor(O))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(4),
//│ 1, 
//│ case x%0 of -- #x
//│   O => let x%1 = False() -- #x
//│     in x%1
//│   S => let x%2 = x%0.s -- #x
//│     in let* (x%3) = even(x%2) -- #x
//│       in x%3
//│ )
//│ Def(2, even, [x%5], [{<EDestruct@even:case x%5 of ...>,<EDirect@even:case x%5 of ...>,<ESelect(s)@even:let x%7 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: Some(4),
//│ 1, 
//│ case x%5 of -- #x
//│   O => let x%6 = True() -- #x
//│     in x%6
//│   S => let x%7 = x%5.s -- #x
//│     in let* (x%8) = odd(x%7) -- #x
//│       in x%8
//│ )
//│ Def(4, foo, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let x%10 = >(10,0) -- #x
//│   in if x%10 -- #x
//│     true => let x%11 = O() -- #x
//│       in let x%12 = S(x%11) -- #x
//│         in jump j%2(x%12) -- #x
//│     false => let x%13 = O() -- #x
//│       in jump j%2(x%13) -- #x
//│ )
//│ Def(5, @join j%2, [x%14], [{<EDirect@j%2:let* (x%15) = odd ...>,<EIndirectDestruct@j%2:let* (x%15) = odd ...>,<ESelect(s)@odd:let x%2 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(S))],[Some(ICtor(O))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%15) = odd(x%14) -- #x
//│   in x%15
//│ )
//│ Def(6, bar, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let x%16 = >(10,0) -- #x
//│   in if x%16 -- #x
//│     true => let x%17 = O() -- #x
//│       in let x%18 = S(x%17) -- #x
//│         in let* (x%19) = odd(x%18) -- #x
//│           in x%19
//│     false => let x%20 = O() -- #x
//│       in let* (x%21) = odd(x%20) -- #x
//│         in x%21
//│ )
//│ Def(8, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%23) = foo() -- #x
//│   in let* (x%24) = bar() -- #x
//│     in x%24
//│ )
//│ },
//│ let* (x%25) = main() -- #x
//│   in x%25)
//│ 
//│ Interpreted ------------------------------
//│ True()
//│ 
//│ 
//│ 
//│ Interpreted ------------------------------
//│ True()
//│ 
//│ 
//│ Fuel used: 1

:GraphInterp
:GraphOpt
class True
class False
class A()
class B(b)
fun aaa() =
  let m = 1
  let n = 2
  let p = 3
  let q = 4
  m + n - p + q
fun bbb() =
  let x = aaa()
  x * 100 + 4
fun not(x) =
  if x then False else True
fun foo(x) =
  if x then A else B(foo(not(x)))
fun main(flag) =
  let x = foo(flag)
  if x is
    A then aaa()
    B(b1) then bbb()
main(False)
//│ |#class| |True|↵|#class| |False|↵|#class| |A|(||)|↵|#class| |B|(|b|)|↵|#fun| |aaa|(||)| |#=|→|#let| |m| |#=| |1|↵|#let| |n| |#=| |2|↵|#let| |p| |#=| |3|↵|#let| |q| |#=| |4|↵|m| |+| |n| |-| |p| |+| |q|←|↵|#fun| |bbb|(||)| |#=|→|#let| |x| |#=| |aaa|(||)|↵|x| |*| |100| |+| |4|←|↵|#fun| |not|(|x|)| |#=|→|#if| |x| |#then| |False| |#else| |True|←|↵|#fun| |foo|(|x|)| |#=|→|#if| |x| |#then| |A| |#else| |B|(|foo|(|not|(|x|)|)|)|←|↵|#fun| |main|(|flag|)| |#=|→|#let| |x| |#=| |foo|(|flag|)|↵|#if| |x| |is|→|A| |#then| |aaa|(||)|↵|B|(|b1|)| |#then| |bbb|(||)|←|←|↵|main|(|False|)|
//│ Parsed: {class True {}; class False {}; class A() {}; class B(b,) {}; fun aaa = () => {let m = 1; let n = 2; let p = 3; let q = 4; +(-(+(m,)(n,),)(p,),)(q,)}; fun bbb = () => {let x = aaa(); +(*(x,)(100,),)(4,)}; fun not = (x,) => {if (x) then False else True}; fun foo = (x,) => {if (x) then A else B(foo(not(x,),),)}; fun main = (flag,) => {let x = foo(flag,); if x is ‹(A) then aaa(); (B(b1,)) then bbb()›}; main(False,)}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(0, aaa, [], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%0 = 1 -- #x
//│   in let x%1 = 2 -- #x
//│     in let x%2 = 3 -- #x
//│       in let x%3 = 4 -- #x
//│         in let x%4 = +(x%0,x%1) -- #x
//│           in let x%5 = -(x%4,x%2) -- #x
//│             in let x%6 = +(x%5,x%3) -- #x
//│               in x%6
//│ )
//│ Def(1, bbb, [], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%7) = aaa() -- #x
//│   in let x%8 = *(x%7,100) -- #x
//│     in let x%9 = +(x%8,4) -- #x
//│       in x%9
//│ )
//│ Def(2, not, [x%10], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x%10 -- #x
//│   true => let x%11 = False() -- #x
//│     in jump j%0(x%11) -- #x
//│   false => let x%12 = True() -- #x
//│     in jump j%0(x%12) -- #x
//│ )
//│ Def(3, @join j%0, [x%13], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%13
//│ )
//│ Def(4, foo, [x%14], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x%14 -- #x
//│   true => let x%15 = A() -- #x
//│     in jump j%1(x%15) -- #x
//│   false => let* (x%16) = not(x%14) -- #x
//│     in let* (x%17) = foo(x%16) -- #x
//│       in let x%18 = B(x%17) -- #x
//│         in jump j%1(x%18) -- #x
//│ )
//│ Def(5, @join j%1, [x%19], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%19
//│ )
//│ Def(6, main, [flag%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%20) = foo(flag%0) -- #x
//│   in case x%20 of -- #x
//│     A => let* (x%21) = aaa() -- #x
//│       in jump j%2(x%21) -- #x
//│     B => let x%22 = x%20.b -- #x
//│       in let* (x%23) = bbb() -- #x
//│         in jump j%2(x%23) -- #x
//│ )
//│ Def(7, @join j%2, [x%24], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%24
//│ )
//│ },
//│ let x%25 = False() -- #x
//│   in let* (x%26) = main(x%25) -- #x
//│     in x%26)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(0, aaa, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%4 = +(1,2) -- #x
//│   in let x%5 = -(x%4,3) -- #x
//│     in let x%6 = +(x%5,4) -- #x
//│       in x%6
//│ )
//│ Def(1, bbb, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%7) = aaa() -- #x
//│   in let x%8 = *(x%7,100) -- #x
//│     in let x%9 = +(x%8,4) -- #x
//│       in x%9
//│ )
//│ Def(2, not, [x%10], [{<EDestruct@not:if x%10 ...>,<EDirect@not:if x%10 ...>}],
//│ S: None,
//│ I: [[Some(ICtor(False))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ if x%10 -- #x
//│   true => let x%11 = False() -- #x
//│     in x%11
//│   false => let x%12 = True() -- #x
//│     in x%12
//│ )
//│ Def(4, foo, [x%14], [{<EDestruct@foo:if x%14 ...>,<EDirect@foo:if x%14 ...>,<EDirect@foo:let* (x%16) = not ...>,<EIndirectDestruct@foo:let* (x%16) = not ...>}],
//│ S: None,
//│ I: [[Some(IMix(ICtor(False),ICtor(True)))]],
//│ R: [Some(IMix(ICtor(A),ICtor(B)))],
//│ Rec: Some(1),
//│ 1, 
//│ if x%14 -- #x
//│   true => let x%15 = A() -- #x
//│     in x%15
//│   false => let* (x%16) = not(x%14) -- #x
//│     in let* (x%17) = foo(x%16) -- #x
//│       in let x%18 = B(x%17) -- #x
//│         in x%18
//│ )
//│ Def(6, main, [flag%0], [{<EDirect@main:let* (x%20) = foo ...>,<EIndirectDestruct@main:let* (x%20) = foo ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%20) = foo(flag%0) -- #x
//│   in case x%20 of -- #x
//│     A => let* (x%21) = aaa() -- #x
//│       in x%21
//│     B => let* (x%23) = bbb() -- #x
//│       in x%23
//│ )
//│ },
//│ let x%25 = False() -- #x
//│   in let* (x%26) = main(x%25) -- #x
//│     in x%26)
//│ 
//│ Interpreted ------------------------------
//│ 404
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(0, aaa, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%4 = +(1,2) -- #x
//│   in let x%5 = -(x%4,3) -- #x
//│     in let x%6 = +(x%5,4) -- #x
//│       in x%6
//│ )
//│ Def(1, bbb, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%7) = aaa() -- #x
//│   in let x%8 = *(x%7,100) -- #x
//│     in let x%9 = +(x%8,4) -- #x
//│       in x%9
//│ )
//│ Def(4, foo, [x%14], [{<EDestruct@foo:if x%14 ...>,<EDirect@foo:if x%14 ...>}],
//│ S: None,
//│ I: [[Some(ICtor(True))]],
//│ R: [Some(IMix(ICtor(A),ICtor(B)))],
//│ Rec: Some(1),
//│ 1, 
//│ if x%14 -- #x
//│   true => let x%15 = A() -- #x
//│     in x%15
//│   false => let x%12 = True() -- #x
//│     in let* (x%17) = foo(x%12) -- #x
//│       in let x%18 = B(x%17) -- #x
//│         in x%18
//│ )
//│ Def(6, main, [flag%0], [{<EDirect@main:let* (x%20) = foo ...>,<EIndirectDestruct@main:let* (x%20) = foo ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%20) = foo(flag%0) -- #x
//│   in case x%20 of -- #x
//│     A => let* (x%21) = aaa() -- #x
//│       in x%21
//│     B => let* (x%23) = bbb() -- #x
//│       in x%23
//│ )
//│ },
//│ let x%25 = False() -- #x
//│   in let* (x%26) = main(x%25) -- #x
//│     in x%26)
//│ 
//│ 
//│ Interpreted ------------------------------
//│ 404
//│ 
//│ 
//│ Fuel used: 2


:GraphInterp
:GraphOpt
class True
class False
class Cons(h, t)
class Nil
class Some(x)
class None
fun head_opt(l) =
  if l is
    Nil then None
    Cons(h, t) then Some(h)
fun is_none(o) =
  if o is
    None then True
    Some(x) then False
fun is_empty(l) =
  is_none(head_opt(l))
fun main() =
  is_empty(Cons(1, Cons(2, Nil)))
main()
//│ |#class| |True|↵|#class| |False|↵|#class| |Cons|(|h|,| |t|)|↵|#class| |Nil|↵|#class| |Some|(|x|)|↵|#class| |None|↵|#fun| |head_opt|(|l|)| |#=|→|#if| |l| |is|→|Nil| |#then| |None|↵|Cons|(|h|,| |t|)| |#then| |Some|(|h|)|←|←|↵|#fun| |is_none|(|o|)| |#=|→|#if| |o| |is|→|None| |#then| |True|↵|Some|(|x|)| |#then| |False|←|←|↵|#fun| |is_empty|(|l|)| |#=|→|is_none|(|head_opt|(|l|)|)|←|↵|#fun| |main|(||)| |#=|→|is_empty|(|Cons|(|1|,| |Cons|(|2|,| |Nil|)|)|)|←|↵|main|(||)|
//│ Parsed: {class True {}; class False {}; class Cons(h, t,) {}; class Nil {}; class Some(x,) {}; class None {}; fun head_opt = (l,) => {if l is ‹(Nil) then None; (Cons(h, t,)) then Some(h,)›}; fun is_none = (o,) => {if o is ‹(None) then True; (Some(x,)) then False›}; fun is_empty = (l,) => {is_none(head_opt(l,),)}; fun main = () => {is_empty(Cons(1, Cons(2, Nil,),),)}; main()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(0, head_opt, [l%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case l%0 of -- #x
//│   Nil => let x%0 = None() -- #x
//│     in jump j%0(x%0) -- #x
//│   Cons => let x%1 = l%0.t -- #x
//│     in let x%2 = l%0.h -- #x
//│       in let x%3 = Some(x%2) -- #x
//│         in jump j%0(x%3) -- #x
//│ )
//│ Def(1, @join j%0, [x%4], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%4
//│ )
//│ Def(2, is_none, [o%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case o%0 of -- #x
//│   None => let x%5 = True() -- #x
//│     in jump j%1(x%5) -- #x
//│   Some => let x%6 = o%0.x -- #x
//│     in let x%7 = False() -- #x
//│       in jump j%1(x%7) -- #x
//│ )
//│ Def(3, @join j%1, [x%8], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%8
//│ )
//│ Def(4, is_empty, [l%1], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%9) = head_opt(l%1) -- #x
//│   in let* (x%10) = is_none(x%9) -- #x
//│     in x%10
//│ )
//│ Def(5, main, [], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%11 = Nil() -- #x
//│   in let x%12 = Cons(2,x%11) -- #x
//│     in let x%13 = Cons(1,x%12) -- #x
//│       in let* (x%14) = is_empty(x%13) -- #x
//│         in x%14
//│ )
//│ },
//│ let* (x%15) = main() -- #x
//│   in x%15)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(0, head_opt, [l%0], [{<EDestruct@head_opt:case l%0 of ...>,<EDirect@head_opt:case l%0 of ...>,<ESelect(h)@head_opt:let x%2 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(None),ICtor(Some)))],
//│ Rec: None,
//│ 1, 
//│ case l%0 of -- #x
//│   Nil => let x%0 = None() -- #x
//│     in x%0
//│   Cons => let x%2 = l%0.h -- #x
//│     in let x%3 = Some(x%2) -- #x
//│       in x%3
//│ )
//│ Def(2, is_none, [o%0], [{<EDestruct@is_none:case o%0 of ...>,<EDirect@is_none:case o%0 of ...>}],
//│ S: None,
//│ I: [[Some(IMix(ICtor(None),ICtor(Some)))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ case o%0 of -- #x
//│   None => let x%5 = True() -- #x
//│     in x%5
//│   Some => let x%7 = False() -- #x
//│     in x%7
//│ )
//│ Def(4, is_empty, [l%1], [{<EDirect@is_empty:let* (x%9) = head_opt ...>,<EIndirectDestruct@is_empty:let* (x%9) = head_opt ...>,<ESelect(h)@head_opt:let x%2 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(Cons))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%9) = head_opt(l%1) -- #x
//│   in let* (x%10) = is_none(x%9) -- #x
//│     in x%10
//│ )
//│ Def(5, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let x%11 = Nil() -- #x
//│   in let x%12 = Cons(2,x%11) -- #x
//│     in let x%13 = Cons(1,x%12) -- #x
//│       in let* (x%14) = is_empty(x%13) -- #x
//│         in x%14
//│ )
//│ },
//│ let* (x%15) = main() -- #x
//│   in x%15)
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(2, is_none, [o%0], [{<EDestruct@is_none:case o%0 of ...>,<EDirect@is_none:case o%0 of ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ case o%0 of -- #x
//│   None => let x%5 = True() -- #x
//│     in x%5
//│   Some => let x%7 = False() -- #x
//│     in x%7
//│ )
//│ Def(4, is_empty, [l%1], [{<EDestruct@is_empty:case l%1 of ...>,<EDirect@is_empty:case l%1 of ...>,<ESelect(h)@is_empty:let x%19 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(Cons))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ case l%1 of -- #x
//│   Cons => let x%19 = l%1.h -- #x
//│     in let x%3 = Some(x%19) -- #x
//│       in jump is_empty$M%0(x%3) -- #x
//│   Nil => let x%0 = None() -- #x
//│     in jump is_empty$M%0(x%0) -- #x
//│ )
//│ Def(5, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let x%11 = Nil() -- #x
//│   in let x%12 = Cons(2,x%11) -- #x
//│     in let x%13 = Cons(1,x%12) -- #x
//│       in let* (x%14) = is_empty(x%13) -- #x
//│         in x%14
//│ )
//│ Def(9, @join is_empty$M%0, [x%9], [{<EDirect@is_empty$M%0:let* (x%10) = is_none ...>,<EIndirectDestruct@is_empty$M%0:let* (x%10) = is_none ...>}],
//│ S: None,
//│ I: [[Some(ICtor(Some))],[Some(ICtor(None))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%10) = is_none(x%9) -- #x
//│   in x%10
//│ )
//│ },
//│ let* (x%15) = main() -- #x
//│   in x%15)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(5, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let x%11 = Nil() -- #x
//│   in let* (x%14) = is_empty$D%0$S%0(1) -- #x
//│     in x%14
//│ )
//│ Def(9, @join is_empty$M%0, [x%9], [{<EDestruct@is_empty$M%0:case x%9 of ...>,<EDirect@is_empty$M%0:case x%9 of ...>}],
//│ S: None,
//│ I: [[Some(ICtor(Some))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ case x%9 of -- #x
//│   Some => let x%7 = False() -- #x
//│     in x%7
//│   None => let x%5 = True() -- #x
//│     in x%5
//│ )
//│ Def(18, is_empty$D%0$S%0, [l%1_h], [{<EDirect@is_empty$D%0$S%0:let x%3 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let x%3 = Some(l%1_h) -- #x
//│   in jump is_empty$M%0(x%3) -- #x
//│ )
//│ },
//│ let* (x%15) = main() -- #x
//│   in x%15)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(5, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(ICtor(False))],
//│ Rec: None,
//│ 1, 
//│ let x%7 = False() -- #x
//│   in x%7
//│ )
//│ },
//│ let* (x%15) = main() -- #x
//│   in x%15)
//│ 
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ Fuel used: 4

:GraphInterp
:GraphOpt
class True
class False
class Cons(h, t)
class Nil
class Some(x)
class None
fun mk_list(n) =
  if n == 0 then Nil else Cons(n, mk_list(n - 1))
fun head_opt(l) =
  if l is
    Nil then None
    Cons(h, t) then Some(h)
fun is_none(o) =
  if o is
    None then True
    Some(x) then False
fun is_empty(l) =
  is_none(head_opt(l))
fun main() =
  is_empty(mk_list(10))
main()
//│ |#class| |True|↵|#class| |False|↵|#class| |Cons|(|h|,| |t|)|↵|#class| |Nil|↵|#class| |Some|(|x|)|↵|#class| |None|↵|#fun| |mk_list|(|n|)| |#=|→|#if| |n| |==| |0| |#then| |Nil| |#else| |Cons|(|n|,| |mk_list|(|n| |-| |1|)|)|←|↵|#fun| |head_opt|(|l|)| |#=|→|#if| |l| |is|→|Nil| |#then| |None|↵|Cons|(|h|,| |t|)| |#then| |Some|(|h|)|←|←|↵|#fun| |is_none|(|o|)| |#=|→|#if| |o| |is|→|None| |#then| |True|↵|Some|(|x|)| |#then| |False|←|←|↵|#fun| |is_empty|(|l|)| |#=|→|is_none|(|head_opt|(|l|)|)|←|↵|#fun| |main|(||)| |#=|→|is_empty|(|mk_list|(|10|)|)|←|↵|main|(||)|
//│ Parsed: {class True {}; class False {}; class Cons(h, t,) {}; class Nil {}; class Some(x,) {}; class None {}; fun mk_list = (n,) => {if (==(n,)(0,)) then Nil else Cons(n, mk_list(-(n,)(1,),),)}; fun head_opt = (l,) => {if l is ‹(Nil) then None; (Cons(h, t,)) then Some(h,)›}; fun is_none = (o,) => {if o is ‹(None) then True; (Some(x,)) then False›}; fun is_empty = (l,) => {is_none(head_opt(l,),)}; fun main = () => {is_empty(mk_list(10,),)}; main()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(0, mk_list, [n%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%0 = ==(n%0,0) -- #x
//│   in if x%0 -- #x
//│     true => let x%1 = Nil() -- #x
//│       in jump j%0(x%1) -- #x
//│     false => let x%2 = -(n%0,1) -- #x
//│       in let* (x%3) = mk_list(x%2) -- #x
//│         in let x%4 = Cons(n%0,x%3) -- #x
//│           in jump j%0(x%4) -- #x
//│ )
//│ Def(1, @join j%0, [x%5], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%5
//│ )
//│ Def(2, head_opt, [l%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case l%0 of -- #x
//│   Nil => let x%6 = None() -- #x
//│     in jump j%1(x%6) -- #x
//│   Cons => let x%7 = l%0.t -- #x
//│     in let x%8 = l%0.h -- #x
//│       in let x%9 = Some(x%8) -- #x
//│         in jump j%1(x%9) -- #x
//│ )
//│ Def(3, @join j%1, [x%10], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%10
//│ )
//│ Def(4, is_none, [o%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case o%0 of -- #x
//│   None => let x%11 = True() -- #x
//│     in jump j%2(x%11) -- #x
//│   Some => let x%12 = o%0.x -- #x
//│     in let x%13 = False() -- #x
//│       in jump j%2(x%13) -- #x
//│ )
//│ Def(5, @join j%2, [x%14], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%14
//│ )
//│ Def(6, is_empty, [l%1], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%15) = head_opt(l%1) -- #x
//│   in let* (x%16) = is_none(x%15) -- #x
//│     in x%16
//│ )
//│ Def(7, main, [], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%17) = mk_list(10) -- #x
//│   in let* (x%18) = is_empty(x%17) -- #x
//│     in x%18
//│ )
//│ },
//│ let* (x%19) = main() -- #x
//│   in x%19)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(0, mk_list, [n%0], [{<EDirect@mk_list:let x%0 = ...>,<EDirect@mk_list:let x%2 = ...>,<EDirect@mk_list:let x%4 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(Cons),ICtor(Nil)))],
//│ Rec: Some(4),
//│ 1, 
//│ let x%0 = ==(n%0,0) -- #x
//│   in if x%0 -- #x
//│     true => let x%1 = Nil() -- #x
//│       in x%1
//│     false => let x%2 = -(n%0,1) -- #x
//│       in let* (x%3) = mk_list(x%2) -- #x
//│         in let x%4 = Cons(n%0,x%3) -- #x
//│           in x%4
//│ )
//│ Def(2, head_opt, [l%0], [{<EDestruct@head_opt:case l%0 of ...>,<EDirect@head_opt:case l%0 of ...>,<ESelect(h)@head_opt:let x%8 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(None),ICtor(Some)))],
//│ Rec: None,
//│ 1, 
//│ case l%0 of -- #x
//│   Nil => let x%6 = None() -- #x
//│     in x%6
//│   Cons => let x%8 = l%0.h -- #x
//│     in let x%9 = Some(x%8) -- #x
//│       in x%9
//│ )
//│ Def(4, is_none, [o%0], [{<EDestruct@is_none:case o%0 of ...>,<EDirect@is_none:case o%0 of ...>}],
//│ S: None,
//│ I: [[Some(IMix(ICtor(None),ICtor(Some)))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ case o%0 of -- #x
//│   None => let x%11 = True() -- #x
//│     in x%11
//│   Some => let x%13 = False() -- #x
//│     in x%13
//│ )
//│ Def(6, is_empty, [l%1], [{<EDirect@is_empty:let* (x%15) = head_opt ...>,<EIndirectDestruct@is_empty:let* (x%15) = head_opt ...>,<ESelect(h)@head_opt:let x%8 = ...>}],
//│ S: None,
//│ I: [[Some(IMix(ICtor(Cons),ICtor(Nil)))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%15) = head_opt(l%1) -- #x
//│   in let* (x%16) = is_none(x%15) -- #x
//│     in x%16
//│ )
//│ Def(7, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%17) = mk_list(10) -- #x
//│   in let* (x%18) = is_empty(x%17) -- #x
//│     in x%18
//│ )
//│ },
//│ let* (x%19) = main() -- #x
//│   in x%19)
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(0, mk_list, [n%0], [{<EDirect@mk_list:let x%0 = ...>,<EDirect@mk_list:let x%2 = ...>,<EDirect@mk_list:let x%4 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(Cons),ICtor(Nil)))],
//│ Rec: Some(4),
//│ 1, 
//│ let x%0 = ==(n%0,0) -- #x
//│   in if x%0 -- #x
//│     true => let x%1 = Nil() -- #x
//│       in x%1
//│     false => let x%2 = -(n%0,1) -- #x
//│       in let* (x%3) = mk_list(x%2) -- #x
//│         in let x%4 = Cons(n%0,x%3) -- #x
//│           in x%4
//│ )
//│ Def(4, is_none, [o%0], [{<EDestruct@is_none:case o%0 of ...>,<EDirect@is_none:case o%0 of ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ case o%0 of -- #x
//│   None => let x%11 = True() -- #x
//│     in x%11
//│   Some => let x%13 = False() -- #x
//│     in x%13
//│ )
//│ Def(6, is_empty, [l%1], [{<EDestruct@is_empty:case l%1 of ...>,<EDirect@is_empty:case l%1 of ...>,<ESelect(h)@is_empty:let x%23 = ...>}],
//│ S: None,
//│ I: [[Some(IMix(ICtor(Cons),ICtor(Nil)))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ case l%1 of -- #x
//│   Cons => let x%23 = l%1.h -- #x
//│     in let x%9 = Some(x%23) -- #x
//│       in jump is_empty$M%0(x%9) -- #x
//│   Nil => let x%6 = None() -- #x
//│     in jump is_empty$M%0(x%6) -- #x
//│ )
//│ Def(7, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%17) = mk_list(10) -- #x
//│   in let* (x%18) = is_empty(x%17) -- #x
//│     in x%18
//│ )
//│ Def(14, @join is_empty$M%0, [x%15], [{<EDirect@is_empty$M%0:let* (x%16) = is_none ...>,<EIndirectDestruct@is_empty$M%0:let* (x%16) = is_none ...>}],
//│ S: None,
//│ I: [[Some(ICtor(Some))],[Some(ICtor(None))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%16) = is_none(x%15) -- #x
//│   in x%16
//│ )
//│ },
//│ let* (x%19) = main() -- #x
//│   in x%19)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(0, mk_list, [n%0], [{<EDirect@mk_list:let x%0 = ...>,<EDirect@mk_list:let x%2 = ...>,<EDirect@mk_list:let x%4 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(Cons),ICtor(Nil)))],
//│ Rec: Some(3),
//│ 1, 
//│ let x%0 = ==(n%0,0) -- #x
//│   in if x%0 -- #x
//│     true => let x%1 = Nil() -- #x
//│       in x%1
//│     false => let x%2 = -(n%0,1) -- #x
//│       in let* (x%3) = mk_list(x%2) -- #x
//│         in let x%4 = Cons(n%0,x%3) -- #x
//│           in x%4
//│ )
//│ Def(6, is_empty, [l%1], [{<EDestruct@is_empty:case l%1 of ...>,<EDirect@is_empty:case l%1 of ...>,<ESelect(h)@is_empty:let x%23 = ...>}],
//│ S: None,
//│ I: [[Some(IMix(ICtor(Cons),ICtor(Nil)))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ case l%1 of -- #x
//│   Cons => let x%23 = l%1.h -- #x
//│     in let x%9 = Some(x%23) -- #x
//│       in jump is_empty$M%0(x%9) -- #x
//│   Nil => let x%6 = None() -- #x
//│     in jump is_empty$M%0(x%6) -- #x
//│ )
//│ Def(7, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%17) = mk_list(10) -- #x
//│   in let* (x%18) = is_empty(x%17) -- #x
//│     in x%18
//│ )
//│ Def(14, @join is_empty$M%0, [x%15], [{<EDestruct@is_empty$M%0:case x%15 of ...>,<EDirect@is_empty$M%0:case x%15 of ...>}],
//│ S: None,
//│ I: [[Some(ICtor(Some))],[Some(ICtor(None))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ case x%15 of -- #x
//│   Some => let x%13 = False() -- #x
//│     in x%13
//│   None => let x%11 = True() -- #x
//│     in x%11
//│ )
//│ },
//│ let* (x%19) = main() -- #x
//│   in x%19)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(0, mk_list, [n%0], [{<EDirect@mk_list:let x%0 = ...>,<EDirect@mk_list:let x%2 = ...>,<EDirect@mk_list:let x%4 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(Cons),ICtor(Nil)))],
//│ Rec: Some(2),
//│ 1, 
//│ let x%0 = ==(n%0,0) -- #x
//│   in if x%0 -- #x
//│     true => let x%1 = Nil() -- #x
//│       in x%1
//│     false => let x%2 = -(n%0,1) -- #x
//│       in let* (x%3) = mk_list(x%2) -- #x
//│         in let x%4 = Cons(n%0,x%3) -- #x
//│           in x%4
//│ )
//│ Def(6, is_empty, [l%1], [{<EDestruct@is_empty:case l%1 of ...>,<EDirect@is_empty:case l%1 of ...>}],
//│ S: None,
//│ I: [[Some(IMix(ICtor(Cons),ICtor(Nil)))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ case l%1 of -- #x
//│   Cons => let x%13 = False() -- #x
//│     in x%13
//│   Nil => let x%11 = True() -- #x
//│     in x%11
//│ )
//│ Def(7, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%17) = mk_list(10) -- #x
//│   in let* (x%18) = is_empty(x%17) -- #x
//│     in x%18
//│ )
//│ },
//│ let* (x%19) = main() -- #x
//│   in x%19)
//│ 
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ Fuel used: 4

:GraphInterp
:GraphOpt
class True
class False
class Cons(h, t)
class Nil
class Some(x)
class None
fun mk_list(n) =
  if n == 0 then Nil else Cons(n, mk_list(n - 1))
fun last_opt(l) =
  if l is
    Nil then None
    Cons(h, t) then
      if t is
        Nil then Some(h)
        Cons(h2, t2) then last_opt(t)
fun main() =
  last_opt(mk_list(10))
main()
//│ |#class| |True|↵|#class| |False|↵|#class| |Cons|(|h|,| |t|)|↵|#class| |Nil|↵|#class| |Some|(|x|)|↵|#class| |None|↵|#fun| |mk_list|(|n|)| |#=|→|#if| |n| |==| |0| |#then| |Nil| |#else| |Cons|(|n|,| |mk_list|(|n| |-| |1|)|)|←|↵|#fun| |last_opt|(|l|)| |#=|→|#if| |l| |is|→|Nil| |#then| |None|↵|Cons|(|h|,| |t|)| |#then|→|#if| |t| |is|→|Nil| |#then| |Some|(|h|)|↵|Cons|(|h2|,| |t2|)| |#then| |last_opt|(|t|)|←|←|←|←|↵|#fun| |main|(||)| |#=|→|last_opt|(|mk_list|(|10|)|)|←|↵|main|(||)|
//│ Parsed: {class True {}; class False {}; class Cons(h, t,) {}; class Nil {}; class Some(x,) {}; class None {}; fun mk_list = (n,) => {if (==(n,)(0,)) then Nil else Cons(n, mk_list(-(n,)(1,),),)}; fun last_opt = (l,) => {if l is ‹(Nil) then None; (Cons(h, t,)) then {if t is ‹(Nil) then Some(h,); (Cons(h2, t2,)) then last_opt(t,)›}›}; fun main = () => {last_opt(mk_list(10,),)}; main()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(0, mk_list, [n%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%0 = ==(n%0,0) -- #x
//│   in if x%0 -- #x
//│     true => let x%1 = Nil() -- #x
//│       in jump j%0(x%1) -- #x
//│     false => let x%2 = -(n%0,1) -- #x
//│       in let* (x%3) = mk_list(x%2) -- #x
//│         in let x%4 = Cons(n%0,x%3) -- #x
//│           in jump j%0(x%4) -- #x
//│ )
//│ Def(1, @join j%0, [x%5], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%5
//│ )
//│ Def(2, last_opt, [l%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case l%0 of -- #x
//│   Nil => let x%6 = None() -- #x
//│     in jump j%1(x%6) -- #x
//│   Cons => let x%7 = l%0.t -- #x
//│     in let x%8 = l%0.h -- #x
//│       in case x%7 of -- #x
//│         Nil => let x%9 = Some(x%8) -- #x
//│           in jump j%2(x%9) -- #x
//│         Cons => let x%10 = x%7.t -- #x
//│           in let x%11 = x%7.h -- #x
//│             in let* (x%12) = last_opt(x%7) -- #x
//│               in jump j%2(x%12) -- #x
//│ )
//│ Def(3, @join j%2, [x%13], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j%1(x%13) -- #x
//│ )
//│ Def(4, @join j%1, [x%14], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%14
//│ )
//│ Def(5, main, [], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%15) = mk_list(10) -- #x
//│   in let* (x%16) = last_opt(x%15) -- #x
//│     in x%16
//│ )
//│ },
//│ let* (x%17) = main() -- #x
//│   in x%17)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(0, mk_list, [n%0], [{<EDirect@mk_list:let x%0 = ...>,<EDirect@mk_list:let x%2 = ...>,<EDirect@mk_list:let x%4 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(Cons),ICtor(Nil)))],
//│ Rec: Some(1),
//│ 1, 
//│ let x%0 = ==(n%0,0) -- #x
//│   in if x%0 -- #x
//│     true => let x%1 = Nil() -- #x
//│       in x%1
//│     false => let x%2 = -(n%0,1) -- #x
//│       in let* (x%3) = mk_list(x%2) -- #x
//│         in let x%4 = Cons(n%0,x%3) -- #x
//│           in x%4
//│ )
//│ Def(2, last_opt, [l%0], [{<EDestruct@last_opt:case l%0 of ...>,<EDirect@last_opt:case l%0 of ...>,<ESelect(h)@last_opt:let x%8 = ...>,<ESelect(t)@last_opt:let x%7 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(Cons))],[Some(IMix(ICtor(Cons),ICtor(Nil)))]],
//│ R: [Some(IMix(ICtor(None),ICtor(Some)))],
//│ Rec: Some(2),
//│ 1, 
//│ case l%0 of -- #x
//│   Nil => let x%6 = None() -- #x
//│     in x%6
//│   Cons => let x%7 = l%0.t -- #x
//│     in let x%8 = l%0.h -- #x
//│       in case x%7 of -- #x
//│         Nil => let x%9 = Some(x%8) -- #x
//│           in x%9
//│         Cons => let* (x%12) = last_opt(x%7) -- #x
//│           in x%12
//│ )
//│ Def(5, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(None),ICtor(Some)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%15) = mk_list(10) -- #x
//│   in let* (x%16) = last_opt(x%15) -- #x
//│     in x%16
//│ )
//│ },
//│ let* (x%17) = main() -- #x
//│   in x%17)
//│ 
//│ Interpreted ------------------------------
//│ Some(1)
//│ 
//│ 
//│ 
//│ Interpreted ------------------------------
//│ Some(1)
//│ 
//│ 
//│ Fuel used: 1
