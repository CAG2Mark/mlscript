:NewParser
:ParseOnly

:GraphInterp
:GraphOpt
class True
class False
fun fib(n) = if n < 2 then n else fib(n-1) + fib(n-2)
fib(20)
//│ |#class| |True|↵|#class| |False|↵|#fun| |fib|(|n|)| |#=| |#if| |n| |<| |2| |#then| |n| |#else| |fib|(|n|-|1|)| |+| |fib|(|n|-|2|)|↵|fib|(|20|)|
//│ Parsed: {class True {}; class False {}; fun fib = (n,) => if (<(n,)(2,)) then n else +(fib(-(n,)(1,),),)(fib(-(n,)(2,),),); fib(20,)}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, True, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, False, (), Tup(), (), None, None, TypingUnit()), NuFunDef(None, fib, None, [], Lam(Tup(_: Var(n)), If(IfThen(App(App(Var(<), Tup(_: Var(n))), Tup(_: IntLit(2))), Var(n), Some(App(App(Var(+), Tup(_: App(Var(fib), Tup(_: App(App(Var(-), Tup(_: Var(n))), Tup(_: IntLit(1))))))), Tup(_: App(Var(fib), Tup(_: App(App(Var(-), Tup(_: Var(n))), Tup(_: IntLit(2))))))))))), App(Var(fib), Tup(_: IntLit(20))))
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, fib, [n%0], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let x%0 = <(n%0,2)
//│   in let join j%0(x%6) = x%6
//│     in if x%0
//│       true => jump j%0(n%0)
//│       false => let x%1 = -(n%0,1)
//│         in let* (x%2) = fib(x%1)
//│           in let x%3 = -(n%0,2)
//│             in let* (x%4) = fib(x%3)
//│               in let x%5 = +(x%2,x%4)
//│                 in jump j%0(x%5)
//│ )
//│ },
//│ let* (x%7) = fib(20)
//│   in x%7)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, fib, [n%0[-T]], [{EDirect}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let x%0[-DT] = <(n%0[-T],2)
//│   in if x%0[-DT]
//│     true => n%0[-T]
//│     false => let x%1[-T] = -(n%0[-T],1)
//│       in let* (x%2) = fib(x%1[-T])
//│         in let x%3[-T] = -(n%0[-T],2)
//│           in let* (x%4[-T]) = fib(x%3[-T])
//│             in let x%5[-T] = +(x%2,x%4[-T])
//│               in x%5[-T]
//│ )
//│ },
//│ let* (x%7) = fib(20)
//│   in x%7)
//│ 
//│ Interpreted ------------------------------
//│ 6765
//│ 
//│ 
//│ 
//│ Interpreted ------------------------------
//│ 6765
//│ 
//│ 
//│ Fuel used: 1

:GraphInterp
:GraphOpt
class True
class False
fun odd(x) = if x == 0 then False else even(x-1)
fun even(x) = if x == 0 then True else odd(x-1)
fun foo() = odd(10)
foo()
//│ |#class| |True|↵|#class| |False|↵|#fun| |odd|(|x|)| |#=| |#if| |x| |==| |0| |#then| |False| |#else| |even|(|x|-|1|)|↵|#fun| |even|(|x|)| |#=| |#if| |x| |==| |0| |#then| |True| |#else| |odd|(|x|-|1|)|↵|#fun| |foo|(||)| |#=| |odd|(|10|)|↵|foo|(||)|
//│ Parsed: {class True {}; class False {}; fun odd = (x,) => if (==(x,)(0,)) then False else even(-(x,)(1,),); fun even = (x,) => if (==(x,)(0,)) then True else odd(-(x,)(1,),); fun foo = () => odd(10,); foo()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, True, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, False, (), Tup(), (), None, None, TypingUnit()), NuFunDef(None, odd, None, [], Lam(Tup(_: Var(x)), If(IfThen(App(App(Var(==), Tup(_: Var(x))), Tup(_: IntLit(0))), Var(False), Some(App(Var(even), Tup(_: App(App(Var(-), Tup(_: Var(x))), Tup(_: IntLit(1))))))))), NuFunDef(None, even, None, [], Lam(Tup(_: Var(x)), If(IfThen(App(App(Var(==), Tup(_: Var(x))), Tup(_: IntLit(0))), Var(True), Some(App(Var(odd), Tup(_: App(App(Var(-), Tup(_: Var(x))), Tup(_: IntLit(1))))))))), NuFunDef(None, foo, None, [], Lam(Tup(), App(Var(odd), Tup(_: IntLit(10))))), App(Var(foo), Tup()))
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, odd, [x%0], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let x%1 = ==(x%0,0)
//│   in let join j%0(x%5) = x%5
//│     in if x%1
//│       true => let x%2 = False()
//│         in jump j%0(x%2)
//│       false => let x%3 = -(x%0,1)
//│         in let* (x%4) = even(x%3)
//│           in jump j%0(x%4)
//│ )
//│ Def(1, even, [x%6], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let x%7 = ==(x%6,0)
//│   in let join j%1(x%11) = x%11
//│     in if x%7
//│       true => let x%8 = True()
//│         in jump j%1(x%8)
//│       false => let x%9 = -(x%6,1)
//│         in let* (x%10) = odd(x%9)
//│           in jump j%1(x%10)
//│ )
//│ Def(2, foo, [], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let* (x%12) = odd(10)
//│   in x%12
//│ )
//│ },
//│ let* (x%13) = foo()
//│   in x%13)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, odd, [x%0[-T]], [{EDirect}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let x%1[-DT] = ==(x%0[-T],0)
//│   in if x%1[-DT]
//│     true => let x%2[+C(False)-T] = False()
//│       in x%2[+C(False)-T]
//│     false => let x%3[-T] = -(x%0[-T],1)
//│       in let* (x%4[+X(C(False)C(True))-T]) = even(x%3[-T])
//│         in x%4[+X(C(False)C(True))-T]
//│ )
//│ Def(1, even, [x%6[-T]], [{EDirect}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let x%7[-DT] = ==(x%6[-T],0)
//│   in if x%7[-DT]
//│     true => let x%8[+C(True)-T] = True()
//│       in x%8[+C(True)-T]
//│     false => let x%9[-T] = -(x%6[-T],1)
//│       in let* (x%10[+X(C(False)C(True))-T]) = odd(x%9[-T])
//│         in x%10[+X(C(False)C(True))-T]
//│ )
//│ Def(2, foo, [], [],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%12[+X(C(False)C(True))-T]) = odd(10)
//│   in x%12[+X(C(False)C(True))-T]
//│ )
//│ },
//│ let* (x%13) = foo()
//│   in x%13)
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ Fuel used: 1

:GraphInterp
:GraphOpt
class True
class False
class A
class B(b)
fun not(x) =
  if x then False else True
fun foo(x) =
  if x then A
       else B(foo(not(x)))
fun main() = foo(False)
main()
//│ |#class| |True|↵|#class| |False|↵|#class| |A|↵|#class| |B|(|b|)|↵|#fun| |not|(|x|)| |#=|→|#if| |x| |#then| |False| |#else| |True|←|↵|#fun| |foo|(|x|)| |#=|→|#if| |x| |#then| |A|→|#else| |B|(|foo|(|not|(|x|)|)|)|←|←|↵|#fun| |main|(||)| |#=| |foo|(|False|)|↵|main|(||)|
//│ Parsed: {class True {}; class False {}; class A {}; class B(b,) {}; fun not = (x,) => {if (x) then False else True}; fun foo = (x,) => {if (x) then A else B(foo(not(x,),),)}; fun main = () => foo(False,); main()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, True, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, False, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, A, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, B, (), Tup(_: Var(b)), (), None, None, TypingUnit()), NuFunDef(None, not, None, [], Lam(Tup(_: Var(x)), Blk(...))), NuFunDef(None, foo, None, [], Lam(Tup(_: Var(x)), Blk(...))), NuFunDef(None, main, None, [], Lam(Tup(), App(Var(foo), Tup(_: Var(False))))), App(Var(main), Tup()))
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(0, not, [x%0], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let join j%0(x%3) = x%3
//│   in if x%0
//│     true => let x%1 = False()
//│       in jump j%0(x%1)
//│     false => let x%2 = True()
//│       in jump j%0(x%2)
//│ )
//│ Def(1, foo, [x%4], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let join j%1(x%9) = x%9
//│   in if x%4
//│     true => let x%5 = A()
//│       in jump j%1(x%5)
//│     false => let* (x%6) = not(x%4)
//│       in let* (x%7) = foo(x%6)
//│         in let x%8 = B(x%7)
//│           in jump j%1(x%8)
//│ )
//│ Def(2, main, [], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let x%10 = False()
//│   in let* (x%11) = foo(x%10)
//│     in x%11
//│ )
//│ },
//│ let* (x%12) = main()
//│   in x%12)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(0, not, [x%0[-DT]], [{EDestruct,EDirect}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ if x%0[-DT]
//│   true => let x%1[+C(False)-T] = False()
//│     in x%1[+C(False)-T]
//│   false => let x%2[+C(True)-T] = True()
//│     in x%2[+C(True)-T]
//│ )
//│ Def(1, foo, [x%4[-DTI]], [{EDestruct,EDirect,EIndirectDestruct}],
//│ S: None,
//│ I: [[Some(IMix(ICtor(False),ICtor(True)))],[Some(ICtor(False))]],
//│ [Some(IMix(ICtor(A),ICtor(B)))], 1, 
//│ if x%4[-DTI]
//│   true => let x%5[+C(A)-T] = A()
//│     in x%5[+C(A)-T]
//│   false => let* (x%6[+X(C(False)C(True))-TI]) = not(x%4[-DTI])
//│     in let* (x%7[+X(C(A)C(B))-T]) = foo(x%6[+X(C(False)C(True))-TI])
//│       in let x%8[+C(B)-T] = B(x%7[+X(C(A)C(B))-T])
//│         in x%8[+C(B)-T]
//│ )
//│ Def(2, main, [], [],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(A),ICtor(B)))], 1, 
//│ let x%10[+C(False)-TI] = False()
//│   in let* (x%11[+X(C(A)C(B))-T]) = foo(x%10[+C(False)-TI])
//│     in x%11[+X(C(A)C(B))-T]
//│ )
//│ },
//│ let* (x%12) = main()
//│   in x%12)
//│ 
//│ Interpreted ------------------------------
//│ B(A())
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(0, not, [x%0[-DT]], [{EDestruct,EDirect}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ if x%0[-DT]
//│   true => let x%1[+C(False)-T] = False()
//│     in x%1[+C(False)-T]
//│   false => let x%2[+C(True)-T] = True()
//│     in x%2[+C(True)-T]
//│ )
//│ Def(1, foo, [x%4[-DTI]], [{EDestruct,EDirect,EIndirectDestruct}],
//│ S: None,
//│ I: [[Some(IMix(ICtor(False),ICtor(True)))]],
//│ [Some(IMix(ICtor(A),ICtor(B)))], 1, 
//│ if x%4[-DTI]
//│   true => let x%5[+C(A)-T] = A()
//│     in x%5[+C(A)-T]
//│   false => let* (x%6[+X(C(False)C(True))-TI]) = not(x%4[-DTI])
//│     in let* (x%7[+X(C(A)C(B))-T]) = foo(x%6[+X(C(False)C(True))-TI])
//│       in let x%8[+C(B)-T] = B(x%7[+X(C(A)C(B))-T])
//│         in x%8[+C(B)-T]
//│ )
//│ Def(2, main, [], [],
//│ S: None,
//│ I: [],
//│ [Some(ICtor(B))], 1, 
//│ let x%10[+C(False)-TI] = False()
//│   in let* (x%11[+C(B)-T]) = foo$D%1(x%10[+C(False)-TI])
//│     in x%11[+C(B)-T]
//│ )
//│ Def(7, foo$D%1, [x%4], [{EDirect,EIndirectDestruct}],
//│ S: None,
//│ I: [[Some(ICtor(False))]],
//│ [Some(ICtor(B))], 1, 
//│ let* (x%6[+X(C(False)C(True))-TI]) = not(x%4[-DTI])
//│   in let* (x%7[+X(C(A)C(B))-T]) = foo(x%6[+X(C(False)C(True))-TI])
//│     in let x%8[+C(B)-T] = B(x%7[+X(C(A)C(B))-T])
//│       in x%8[+C(B)-T]
//│ )
//│ },
//│ let* (x%12[+C(B)]) = main()
//│   in x%12[+C(B)])
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(0, not, [x%0[-DT]], [{EDestruct,EDirect}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ if x%0[-DT]
//│   true => let x%1[+C(False)-T] = False()
//│     in x%1[+C(False)-T]
//│   false => let x%2[+C(True)-T] = True()
//│     in x%2[+C(True)-T]
//│ )
//│ Def(1, foo, [x%4[-DTI]], [{EDestruct,EDirect,EIndirectDestruct}],
//│ S: None,
//│ I: [[Some(IMix(ICtor(False),ICtor(True)))],[Some(ICtor(True))]],
//│ [Some(IMix(ICtor(A),ICtor(B)))], 1, 
//│ if x%4[-DTI]
//│   true => let x%5[+C(A)-T] = A()
//│     in x%5[+C(A)-T]
//│   false => let* (x%6[+C(True)-TI]) = not(x%4[-DTI])
//│     in let* (x%7[+X(C(A)C(B))-T]) = foo(x%6[+C(True)-TI])
//│       in let x%8[+C(B)-T] = B(x%7[+X(C(A)C(B))-T])
//│         in x%8[+C(B)-T]
//│ )
//│ Def(2, main, [], [],
//│ S: None,
//│ I: [],
//│ [Some(ICtor(B))], 1, 
//│ let x%10[+C(False)-TI] = False()
//│   in let* (x%11[+C(B)-T]) = foo$D%1$C%0(x%10[+C(False)-TI])
//│     in x%11[+C(B)-T]
//│ )
//│ Def(10, not$D%1, [], [],
//│ S: None,
//│ I: [],
//│ [Some(ICtor(True))], 1, 
//│ let x%2[+C(True)-T] = True()
//│   in x%2[+C(True)-T]
//│ )
//│ Def(11, foo$D%1$C%0, [x%4], [{}],
//│ S: Some([Some(ICtor(False))]),
//│ I: [[Some(ICtor(False))]],
//│ [Some(ICtor(B))], 1, 
//│ let* (x%6[+C(True)-TI]) = not$D%1()
//│   in let* (x%7[+X(C(A)C(B))-T]) = foo(x%6[+C(True)-TI])
//│     in let x%8[+C(B)-T] = B(x%7[+X(C(A)C(B))-T])
//│       in x%8[+C(B)-T]
//│ )
//│ },
//│ let* (x%12[+C(B)]) = main()
//│   in x%12[+C(B)])
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(2, main, [], [],
//│ S: None,
//│ I: [],
//│ [Some(ICtor(B))], 1, 
//│ let x%10[+C(False)-TI] = False()
//│   in let* (x%11[+C(B)-T]) = foo$D%1$C%0(x%10[+C(False)-TI])
//│     in x%11[+C(B)-T]
//│ )
//│ Def(10, not$D%1, [], [],
//│ S: None,
//│ I: [],
//│ [Some(ICtor(True))], 1, 
//│ let x%2[+C(True)-T] = True()
//│   in x%2[+C(True)-T]
//│ )
//│ Def(11, foo$D%1$C%0, [x%4], [{}],
//│ S: Some([Some(ICtor(False))]),
//│ I: [[Some(ICtor(False))]],
//│ [Some(ICtor(B))], 1, 
//│ let* (x%6[+C(True)-TI]) = not$D%1()
//│   in let* (x%7[+C(A)-T]) = foo$D%2()
//│     in let x%8[+C(B)-T] = B(x%7[+C(A)-T])
//│       in x%8[+C(B)-T]
//│ )
//│ Def(13, foo$D%2, [], [],
//│ S: None,
//│ I: [],
//│ [Some(ICtor(A))], 1, 
//│ let x%5[+C(A)-T] = A()
//│   in x%5[+C(A)-T]
//│ )
//│ },
//│ let* (x%12[+C(B)]) = main()
//│   in x%12[+C(B)])
//│ 
//│ 
//│ Interpreted ------------------------------
//│ B(A())
//│ 
//│ 
//│ Fuel used: 4

:GraphInterp
:GraphOpt
class True
class False
class A()
class B(b)
fun aaa() =
  let m = 1
  let n = 2
  let p = 3
  let q = 4
  m + n - p + q
fun bbb() =
  let x = aaa()
  x * 100 + 4
fun not(x) =
  if x then False else True
fun foo(x) =
  if x then A
       else B(foo(not(x)))
fun main() =
  let x = foo(False)
  if x is
    A then aaa()
    B(b1) then bbb()
main()
//│ |#class| |True|↵|#class| |False|↵|#class| |A|(||)|↵|#class| |B|(|b|)|↵|#fun| |aaa|(||)| |#=|→|#let| |m| |#=| |1|↵|#let| |n| |#=| |2|↵|#let| |p| |#=| |3|↵|#let| |q| |#=| |4|↵|m| |+| |n| |-| |p| |+| |q|←|↵|#fun| |bbb|(||)| |#=|→|#let| |x| |#=| |aaa|(||)|↵|x| |*| |100| |+| |4|←|↵|#fun| |not|(|x|)| |#=|→|#if| |x| |#then| |False| |#else| |True|←|↵|#fun| |foo|(|x|)| |#=|→|#if| |x| |#then| |A|→|#else| |B|(|foo|(|not|(|x|)|)|)|←|←|↵|#fun| |main|(||)| |#=|→|#let| |x| |#=| |foo|(|False|)|↵|#if| |x| |is|→|A| |#then| |aaa|(||)|↵|B|(|b1|)| |#then| |bbb|(||)|←|←|↵|main|(||)|
//│ Parsed: {class True {}; class False {}; class A() {}; class B(b,) {}; fun aaa = () => {let m = 1; let n = 2; let p = 3; let q = 4; +(-(+(m,)(n,),)(p,),)(q,)}; fun bbb = () => {let x = aaa(); +(*(x,)(100,),)(4,)}; fun not = (x,) => {if (x) then False else True}; fun foo = (x,) => {if (x) then A else B(foo(not(x,),),)}; fun main = () => {let x = foo(False,); if x is ‹(A) then aaa(); (B(b1,)) then bbb()›}; main()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, True, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, False, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, A, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, B, (), Tup(_: Var(b)), (), None, None, TypingUnit()), NuFunDef(None, aaa, None, [], Lam(Tup(), Blk(...))), NuFunDef(None, bbb, None, [], Lam(Tup(), Blk(...))), NuFunDef(None, not, None, [], Lam(Tup(_: Var(x)), Blk(...))), NuFunDef(None, foo, None, [], Lam(Tup(_: Var(x)), Blk(...))), NuFunDef(None, main, None, [], Lam(Tup(), Blk(...))), App(Var(main), Tup()))
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(0, aaa, [], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let x%0 = 1
//│   in let x%1 = 2
//│     in let x%2 = 3
//│       in let x%3 = 4
//│         in let x%4 = +(x%0,x%1)
//│           in let x%5 = -(x%4,x%2)
//│             in let x%6 = +(x%5,x%3)
//│               in x%6
//│ )
//│ Def(1, bbb, [], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let* (x%7) = aaa()
//│   in let x%8 = *(x%7,100)
//│     in let x%9 = +(x%8,4)
//│       in x%9
//│ )
//│ Def(2, not, [x%10], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let join j%0(x%13) = x%13
//│   in if x%10
//│     true => let x%11 = False()
//│       in jump j%0(x%11)
//│     false => let x%12 = True()
//│       in jump j%0(x%12)
//│ )
//│ Def(3, foo, [x%14], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let join j%1(x%19) = x%19
//│   in if x%14
//│     true => let x%15 = A()
//│       in jump j%1(x%15)
//│     false => let* (x%16) = not(x%14)
//│       in let* (x%17) = foo(x%16)
//│         in let x%18 = B(x%17)
//│           in jump j%1(x%18)
//│ )
//│ Def(4, main, [], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let x%20 = False()
//│   in let* (x%21) = foo(x%20)
//│     in let join j%2(x%25) = x%25
//│       in case x%21 of
//│         A => let* (x%22) = aaa()
//│           in jump j%2(x%22)
//│         B => let x%23 = x%21.b
//│           in let* (x%24) = bbb()
//│             in jump j%2(x%24)
//│ )
//│ },
//│ let* (x%26) = main()
//│   in x%26)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(0, aaa, [], [],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let x%4[-T] = +(1,2)
//│   in let x%5[-T] = -(x%4[-T],3)
//│     in let x%6[-T] = +(x%5[-T],4)
//│       in x%6[-T]
//│ )
//│ Def(1, bbb, [], [],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let* (x%7[-T]) = aaa()
//│   in let x%8[-T] = *(x%7[-T],100)
//│     in let x%9[-T] = +(x%8[-T],4)
//│       in x%9[-T]
//│ )
//│ Def(2, not, [x%10[-DT]], [{EDestruct,EDirect}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ if x%10[-DT]
//│   true => let x%11[+C(False)-T] = False()
//│     in x%11[+C(False)-T]
//│   false => let x%12[+C(True)-T] = True()
//│     in x%12[+C(True)-T]
//│ )
//│ Def(3, foo, [x%14[-DTI]], [{EDestruct,EDirect,EIndirectDestruct}],
//│ S: None,
//│ I: [[Some(IMix(ICtor(False),ICtor(True)))],[Some(ICtor(False))]],
//│ [Some(IMix(ICtor(A),ICtor(B)))], 1, 
//│ if x%14[-DTI]
//│   true => let x%15[+C(A)-T] = A()
//│     in x%15[+C(A)-T]
//│   false => let* (x%16[+X(C(False)C(True))-TI]) = not(x%14[-DTI])
//│     in let* (x%17[+X(C(A)C(B))-T]) = foo(x%16[+X(C(False)C(True))-TI])
//│       in let x%18[+C(B)-T] = B(x%17[+X(C(A)C(B))-T])
//│         in x%18[+C(B)-T]
//│ )
//│ Def(4, main, [], [],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let x%20[+C(False)-TI] = False()
//│   in let* (x%21[+X(C(A)C(B))-DT]) = foo(x%20[+C(False)-TI])
//│     in case x%21[+X(C(A)C(B))-DT] of
//│       A => let* (x%22[-T]) = aaa()
//│         in x%22[-T]
//│       B => let* (x%24[-T]) = bbb()
//│         in x%24[-T]
//│ )
//│ },
//│ let* (x%26) = main()
//│   in x%26)
//│ 
//│ Interpreted ------------------------------
//│ 404
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(0, aaa, [], [],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let x%4[-T] = +(1,2)
//│   in let x%5[-T] = -(x%4[-T],3)
//│     in let x%6[-T] = +(x%5[-T],4)
//│       in x%6[-T]
//│ )
//│ Def(1, bbb, [], [],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let* (x%7[-T]) = aaa()
//│   in let x%8[-T] = *(x%7[-T],100)
//│     in let x%9[-T] = +(x%8[-T],4)
//│       in x%9[-T]
//│ )
//│ Def(2, not, [x%10[-DT]], [{EDestruct,EDirect}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ if x%10[-DT]
//│   true => let x%11[+C(False)-T] = False()
//│     in x%11[+C(False)-T]
//│   false => let x%12[+C(True)-T] = True()
//│     in x%12[+C(True)-T]
//│ )
//│ Def(3, foo, [x%14[-DTI]], [{EDestruct,EDirect,EIndirectDestruct}],
//│ S: None,
//│ I: [[Some(IMix(ICtor(False),ICtor(True)))]],
//│ [Some(IMix(ICtor(A),ICtor(B)))], 1, 
//│ if x%14[-DTI]
//│   true => let x%15[+C(A)-T] = A()
//│     in x%15[+C(A)-T]
//│   false => let* (x%16[+X(C(False)C(True))-TI]) = not(x%14[-DTI])
//│     in let* (x%17[+X(C(A)C(B))-T]) = foo(x%16[+X(C(False)C(True))-TI])
//│       in let x%18[+C(B)-T] = B(x%17[+X(C(A)C(B))-T])
//│         in x%18[+C(B)-T]
//│ )
//│ Def(4, main, [], [],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let x%20[+C(False)-TI] = False()
//│   in let* (x%21[+C(B)-DT]) = foo$D%1(x%20[+C(False)-TI])
//│     in case x%21[+C(B)-DT] of
//│       A => let* (x%22[-T]) = aaa()
//│         in x%22[-T]
//│       B => let* (x%24[-T]) = bbb()
//│         in x%24[-T]
//│ )
//│ Def(10, foo$D%1, [x%14], [{EDirect,EIndirectDestruct}],
//│ S: None,
//│ I: [[Some(ICtor(False))]],
//│ [Some(ICtor(B))], 1, 
//│ let* (x%16[+X(C(False)C(True))-TI]) = not(x%14[-DTI])
//│   in let* (x%17[+X(C(A)C(B))-T]) = foo(x%16[+X(C(False)C(True))-TI])
//│     in let x%18[+C(B)-T] = B(x%17[+X(C(A)C(B))-T])
//│       in x%18[+C(B)-T]
//│ )
//│ },
//│ let* (x%26) = main()
//│   in x%26)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(0, aaa, [], [],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let x%4[-T] = +(1,2)
//│   in let x%5[-T] = -(x%4[-T],3)
//│     in let x%6[-T] = +(x%5[-T],4)
//│       in x%6[-T]
//│ )
//│ Def(1, bbb, [], [],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let* (x%7[-T]) = aaa()
//│   in let x%8[-T] = *(x%7[-T],100)
//│     in let x%9[-T] = +(x%8[-T],4)
//│       in x%9[-T]
//│ )
//│ Def(2, not, [x%10[-DT]], [{EDestruct,EDirect}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ if x%10[-DT]
//│   true => let x%11[+C(False)-T] = False()
//│     in x%11[+C(False)-T]
//│   false => let x%12[+C(True)-T] = True()
//│     in x%12[+C(True)-T]
//│ )
//│ Def(3, foo, [x%14[-DTI]], [{EDestruct,EDirect,EIndirectDestruct}],
//│ S: None,
//│ I: [[Some(IMix(ICtor(False),ICtor(True)))],[Some(ICtor(True))]],
//│ [Some(IMix(ICtor(A),ICtor(B)))], 1, 
//│ if x%14[-DTI]
//│   true => let x%15[+C(A)-T] = A()
//│     in x%15[+C(A)-T]
//│   false => let* (x%16[+X(C(False)C(True))-TI]) = not(x%14[-DTI])
//│     in let* (x%17[+X(C(A)C(B))-T]) = foo(x%16[+X(C(False)C(True))-TI])
//│       in let x%18[+C(B)-T] = B(x%17[+X(C(A)C(B))-T])
//│         in x%18[+C(B)-T]
//│ )
//│ Def(4, main, [], [],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let x%20[+C(False)-TI] = False()
//│   in let* (x%21[+C(B)-DT]) = foo$D%1$C%0(x%20[+C(False)-TI])
//│     in case x%21[+C(B)-DT] of
//│       A => let* (x%22[-T]) = aaa()
//│         in x%22[-T]
//│       B => let* (x%24[-T]) = bbb()
//│         in x%24[-T]
//│ )
//│ Def(13, not$D%1, [], [],
//│ S: None,
//│ I: [],
//│ [Some(ICtor(True))], 1, 
//│ let x%12[+C(True)-T] = True()
//│   in x%12[+C(True)-T]
//│ )
//│ Def(14, foo$D%1$C%0, [x%14], [{}],
//│ S: Some([Some(ICtor(False))]),
//│ I: [[Some(ICtor(False))]],
//│ [Some(ICtor(B))], 1, 
//│ let* (x%16[+X(C(False)C(True))-TI]) = not$D%1()
//│   in let* (x%17[+X(C(A)C(B))-T]) = foo(x%16[+X(C(False)C(True))-TI])
//│     in let x%18[+C(B)-T] = B(x%17[+X(C(A)C(B))-T])
//│       in x%18[+C(B)-T]
//│ )
//│ },
//│ let* (x%26) = main()
//│   in x%26)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(0, aaa, [], [],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let x%4[-T] = +(1,2)
//│   in let x%5[-T] = -(x%4[-T],3)
//│     in let x%6[-T] = +(x%5[-T],4)
//│       in x%6[-T]
//│ )
//│ Def(1, bbb, [], [],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let* (x%7[-T]) = aaa()
//│   in let x%8[-T] = *(x%7[-T],100)
//│     in let x%9[-T] = +(x%8[-T],4)
//│       in x%9[-T]
//│ )
//│ Def(4, main, [], [],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let x%20[+C(False)-TI] = False()
//│   in let* (x%21[+C(B)-DT]) = foo$D%1$C%0(x%20[+C(False)-TI])
//│     in case x%21[+C(B)-DT] of
//│       A => let* (x%22[-T]) = aaa()
//│         in x%22[-T]
//│       B => let* (x%24[-T]) = bbb()
//│         in x%24[-T]
//│ )
//│ Def(13, not$D%1, [], [],
//│ S: None,
//│ I: [],
//│ [Some(ICtor(True))], 1, 
//│ let x%12[+C(True)-T] = True()
//│   in x%12[+C(True)-T]
//│ )
//│ Def(14, foo$D%1$C%0, [x%14], [{}],
//│ S: Some([Some(ICtor(False))]),
//│ I: [[Some(ICtor(False))]],
//│ [Some(ICtor(B))], 1, 
//│ let* (x%16[+C(True)-TI]) = not$D%1()
//│   in let* (x%17[+C(A)-T]) = foo$D%2()
//│     in let x%18[+C(B)-T] = B(x%17[+C(A)-T])
//│       in x%18[+C(B)-T]
//│ )
//│ Def(16, foo$D%2, [], [],
//│ S: None,
//│ I: [],
//│ [Some(ICtor(A))], 1, 
//│ let x%15[+C(A)-T] = A()
//│   in x%15[+C(A)-T]
//│ )
//│ },
//│ let* (x%26) = main()
//│   in x%26)
//│ 
//│ 
//│ Interpreted ------------------------------
//│ 404
//│ 
//│ 
//│ Fuel used: 4


:GraphInterp
:GraphOpt
class True
class False
class S(s)
class O
fun odd(x) =
  if x is
    O then False
    S(s) then even(s)
fun even(x) =
  if x is
    O then True
    S(s) then odd(s)
fun foo() = odd(S(S(S(O))))
foo()
//│ |#class| |True|↵|#class| |False|↵|#class| |S|(|s|)|↵|#class| |O|↵|#fun| |odd|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |False|↵|S|(|s|)| |#then| |even|(|s|)|←|←|↵|#fun| |even|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |True|↵|S|(|s|)| |#then| |odd|(|s|)|←|←|↵|#fun| |foo|(||)| |#=| |odd|(|S|(|S|(|S|(|O|)|)|)|)|↵|foo|(||)|
//│ Parsed: {class True {}; class False {}; class S(s,) {}; class O {}; fun odd = (x,) => {if x is ‹(O) then False; (S(s,)) then even(s,)›}; fun even = (x,) => {if x is ‹(O) then True; (S(s,)) then odd(s,)›}; fun foo = () => odd(S(S(S(O,),),),); foo()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, True, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, False, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, S, (), Tup(_: Var(s)), (), None, None, TypingUnit()), NuTypeDef(class, O, (), Tup(), (), None, None, TypingUnit()), NuFunDef(None, odd, None, [], Lam(Tup(_: Var(x)), Blk(...))), NuFunDef(None, even, None, [], Lam(Tup(_: Var(x)), Blk(...))), NuFunDef(None, foo, None, [], Lam(Tup(), App(Var(odd), Tup(_: App(Var(S), Tup(_: App(Var(S), Tup(_: App(Var(S), Tup(_: Var(O))))))))))), App(Var(foo), Tup()))
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let join j%0(x%4) = x%4
//│   in case x%0 of
//│     O => let x%1 = False()
//│       in jump j%0(x%1)
//│     S => let x%2 = x%0.s
//│       in let* (x%3) = even(x%2)
//│         in jump j%0(x%3)
//│ )
//│ Def(1, even, [x%5], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let join j%1(x%9) = x%9
//│   in case x%5 of
//│     O => let x%6 = True()
//│       in jump j%1(x%6)
//│     S => let x%7 = x%5.s
//│       in let* (x%8) = odd(x%7)
//│         in jump j%1(x%8)
//│ )
//│ Def(2, foo, [], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let x%10 = O()
//│   in let x%11 = S(x%10)
//│     in let x%12 = S(x%11)
//│       in let x%13 = S(x%12)
//│         in let* (x%14) = odd(x%13)
//│           in x%14
//│ )
//│ },
//│ let* (x%15) = foo()
//│   in x%15)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [[Some(ICtor(S))]],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%0[-DTS(s)] of
//│   O => let x%1[+C(False)-T] = False()
//│     in x%1[+C(False)-T]
//│   S => let x%2[-TIS(s)] = x%0[-DTS(s)].s
//│     in let* (x%3[+X(C(False)C(True))-T]) = even(x%2[-TIS(s)])
//│       in x%3[+X(C(False)C(True))-T]
//│ )
//│ Def(1, even, [x%5[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%5[-DTS(s)] of
//│   O => let x%6[+C(True)-T] = True()
//│     in x%6[+C(True)-T]
//│   S => let x%7[-TIS(s)] = x%5[-DTS(s)].s
//│     in let* (x%8[+X(C(False)C(True))-T]) = odd(x%7[-TIS(s)])
//│       in x%8[+X(C(False)C(True))-T]
//│ )
//│ Def(2, foo, [], [],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let x%10[+C(O)-T] = O()
//│   in let x%11[+C(S)-T] = S(x%10[+C(O)-T])
//│     in let x%12[+C(S)-T] = S(x%11[+C(S)-T])
//│       in let x%13[+C(S)-TIS(s)] = S(x%12[+C(S)-T])
//│         in let* (x%14[+X(C(False)C(True))-T]) = odd(x%13[+C(S)-TIS(s)])
//│           in x%14[+X(C(False)C(True))-T]
//│ )
//│ },
//│ let* (x%15) = foo()
//│   in x%15)
//│ 
//│ Interpreted ------------------------------
//│ True()
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%0[-DTS(s)] of
//│   O => let x%1[+C(False)-T] = False()
//│     in x%1[+C(False)-T]
//│   S => let x%2[-TIS(s)] = x%0[-DTS(s)].s
//│     in let* (x%3[+X(C(False)C(True))-T]) = even(x%2[-TIS(s)])
//│       in x%3[+X(C(False)C(True))-T]
//│ )
//│ Def(1, even, [x%5[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%5[-DTS(s)] of
//│   O => let x%6[+C(True)-T] = True()
//│     in x%6[+C(True)-T]
//│   S => let x%7[-TIS(s)] = x%5[-DTS(s)].s
//│     in let* (x%8[+X(C(False)C(True))-T]) = odd(x%7[-TIS(s)])
//│       in x%8[+X(C(False)C(True))-T]
//│ )
//│ Def(2, foo, [], [],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let x%10[+C(O)-T] = O()
//│   in let x%11[+C(S)-T] = S(x%10[+C(O)-T])
//│     in let x%12[+C(S)-TIS(s)] = S(x%11[+C(S)-T])
//│       in let* (x%14[+X(C(False)C(True))-T]) = odd$D%1$S%0(x%12[+C(S)-TIS(s)])
//│         in x%14[+X(C(False)C(True))-T]
//│ )
//│ Def(8, odd$D%1$S%0, [x%0_s], [{EDirect,EIndirectDestruct,ESelect(s)}],
//│ S: None,
//│ I: [[Some(ICtor(S))]],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%3[+X(C(False)C(True))-T]) = even(x%0_s[-TIS(s)])
//│   in x%3[+X(C(False)C(True))-T]
//│ )
//│ },
//│ let* (x%15[+X(C(False)C(True))]) = foo()
//│   in x%15[+X(C(False)C(True))])
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%0[-DTS(s)] of
//│   O => let x%1[+C(False)-T] = False()
//│     in x%1[+C(False)-T]
//│   S => let x%2[-TIS(s)] = x%0[-DTS(s)].s
//│     in let* (x%3[+X(C(False)C(True))-T]) = even(x%2[-TIS(s)])
//│       in x%3[+X(C(False)C(True))-T]
//│ )
//│ Def(1, even, [x%5[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%5[-DTS(s)] of
//│   O => let x%6[+C(True)-T] = True()
//│     in x%6[+C(True)-T]
//│   S => let x%7[-TIS(s)] = x%5[-DTS(s)].s
//│     in let* (x%8[+X(C(False)C(True))-T]) = odd(x%7[-TIS(s)])
//│       in x%8[+X(C(False)C(True))-T]
//│ )
//│ Def(2, foo, [], [],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let x%10[+C(O)-T] = O()
//│   in let x%11[+C(S)-T] = S(x%10[+C(O)-T])
//│     in let x%12[+C(S)-TIS(s)] = S(x%11[+C(S)-T])
//│       in let* (x%14[+X(C(False)C(True))-T]) = odd$D%1$S%0$C%0(x%12[+C(S)-TIS(s)])
//│         in x%14[+X(C(False)C(True))-T]
//│ )
//│ Def(12, odd$D%1$S%0$C%0, [x%0_s], [{ESelect(s)}],
//│ S: Some([Some(ICtor(S))]),
//│ I: [[Some(ICtor(S))]],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let x%19 = x%0_s[-S(s)].s
//│   in let* (x%3[+X(C(False)C(True))-T]) = even$D%1$S%0(x%19[-TIS(s)])
//│     in x%3[+X(C(False)C(True))-T]
//│ )
//│ Def(13, even$D%1$S%0, [x%5_s], [{EDirect,EIndirectDestruct,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%8[+X(C(False)C(True))-T]) = odd(x%5_s[-TIS(s)])
//│   in x%8[+X(C(False)C(True))-T]
//│ )
//│ },
//│ let* (x%15[+X(C(False)C(True))]) = foo()
//│   in x%15[+X(C(False)C(True))])
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%0[-DTS(s)] of
//│   O => let x%1[+C(False)-T] = False()
//│     in x%1[+C(False)-T]
//│   S => let x%2[-TIS(s)] = x%0[-DTS(s)].s
//│     in let* (x%3[+X(C(False)C(True))-T]) = even(x%2[-TIS(s)])
//│       in x%3[+X(C(False)C(True))-T]
//│ )
//│ Def(1, even, [x%5[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%5[-DTS(s)] of
//│   O => let x%6[+C(True)-T] = True()
//│     in x%6[+C(True)-T]
//│   S => let x%7[-TIS(s)] = x%5[-DTS(s)].s
//│     in let* (x%8[+X(C(False)C(True))-T]) = odd(x%7[-TIS(s)])
//│       in x%8[+X(C(False)C(True))-T]
//│ )
//│ Def(2, foo, [], [],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let x%10[+C(O)-T] = O()
//│   in let x%11[+C(S)-TIS(s)] = S(x%10[+C(O)-T])
//│     in let* (x%14[+X(C(False)C(True))-T]) = odd$D%1$S%0$C%0$S%0(x%11[+C(S)-TIS(s)])
//│       in x%14[+X(C(False)C(True))-T]
//│ )
//│ Def(13, even$D%1$S%0, [x%5_s], [{EDirect,EIndirectDestruct,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%8[+X(C(False)C(True))-T]) = odd(x%5_s[-TIS(s)])
//│   in x%8[+X(C(False)C(True))-T]
//│ )
//│ Def(14, odd$D%1$S%0$C%0$S%0, [x%0_s_s], [{EDirect,EIndirectDestruct,ESelect(s)}],
//│ S: None,
//│ I: [[Some(ICtor(S))]],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%3[+X(C(False)C(True))-T]) = even$D%1$S%0(x%0_s_s[-TIS(s)])
//│   in x%3[+X(C(False)C(True))-T]
//│ )
//│ },
//│ let* (x%15[+X(C(False)C(True))]) = foo()
//│   in x%15[+X(C(False)C(True))])
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%0[-DTS(s)] of
//│   O => let x%1[+C(False)-T] = False()
//│     in x%1[+C(False)-T]
//│   S => let x%2[-TIS(s)] = x%0[-DTS(s)].s
//│     in let* (x%3[+X(C(False)C(True))-T]) = even(x%2[-TIS(s)])
//│       in x%3[+X(C(False)C(True))-T]
//│ )
//│ Def(1, even, [x%5[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%5[-DTS(s)] of
//│   O => let x%6[+C(True)-T] = True()
//│     in x%6[+C(True)-T]
//│   S => let x%7[-TIS(s)] = x%5[-DTS(s)].s
//│     in let* (x%8[+X(C(False)C(True))-T]) = odd(x%7[-TIS(s)])
//│       in x%8[+X(C(False)C(True))-T]
//│ )
//│ Def(2, foo, [], [],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let x%10[+C(O)-T] = O()
//│   in let x%11[+C(S)-TIS(s)] = S(x%10[+C(O)-T])
//│     in let* (x%14[+X(C(False)C(True))-T]) = odd$D%1$S%0$C%0$S%0$C%0(x%11[+C(S)-TIS(s)])
//│       in x%14[+X(C(False)C(True))-T]
//│ )
//│ Def(13, even$D%1$S%0, [x%5_s], [{EDirect,EIndirectDestruct,ESelect(s)}],
//│ S: None,
//│ I: [[Some(ICtor(S))]],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%8[+X(C(False)C(True))-T]) = odd(x%5_s[-TIS(s)])
//│   in x%8[+X(C(False)C(True))-T]
//│ )
//│ Def(18, odd$D%1$S%0$C%0$S%0$C%0, [x%0_s_s], [{EDirect,EIndirectDestruct,ESelect(s)}],
//│ S: Some([Some(ICtor(S))]),
//│ I: [[Some(ICtor(S))]],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%3[+X(C(False)C(True))-T]) = even$D%1$S%0(x%0_s_s[-TIS(s)])
//│   in x%3[+X(C(False)C(True))-T]
//│ )
//│ },
//│ let* (x%15[+X(C(False)C(True))]) = foo()
//│   in x%15[+X(C(False)C(True))])
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%0[-DTS(s)] of
//│   O => let x%1[+C(False)-T] = False()
//│     in x%1[+C(False)-T]
//│   S => let x%2[-TIS(s)] = x%0[-DTS(s)].s
//│     in let* (x%3[+X(C(False)C(True))-T]) = even(x%2[-TIS(s)])
//│       in x%3[+X(C(False)C(True))-T]
//│ )
//│ Def(1, even, [x%5[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%5[-DTS(s)] of
//│   O => let x%6[+C(True)-T] = True()
//│     in x%6[+C(True)-T]
//│   S => let x%7[-TIS(s)] = x%5[-DTS(s)].s
//│     in let* (x%8[+X(C(False)C(True))-T]) = odd(x%7[-TIS(s)])
//│       in x%8[+X(C(False)C(True))-T]
//│ )
//│ Def(2, foo, [], [],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let x%10[+C(O)-T] = O()
//│   in let x%11[+C(S)-TIS(s)] = S(x%10[+C(O)-T])
//│     in let* (x%14[+X(C(False)C(True))-T]) = odd$D%1$S%0$C%0$S%0$C%0$C%0(x%11[+C(S)-TIS(s)])
//│       in x%14[+X(C(False)C(True))-T]
//│ )
//│ Def(22, even$D%1$S%0$C%0, [x%5_s], [{ESelect(s)}],
//│ S: Some([Some(ICtor(S))]),
//│ I: [[Some(ICtor(S))]],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let x%22 = x%5_s[-S(s)].s
//│   in let* (x%8[+X(C(False)C(True))-T]) = odd$D%5$S%0(x%22[-TIS(s)])
//│     in x%8[+X(C(False)C(True))-T]
//│ )
//│ Def(23, odd$D%1$S%0$C%0$S%0$C%0$C%0, [x%0_s_s], [{EDirect,ESelect(s)}],
//│ S: Some([Some(ICtor(S))]),
//│ I: [[Some(ICtor(S))]],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%3[+X(C(False)C(True))-T]) = even$D%1$S%0$C%0(x%0_s_s[-TIS(s)])
//│   in x%3[+X(C(False)C(True))-T]
//│ )
//│ Def(24, odd$D%5$S%0, [x%0_s], [{EDirect,EIndirectDestruct,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%3[+X(C(False)C(True))-T]) = even(x%0_s[-TIS(s)])
//│   in x%3[+X(C(False)C(True))-T]
//│ )
//│ },
//│ let* (x%15[+X(C(False)C(True))]) = foo()
//│   in x%15[+X(C(False)C(True))])
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%0[-DTS(s)] of
//│   O => let x%1[+C(False)-T] = False()
//│     in x%1[+C(False)-T]
//│   S => let x%2[-TIS(s)] = x%0[-DTS(s)].s
//│     in let* (x%3[+X(C(False)C(True))-T]) = even(x%2[-TIS(s)])
//│       in x%3[+X(C(False)C(True))-T]
//│ )
//│ Def(1, even, [x%5[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%5[-DTS(s)] of
//│   O => let x%6[+C(True)-T] = True()
//│     in x%6[+C(True)-T]
//│   S => let x%7[-TIS(s)] = x%5[-DTS(s)].s
//│     in let* (x%8[+X(C(False)C(True))-T]) = odd(x%7[-TIS(s)])
//│       in x%8[+X(C(False)C(True))-T]
//│ )
//│ Def(2, foo, [], [],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let x%10[+C(O)-T] = O()
//│   in let x%11[+C(S)-TIS(s)] = S(x%10[+C(O)-T])
//│     in let* (x%14[+X(C(False)C(True))-T]) = odd$D%1$S%0$C%0$S%0$C%0$C%0(x%11[+C(S)-TIS(s)])
//│       in x%14[+X(C(False)C(True))-T]
//│ )
//│ Def(23, odd$D%1$S%0$C%0$S%0$C%0$C%0, [x%0_s_s], [{ESelect(s)}],
//│ S: Some([Some(ICtor(S))]),
//│ I: [[Some(ICtor(S))]],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let x%23 = x%0_s_s[-S(s)].s
//│   in let* (x%3[+X(C(False)C(True))-T]) = even$D%1$S%0$C%0$S%0(x%23[-TIS(s)])
//│     in x%3[+X(C(False)C(True))-T]
//│ )
//│ Def(24, odd$D%5$S%0, [x%0_s], [{EDirect,EIndirectDestruct,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%3[+X(C(False)C(True))-T]) = even(x%0_s[-TIS(s)])
//│   in x%3[+X(C(False)C(True))-T]
//│ )
//│ Def(25, even$D%1$S%0$C%0$S%0, [x%5_s_s], [{EDirect,EIndirectDestruct,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%8[+X(C(False)C(True))-T]) = odd$D%5$S%0(x%5_s_s[-TIS(s)])
//│   in x%8[+X(C(False)C(True))-T]
//│ )
//│ },
//│ let* (x%15[+X(C(False)C(True))]) = foo()
//│   in x%15[+X(C(False)C(True))])
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%0[-DTS(s)] of
//│   O => let x%1[+C(False)-T] = False()
//│     in x%1[+C(False)-T]
//│   S => let x%2[-TIS(s)] = x%0[-DTS(s)].s
//│     in let* (x%3[+X(C(False)C(True))-T]) = even(x%2[-TIS(s)])
//│       in x%3[+X(C(False)C(True))-T]
//│ )
//│ Def(1, even, [x%5[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%5[-DTS(s)] of
//│   O => let x%6[+C(True)-T] = True()
//│     in x%6[+C(True)-T]
//│   S => let x%7[-TIS(s)] = x%5[-DTS(s)].s
//│     in let* (x%8[+X(C(False)C(True))-T]) = odd(x%7[-TIS(s)])
//│       in x%8[+X(C(False)C(True))-T]
//│ )
//│ Def(2, foo, [], [],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let x%10[+C(O)-TIS(s)] = O()
//│   in let* (x%14[+X(C(False)C(True))-T]) = odd$D%1$S%0$C%0$S%0$C%0$C%0$S%0(x%10[+C(O)-TIS(s)])
//│     in x%14[+X(C(False)C(True))-T]
//│ )
//│ Def(24, odd$D%5$S%0, [x%0_s], [{EDirect,EIndirectDestruct,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%3[+X(C(False)C(True))-T]) = even(x%0_s[-TIS(s)])
//│   in x%3[+X(C(False)C(True))-T]
//│ )
//│ Def(25, even$D%1$S%0$C%0$S%0, [x%5_s_s], [{EDirect,EIndirectDestruct,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%8[+X(C(False)C(True))-T]) = odd$D%5$S%0(x%5_s_s[-TIS(s)])
//│   in x%8[+X(C(False)C(True))-T]
//│ )
//│ Def(26, odd$D%1$S%0$C%0$S%0$C%0$C%0$S%0, [x%0_s_s_s], [{EDirect,EIndirectDestruct,ESelect(s)}],
//│ S: None,
//│ I: [[Some(ICtor(O))]],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%3[+X(C(False)C(True))-T]) = even$D%1$S%0$C%0$S%0(x%0_s_s_s[-TIS(s)])
//│   in x%3[+X(C(False)C(True))-T]
//│ )
//│ },
//│ let* (x%15[+X(C(False)C(True))]) = foo()
//│   in x%15[+X(C(False)C(True))])
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%0[-DTS(s)] of
//│   O => let x%1[+C(False)-T] = False()
//│     in x%1[+C(False)-T]
//│   S => let x%2[-TIS(s)] = x%0[-DTS(s)].s
//│     in let* (x%3[+X(C(False)C(True))-T]) = even(x%2[-TIS(s)])
//│       in x%3[+X(C(False)C(True))-T]
//│ )
//│ Def(1, even, [x%5[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%5[-DTS(s)] of
//│   O => let x%6[+C(True)-T] = True()
//│     in x%6[+C(True)-T]
//│   S => let x%7[-TIS(s)] = x%5[-DTS(s)].s
//│     in let* (x%8[+X(C(False)C(True))-T]) = odd(x%7[-TIS(s)])
//│       in x%8[+X(C(False)C(True))-T]
//│ )
//│ Def(2, foo, [], [],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let x%10[+C(O)-TIS(s)] = O()
//│   in let* (x%14[+X(C(False)C(True))-T]) = odd$D%1$S%0$C%0$S%0$C%0$C%0$S%0$C%0(x%10[+C(O)-TIS(s)])
//│     in x%14[+X(C(False)C(True))-T]
//│ )
//│ Def(24, odd$D%5$S%0, [x%0_s], [{EDirect,EIndirectDestruct,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%3[+X(C(False)C(True))-T]) = even(x%0_s[-TIS(s)])
//│   in x%3[+X(C(False)C(True))-T]
//│ )
//│ Def(25, even$D%1$S%0$C%0$S%0, [x%5_s_s], [{EDirect,EIndirectDestruct,ESelect(s)}],
//│ S: None,
//│ I: [[Some(ICtor(O))]],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%8[+X(C(False)C(True))-T]) = odd$D%5$S%0(x%5_s_s[-TIS(s)])
//│   in x%8[+X(C(False)C(True))-T]
//│ )
//│ Def(30, odd$D%1$S%0$C%0$S%0$C%0$C%0$S%0$C%0, [x%0_s_s_s], [{EDirect,EIndirectDestruct,ESelect(s)}],
//│ S: Some([Some(ICtor(O))]),
//│ I: [[Some(ICtor(O))]],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%3[+X(C(False)C(True))-T]) = even$D%1$S%0$C%0$S%0(x%0_s_s_s[-TIS(s)])
//│   in x%3[+X(C(False)C(True))-T]
//│ )
//│ },
//│ let* (x%15[+X(C(False)C(True))]) = foo()
//│   in x%15[+X(C(False)C(True))])
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%0[-DTS(s)] of
//│   O => let x%1[+C(False)-T] = False()
//│     in x%1[+C(False)-T]
//│   S => let x%2[-TIS(s)] = x%0[-DTS(s)].s
//│     in let* (x%3[+X(C(False)C(True))-T]) = even(x%2[-TIS(s)])
//│       in x%3[+X(C(False)C(True))-T]
//│ )
//│ Def(1, even, [x%5[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%5[-DTS(s)] of
//│   O => let x%6[+C(True)-T] = True()
//│     in x%6[+C(True)-T]
//│   S => let x%7[-TIS(s)] = x%5[-DTS(s)].s
//│     in let* (x%8[+X(C(False)C(True))-T]) = odd(x%7[-TIS(s)])
//│       in x%8[+X(C(False)C(True))-T]
//│ )
//│ Def(2, foo, [], [],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let x%10[+C(O)-TIS(s)] = O()
//│   in let* (x%14[+X(C(False)C(True))-T]) = odd$D%1$S%0$C%0$S%0$C%0$C%0$S%0$C%0$C%0(x%10[+C(O)-TIS(s)])
//│     in x%14[+X(C(False)C(True))-T]
//│ )
//│ Def(24, odd$D%5$S%0, [x%0_s], [{EDirect,EIndirectDestruct,ESelect(s)}],
//│ S: None,
//│ I: [[Some(ICtor(O))]],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%3[+X(C(False)C(True))-T]) = even(x%0_s[-TIS(s)])
//│   in x%3[+X(C(False)C(True))-T]
//│ )
//│ Def(34, odd$D%1$S%0$C%0$S%0$C%0$C%0$S%0$C%0$C%0, [x%0_s_s_s], [{EDirect,EIndirectDestruct,ESelect(s)}],
//│ S: Some([Some(ICtor(O))]),
//│ I: [[Some(ICtor(O))]],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%3[+X(C(False)C(True))-T]) = even$D%1$S%0$C%0$S%0$C%0(x%0_s_s_s[-TIS(s)])
//│   in x%3[+X(C(False)C(True))-T]
//│ )
//│ Def(35, even$D%1$S%0$C%0$S%0$C%0, [x%5_s_s], [{EDirect,EIndirectDestruct,ESelect(s)}],
//│ S: Some([Some(ICtor(O))]),
//│ I: [[Some(ICtor(O))]],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%8[+X(C(False)C(True))-T]) = odd$D%5$S%0(x%5_s_s[-TIS(s)])
//│   in x%8[+X(C(False)C(True))-T]
//│ )
//│ },
//│ let* (x%15[+X(C(False)C(True))]) = foo()
//│   in x%15[+X(C(False)C(True))])
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(2, foo, [], [],
//│ S: None,
//│ I: [],
//│ [Some(ICtor(True))], 1, 
//│ let x%10[+C(O)-TIS(s)] = O()
//│   in let* (x%14[+C(True)-T]) = odd$D%1$S%0$C%0$S%0$C%0$C%0$S%0$C%0$C%0$C%0(x%10[+C(O)-TIS(s)])
//│     in x%14[+C(True)-T]
//│ )
//│ Def(37, even$D%6, [], [],
//│ S: None,
//│ I: [],
//│ [Some(ICtor(True))], 1, 
//│ let x%6[+C(True)-T] = True()
//│   in x%6[+C(True)-T]
//│ )
//│ Def(39, odd$D%5$S%0$C%0, [x%0_s], [{}],
//│ S: Some([Some(ICtor(O))]),
//│ I: [[Some(ICtor(O))]],
//│ [Some(ICtor(True))], 1, 
//│ let* (x%3[+C(True)-T]) = even$D%6()
//│   in x%3[+C(True)-T]
//│ )
//│ Def(40, odd$D%1$S%0$C%0$S%0$C%0$C%0$S%0$C%0$C%0$C%0, [x%0_s_s_s], [{EDirect}],
//│ S: Some([Some(ICtor(O))]),
//│ I: [[Some(ICtor(O))]],
//│ [Some(ICtor(True))], 1, 
//│ let* (x%3[+C(True)-T]) = even$D%1$S%0$C%0$S%0$C%0$C%0(x%0_s_s_s[-TIS(s)])
//│   in x%3[+C(True)-T]
//│ )
//│ Def(41, even$D%1$S%0$C%0$S%0$C%0$C%0, [x%5_s_s], [{EDirect}],
//│ S: Some([Some(ICtor(O))]),
//│ I: [[Some(ICtor(O))]],
//│ [Some(ICtor(True))], 1, 
//│ let* (x%8[+C(True)-T]) = odd$D%5$S%0$C%0(x%5_s_s[-TIS(s)])
//│   in x%8[+C(True)-T]
//│ )
//│ },
//│ let* (x%15[+C(True)]) = foo()
//│   in x%15[+C(True)])
//│ 
//│ 
//│ Interpreted ------------------------------
//│ True()
//│ 
//│ 
//│ Fuel used: 11

:GraphInterp
:GraphOpt
class True
class False
class S(s)
class O
fun odd(x) =
  if x is
    O then False
    S(s) then even(s)
fun even(x) =
  if x is
    O then True
    S(s) then odd(s)
fun mk(n) = if n > 0 then S(mk(n - 1)) else O
fun foo() = odd(mk(10))
foo() 
//│ |#class| |True|↵|#class| |False|↵|#class| |S|(|s|)|↵|#class| |O|↵|#fun| |odd|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |False|↵|S|(|s|)| |#then| |even|(|s|)|←|←|↵|#fun| |even|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |True|↵|S|(|s|)| |#then| |odd|(|s|)|←|←|↵|#fun| |mk|(|n|)| |#=| |#if| |n| |>| |0| |#then| |S|(|mk|(|n| |-| |1|)|)| |#else| |O|↵|#fun| |foo|(||)| |#=| |odd|(|mk|(|10|)|)|↵|foo|(||)| |
//│ Parsed: {class True {}; class False {}; class S(s,) {}; class O {}; fun odd = (x,) => {if x is ‹(O) then False; (S(s,)) then even(s,)›}; fun even = (x,) => {if x is ‹(O) then True; (S(s,)) then odd(s,)›}; fun mk = (n,) => if (>(n,)(0,)) then S(mk(-(n,)(1,),),) else O; fun foo = () => odd(mk(10,),); foo()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, True, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, False, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, S, (), Tup(_: Var(s)), (), None, None, TypingUnit()), NuTypeDef(class, O, (), Tup(), (), None, None, TypingUnit()), NuFunDef(None, odd, None, [], Lam(Tup(_: Var(x)), Blk(...))), NuFunDef(None, even, None, [], Lam(Tup(_: Var(x)), Blk(...))), NuFunDef(None, mk, None, [], Lam(Tup(_: Var(n)), If(IfThen(App(App(Var(>), Tup(_: Var(n))), Tup(_: IntLit(0))), App(Var(S), Tup(_: App(Var(mk), Tup(_: App(App(Var(-), Tup(_: Var(n))), Tup(_: IntLit(1))))))), Some(Var(O))))), NuFunDef(None, foo, None, [], Lam(Tup(), App(Var(odd), Tup(_: App(Var(mk), Tup(_: IntLit(10))))))), App(Var(foo), Tup()))
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let join j%0(x%4) = x%4
//│   in case x%0 of
//│     O => let x%1 = False()
//│       in jump j%0(x%1)
//│     S => let x%2 = x%0.s
//│       in let* (x%3) = even(x%2)
//│         in jump j%0(x%3)
//│ )
//│ Def(1, even, [x%5], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let join j%1(x%9) = x%9
//│   in case x%5 of
//│     O => let x%6 = True()
//│       in jump j%1(x%6)
//│     S => let x%7 = x%5.s
//│       in let* (x%8) = odd(x%7)
//│         in jump j%1(x%8)
//│ )
//│ Def(2, mk, [n%0], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let x%10 = >(n%0,0)
//│   in let join j%2(x%15) = x%15
//│     in if x%10
//│       true => let x%11 = -(n%0,1)
//│         in let* (x%12) = mk(x%11)
//│           in let x%13 = S(x%12)
//│             in jump j%2(x%13)
//│       false => let x%14 = O()
//│         in jump j%2(x%14)
//│ )
//│ Def(3, foo, [], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let* (x%16) = mk(10)
//│   in let* (x%17) = odd(x%16)
//│     in x%17
//│ )
//│ },
//│ let* (x%18) = foo()
//│   in x%18)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [[Some(IMix(ICtor(O),ICtor(S)))]],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%0[-DTS(s)] of
//│   O => let x%1[+C(False)-T] = False()
//│     in x%1[+C(False)-T]
//│   S => let x%2[-TIS(s)] = x%0[-DTS(s)].s
//│     in let* (x%3[+X(C(False)C(True))-T]) = even(x%2[-TIS(s)])
//│       in x%3[+X(C(False)C(True))-T]
//│ )
//│ Def(1, even, [x%5[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%5[-DTS(s)] of
//│   O => let x%6[+C(True)-T] = True()
//│     in x%6[+C(True)-T]
//│   S => let x%7[-TIS(s)] = x%5[-DTS(s)].s
//│     in let* (x%8[+X(C(False)C(True))-T]) = odd(x%7[-TIS(s)])
//│       in x%8[+X(C(False)C(True))-T]
//│ )
//│ Def(2, mk, [n%0[-T]], [{EDirect}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(O),ICtor(S)))], 1, 
//│ let x%10[-DT] = >(n%0[-T],0)
//│   in if x%10[-DT]
//│     true => let x%11[-T] = -(n%0[-T],1)
//│       in let* (x%12[+X(C(O)C(S))-T]) = mk(x%11[-T])
//│         in let x%13[+C(S)-T] = S(x%12[+X(C(O)C(S))-T])
//│           in x%13[+C(S)-T]
//│     false => let x%14[+C(O)-T] = O()
//│       in x%14[+C(O)-T]
//│ )
//│ Def(3, foo, [], [],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%16[+X(C(O)C(S))-TIS(s)]) = mk(10)
//│   in let* (x%17[+X(C(False)C(True))-T]) = odd(x%16[+X(C(O)C(S))-TIS(s)])
//│     in x%17[+X(C(False)C(True))-T]
//│ )
//│ },
//│ let* (x%18) = foo()
//│   in x%18)
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ Fuel used: 1

:GraphInterp
:GraphOpt
class True
class False
class S(s)
class O
fun odd(x) =
  if x is
    O then False
    S(s) then even(s)
fun even(x) =
  if x is
    O then True
    S(s) then odd(s)
fun mk(n) = if n > 0 then S(mk(n - 1)) else O
fun foo() = odd(S(S(mk(10))))
foo()
//│ |#class| |True|↵|#class| |False|↵|#class| |S|(|s|)|↵|#class| |O|↵|#fun| |odd|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |False|↵|S|(|s|)| |#then| |even|(|s|)|←|←|↵|#fun| |even|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |True|↵|S|(|s|)| |#then| |odd|(|s|)|←|←|↵|#fun| |mk|(|n|)| |#=| |#if| |n| |>| |0| |#then| |S|(|mk|(|n| |-| |1|)|)| |#else| |O|↵|#fun| |foo|(||)| |#=| |odd|(|S|(|S|(|mk|(|10|)|)|)|)|↵|foo|(||)|
//│ Parsed: {class True {}; class False {}; class S(s,) {}; class O {}; fun odd = (x,) => {if x is ‹(O) then False; (S(s,)) then even(s,)›}; fun even = (x,) => {if x is ‹(O) then True; (S(s,)) then odd(s,)›}; fun mk = (n,) => if (>(n,)(0,)) then S(mk(-(n,)(1,),),) else O; fun foo = () => odd(S(S(mk(10,),),),); foo()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, True, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, False, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, S, (), Tup(_: Var(s)), (), None, None, TypingUnit()), NuTypeDef(class, O, (), Tup(), (), None, None, TypingUnit()), NuFunDef(None, odd, None, [], Lam(Tup(_: Var(x)), Blk(...))), NuFunDef(None, even, None, [], Lam(Tup(_: Var(x)), Blk(...))), NuFunDef(None, mk, None, [], Lam(Tup(_: Var(n)), If(IfThen(App(App(Var(>), Tup(_: Var(n))), Tup(_: IntLit(0))), App(Var(S), Tup(_: App(Var(mk), Tup(_: App(App(Var(-), Tup(_: Var(n))), Tup(_: IntLit(1))))))), Some(Var(O))))), NuFunDef(None, foo, None, [], Lam(Tup(), App(Var(odd), Tup(_: App(Var(S), Tup(_: App(Var(S), Tup(_: App(Var(mk), Tup(_: IntLit(10))))))))))), App(Var(foo), Tup()))
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let join j%0(x%4) = x%4
//│   in case x%0 of
//│     O => let x%1 = False()
//│       in jump j%0(x%1)
//│     S => let x%2 = x%0.s
//│       in let* (x%3) = even(x%2)
//│         in jump j%0(x%3)
//│ )
//│ Def(1, even, [x%5], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let join j%1(x%9) = x%9
//│   in case x%5 of
//│     O => let x%6 = True()
//│       in jump j%1(x%6)
//│     S => let x%7 = x%5.s
//│       in let* (x%8) = odd(x%7)
//│         in jump j%1(x%8)
//│ )
//│ Def(2, mk, [n%0], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let x%10 = >(n%0,0)
//│   in let join j%2(x%15) = x%15
//│     in if x%10
//│       true => let x%11 = -(n%0,1)
//│         in let* (x%12) = mk(x%11)
//│           in let x%13 = S(x%12)
//│             in jump j%2(x%13)
//│       false => let x%14 = O()
//│         in jump j%2(x%14)
//│ )
//│ Def(3, foo, [], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let* (x%16) = mk(10)
//│   in let x%17 = S(x%16)
//│     in let x%18 = S(x%17)
//│       in let* (x%19) = odd(x%18)
//│         in x%19
//│ )
//│ },
//│ let* (x%20) = foo()
//│   in x%20)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [[Some(ICtor(S))]],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%0[-DTS(s)] of
//│   O => let x%1[+C(False)-T] = False()
//│     in x%1[+C(False)-T]
//│   S => let x%2[-TIS(s)] = x%0[-DTS(s)].s
//│     in let* (x%3[+X(C(False)C(True))-T]) = even(x%2[-TIS(s)])
//│       in x%3[+X(C(False)C(True))-T]
//│ )
//│ Def(1, even, [x%5[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%5[-DTS(s)] of
//│   O => let x%6[+C(True)-T] = True()
//│     in x%6[+C(True)-T]
//│   S => let x%7[-TIS(s)] = x%5[-DTS(s)].s
//│     in let* (x%8[+X(C(False)C(True))-T]) = odd(x%7[-TIS(s)])
//│       in x%8[+X(C(False)C(True))-T]
//│ )
//│ Def(2, mk, [n%0[-T]], [{EDirect}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(O),ICtor(S)))], 1, 
//│ let x%10[-DT] = >(n%0[-T],0)
//│   in if x%10[-DT]
//│     true => let x%11[-T] = -(n%0[-T],1)
//│       in let* (x%12[+X(C(O)C(S))-T]) = mk(x%11[-T])
//│         in let x%13[+C(S)-T] = S(x%12[+X(C(O)C(S))-T])
//│           in x%13[+C(S)-T]
//│     false => let x%14[+C(O)-T] = O()
//│       in x%14[+C(O)-T]
//│ )
//│ Def(3, foo, [], [],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%16[+X(C(O)C(S))-T]) = mk(10)
//│   in let x%17[+C(S)-T] = S(x%16[+X(C(O)C(S))-T])
//│     in let x%18[+C(S)-TIS(s)] = S(x%17[+C(S)-T])
//│       in let* (x%19[+X(C(False)C(True))-T]) = odd(x%18[+C(S)-TIS(s)])
//│         in x%19[+X(C(False)C(True))-T]
//│ )
//│ },
//│ let* (x%20) = foo()
//│   in x%20)
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%0[-DTS(s)] of
//│   O => let x%1[+C(False)-T] = False()
//│     in x%1[+C(False)-T]
//│   S => let x%2[-TIS(s)] = x%0[-DTS(s)].s
//│     in let* (x%3[+X(C(False)C(True))-T]) = even(x%2[-TIS(s)])
//│       in x%3[+X(C(False)C(True))-T]
//│ )
//│ Def(1, even, [x%5[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%5[-DTS(s)] of
//│   O => let x%6[+C(True)-T] = True()
//│     in x%6[+C(True)-T]
//│   S => let x%7[-TIS(s)] = x%5[-DTS(s)].s
//│     in let* (x%8[+X(C(False)C(True))-T]) = odd(x%7[-TIS(s)])
//│       in x%8[+X(C(False)C(True))-T]
//│ )
//│ Def(2, mk, [n%0[-T]], [{EDirect}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(O),ICtor(S)))], 1, 
//│ let x%10[-DT] = >(n%0[-T],0)
//│   in if x%10[-DT]
//│     true => let x%11[-T] = -(n%0[-T],1)
//│       in let* (x%12[+X(C(O)C(S))-T]) = mk(x%11[-T])
//│         in let x%13[+C(S)-T] = S(x%12[+X(C(O)C(S))-T])
//│           in x%13[+C(S)-T]
//│     false => let x%14[+C(O)-T] = O()
//│       in x%14[+C(O)-T]
//│ )
//│ Def(3, foo, [], [],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%16[+X(C(O)C(S))-T]) = mk(10)
//│   in let x%17[+C(S)-TIS(s)] = S(x%16[+X(C(O)C(S))-T])
//│     in let* (x%19[+X(C(False)C(True))-T]) = odd$D%1$S%0(x%17[+C(S)-TIS(s)])
//│       in x%19[+X(C(False)C(True))-T]
//│ )
//│ Def(10, odd$D%1$S%0, [x%0_s], [{EDirect,EIndirectDestruct,ESelect(s)}],
//│ S: None,
//│ I: [[Some(ICtor(S))]],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%3[+X(C(False)C(True))-T]) = even(x%0_s[-TIS(s)])
//│   in x%3[+X(C(False)C(True))-T]
//│ )
//│ },
//│ let* (x%20[+X(C(False)C(True))]) = foo()
//│   in x%20[+X(C(False)C(True))])
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%0[-DTS(s)] of
//│   O => let x%1[+C(False)-T] = False()
//│     in x%1[+C(False)-T]
//│   S => let x%2[-TIS(s)] = x%0[-DTS(s)].s
//│     in let* (x%3[+X(C(False)C(True))-T]) = even(x%2[-TIS(s)])
//│       in x%3[+X(C(False)C(True))-T]
//│ )
//│ Def(1, even, [x%5[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%5[-DTS(s)] of
//│   O => let x%6[+C(True)-T] = True()
//│     in x%6[+C(True)-T]
//│   S => let x%7[-TIS(s)] = x%5[-DTS(s)].s
//│     in let* (x%8[+X(C(False)C(True))-T]) = odd(x%7[-TIS(s)])
//│       in x%8[+X(C(False)C(True))-T]
//│ )
//│ Def(2, mk, [n%0[-T]], [{EDirect}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(O),ICtor(S)))], 1, 
//│ let x%10[-DT] = >(n%0[-T],0)
//│   in if x%10[-DT]
//│     true => let x%11[-T] = -(n%0[-T],1)
//│       in let* (x%12[+X(C(O)C(S))-T]) = mk(x%11[-T])
//│         in let x%13[+C(S)-T] = S(x%12[+X(C(O)C(S))-T])
//│           in x%13[+C(S)-T]
//│     false => let x%14[+C(O)-T] = O()
//│       in x%14[+C(O)-T]
//│ )
//│ Def(3, foo, [], [],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%16[+X(C(O)C(S))-T]) = mk(10)
//│   in let x%17[+C(S)-TIS(s)] = S(x%16[+X(C(O)C(S))-T])
//│     in let* (x%19[+X(C(False)C(True))-T]) = odd$D%1$S%0$C%0(x%17[+C(S)-TIS(s)])
//│       in x%19[+X(C(False)C(True))-T]
//│ )
//│ Def(14, odd$D%1$S%0$C%0, [x%0_s], [{ESelect(s)}],
//│ S: Some([Some(ICtor(S))]),
//│ I: [[Some(ICtor(S))]],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let x%24 = x%0_s[-S(s)].s
//│   in let* (x%3[+X(C(False)C(True))-T]) = even$D%1$S%0(x%24[-TIS(s)])
//│     in x%3[+X(C(False)C(True))-T]
//│ )
//│ Def(15, even$D%1$S%0, [x%5_s], [{EDirect,EIndirectDestruct,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%8[+X(C(False)C(True))-T]) = odd(x%5_s[-TIS(s)])
//│   in x%8[+X(C(False)C(True))-T]
//│ )
//│ },
//│ let* (x%20[+X(C(False)C(True))]) = foo()
//│   in x%20[+X(C(False)C(True))])
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%0[-DTS(s)] of
//│   O => let x%1[+C(False)-T] = False()
//│     in x%1[+C(False)-T]
//│   S => let x%2[-TIS(s)] = x%0[-DTS(s)].s
//│     in let* (x%3[+X(C(False)C(True))-T]) = even(x%2[-TIS(s)])
//│       in x%3[+X(C(False)C(True))-T]
//│ )
//│ Def(1, even, [x%5[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%5[-DTS(s)] of
//│   O => let x%6[+C(True)-T] = True()
//│     in x%6[+C(True)-T]
//│   S => let x%7[-TIS(s)] = x%5[-DTS(s)].s
//│     in let* (x%8[+X(C(False)C(True))-T]) = odd(x%7[-TIS(s)])
//│       in x%8[+X(C(False)C(True))-T]
//│ )
//│ Def(2, mk, [n%0[-T]], [{EDirect}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(O),ICtor(S)))], 1, 
//│ let x%10[-DT] = >(n%0[-T],0)
//│   in if x%10[-DT]
//│     true => let x%11[-T] = -(n%0[-T],1)
//│       in let* (x%12[+X(C(O)C(S))-T]) = mk(x%11[-T])
//│         in let x%13[+C(S)-T] = S(x%12[+X(C(O)C(S))-T])
//│           in x%13[+C(S)-T]
//│     false => let x%14[+C(O)-T] = O()
//│       in x%14[+C(O)-T]
//│ )
//│ Def(3, foo, [], [],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%16[+X(C(O)C(S))-TIS(s)]) = mk(10)
//│   in let* (x%19[+X(C(False)C(True))-T]) = odd$D%1$S%0$C%0$S%0(x%16[+X(C(O)C(S))-TIS(s)])
//│     in x%19[+X(C(False)C(True))-T]
//│ )
//│ Def(15, even$D%1$S%0, [x%5_s], [{EDirect,EIndirectDestruct,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%8[+X(C(False)C(True))-T]) = odd(x%5_s[-TIS(s)])
//│   in x%8[+X(C(False)C(True))-T]
//│ )
//│ Def(16, odd$D%1$S%0$C%0$S%0, [x%0_s_s], [{EDirect,EIndirectDestruct,ESelect(s)}],
//│ S: None,
//│ I: [[Some(IMix(ICtor(O),ICtor(S)))]],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%3[+X(C(False)C(True))-T]) = even$D%1$S%0(x%0_s_s[-TIS(s)])
//│   in x%3[+X(C(False)C(True))-T]
//│ )
//│ },
//│ let* (x%20[+X(C(False)C(True))]) = foo()
//│   in x%20[+X(C(False)C(True))])
//│ 
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ Fuel used: 4

:GraphInterp
:GraphOpt
class True
class False
class S(s)
class O
fun odd(x) =
  if x is
    O then False
    S(s) then even(s)
fun even(x) =
  if x is
    O then True
    S(s) then odd(s)
fun foo() = odd(if 10 > 0 then S(O) else O)
fun bar() = if 10 > 0 then odd(S(O)) else odd(O)
fun main() =
  foo()
  bar()
main()
//│ |#class| |True|↵|#class| |False|↵|#class| |S|(|s|)|↵|#class| |O|↵|#fun| |odd|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |False|↵|S|(|s|)| |#then| |even|(|s|)|←|←|↵|#fun| |even|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |True|↵|S|(|s|)| |#then| |odd|(|s|)|←|←|↵|#fun| |foo|(||)| |#=| |odd|(|#if| |10| |>| |0| |#then| |S|(|O|)| |#else| |O|)|↵|#fun| |bar|(||)| |#=| |#if| |10| |>| |0| |#then| |odd|(|S|(|O|)|)| |#else| |odd|(|O|)|↵|#fun| |main|(||)| |#=|→|foo|(||)|↵|bar|(||)|←|↵|main|(||)|
//│ Parsed: {class True {}; class False {}; class S(s,) {}; class O {}; fun odd = (x,) => {if x is ‹(O) then False; (S(s,)) then even(s,)›}; fun even = (x,) => {if x is ‹(O) then True; (S(s,)) then odd(s,)›}; fun foo = () => odd(if (>(10,)(0,)) then S(O,) else O,); fun bar = () => if (>(10,)(0,)) then odd(S(O,),) else odd(O,); fun main = () => {foo(); bar()}; main()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, True, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, False, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, S, (), Tup(_: Var(s)), (), None, None, TypingUnit()), NuTypeDef(class, O, (), Tup(), (), None, None, TypingUnit()), NuFunDef(None, odd, None, [], Lam(Tup(_: Var(x)), Blk(...))), NuFunDef(None, even, None, [], Lam(Tup(_: Var(x)), Blk(...))), NuFunDef(None, foo, None, [], Lam(Tup(), App(Var(odd), Tup(_: If(IfThen(App(App(Var(>), Tup(_: IntLit(10))), Tup(_: IntLit(0))), App(Var(S), Tup(_: Var(O))), Some(Var(O))))))), NuFunDef(None, bar, None, [], Lam(Tup(), If(IfThen(App(App(Var(>), Tup(_: IntLit(10))), Tup(_: IntLit(0))), App(Var(odd), Tup(_: App(Var(S), Tup(_: Var(O))))), Some(App(Var(odd), Tup(_: Var(O))))))), NuFunDef(None, main, None, [], Lam(Tup(), Blk(...))), App(Var(main), Tup()))
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let join j%0(x%4) = x%4
//│   in case x%0 of
//│     O => let x%1 = False()
//│       in jump j%0(x%1)
//│     S => let x%2 = x%0.s
//│       in let* (x%3) = even(x%2)
//│         in jump j%0(x%3)
//│ )
//│ Def(1, even, [x%5], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let join j%1(x%9) = x%9
//│   in case x%5 of
//│     O => let x%6 = True()
//│       in jump j%1(x%6)
//│     S => let x%7 = x%5.s
//│       in let* (x%8) = odd(x%7)
//│         in jump j%1(x%8)
//│ )
//│ Def(2, foo, [], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let x%10 = >(10,0)
//│   in let join j%2(x%14) = let* (x%15) = odd(x%14)
//│         in x%15
//│     in if x%10
//│       true => let x%11 = O()
//│         in let x%12 = S(x%11)
//│           in jump j%2(x%12)
//│       false => let x%13 = O()
//│         in jump j%2(x%13)
//│ )
//│ Def(3, bar, [], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let x%16 = >(10,0)
//│   in let join j%3(x%22) = x%22
//│     in if x%16
//│       true => let x%17 = O()
//│         in let x%18 = S(x%17)
//│           in let* (x%19) = odd(x%18)
//│             in jump j%3(x%19)
//│       false => let x%20 = O()
//│         in let* (x%21) = odd(x%20)
//│           in jump j%3(x%21)
//│ )
//│ Def(4, main, [], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let* (x%23) = foo()
//│   in let* (x%24) = bar()
//│     in x%24
//│ )
//│ },
//│ let* (x%25) = main()
//│   in x%25)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [[Some(ICtor(S))],[Some(ICtor(O))]],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%0[-DTS(s)] of
//│   O => let x%1[+C(False)-T] = False()
//│     in x%1[+C(False)-T]
//│   S => let x%2[-TIS(s)] = x%0[-DTS(s)].s
//│     in let* (x%3[+X(C(False)C(True))-T]) = even(x%2[-TIS(s)])
//│       in x%3[+X(C(False)C(True))-T]
//│ )
//│ Def(1, even, [x%5[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%5[-DTS(s)] of
//│   O => let x%6[+C(True)-T] = True()
//│     in x%6[+C(True)-T]
//│   S => let x%7[-TIS(s)] = x%5[-DTS(s)].s
//│     in let* (x%8[+X(C(False)C(True))-T]) = odd(x%7[-TIS(s)])
//│       in x%8[+X(C(False)C(True))-T]
//│ )
//│ Def(2, foo, [], [],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let x%10[-DT] = >(10,0)
//│   in if x%10[-DT]
//│     true => let x%11[+C(O)-T] = O()
//│       in let x%12[+C(S)-TIS(s)] = S(x%11[+C(O)-T])
//│         in jump j%2(x%12[+C(S)-TIS(s)])
//│     false => let x%13[+C(O)-TIS(s)] = O()
//│       in jump j%2(x%13[+C(O)-TIS(s)])
//│ )
//│ Def(3, bar, [], [],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let x%16[-DT] = >(10,0)
//│   in if x%16[-DT]
//│     true => let x%17[+C(O)-T] = O()
//│       in let x%18[+C(S)-TIS(s)] = S(x%17[+C(O)-T])
//│         in let* (x%19[+X(C(False)C(True))-T]) = odd(x%18[+C(S)-TIS(s)])
//│           in x%19[+X(C(False)C(True))-T]
//│     false => let x%20[+C(O)-TIS(s)] = O()
//│       in let* (x%21[+X(C(False)C(True))-T]) = odd(x%20[+C(O)-TIS(s)])
//│         in x%21[+X(C(False)C(True))-T]
//│ )
//│ Def(4, main, [], [],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%23[+X(C(False)C(True))]) = foo()
//│   in let* (x%24[+X(C(False)C(True))-T]) = bar()
//│     in x%24[+X(C(False)C(True))-T]
//│ )
//│ Def(7, @join j%2, [x%14[-TIS(s)]], [{EDirect,EIndirectDestruct,ESelect(s)}],
//│ S: None,
//│ I: [[Some(ICtor(S))],[Some(ICtor(O))]],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%15[+X(C(False)C(True))-T]) = odd(x%14[-TIS(s)])
//│   in x%15[+X(C(False)C(True))-T]
//│ )
//│ },
//│ let* (x%25) = main()
//│   in x%25)
//│ 
//│ Interpreted ------------------------------
//│ True()
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%0[-DTS(s)] of
//│   O => let x%1[+C(False)-T] = False()
//│     in x%1[+C(False)-T]
//│   S => let x%2[-TIS(s)] = x%0[-DTS(s)].s
//│     in let* (x%3[+X(C(False)C(True))-T]) = even(x%2[-TIS(s)])
//│       in x%3[+X(C(False)C(True))-T]
//│ )
//│ Def(1, even, [x%5[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%5[-DTS(s)] of
//│   O => let x%6[+C(True)-T] = True()
//│     in x%6[+C(True)-T]
//│   S => let x%7[-TIS(s)] = x%5[-DTS(s)].s
//│     in let* (x%8[+X(C(False)C(True))-T]) = odd(x%7[-TIS(s)])
//│       in x%8[+X(C(False)C(True))-T]
//│ )
//│ Def(2, foo, [], [],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let x%10[-DT] = >(10,0)
//│   in if x%10[-DT]
//│     true => let x%11[+C(O)-T] = O()
//│       in let x%12[+C(S)-TIS(s)] = S(x%11[+C(O)-T])
//│         in jump j%2$C%0(x%12[+C(S)-TIS(s)])
//│     false => let x%13[+C(O)-TIS(s)] = O()
//│       in jump j%2$C%1(x%13[+C(O)-TIS(s)])
//│ )
//│ Def(3, bar, [], [],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let x%16[-DT] = >(10,0)
//│   in if x%16[-DT]
//│     true => let x%17[+C(O)-TIS(s)] = O()
//│       in let* (x%19[+X(C(False)C(True))-T]) = odd$D%1$S%0(x%17[+C(O)-TIS(s)])
//│         in x%19[+X(C(False)C(True))-T]
//│     false => let* (x%21[+C(False)-T]) = odd$D%0()
//│       in x%21[+C(False)-T]
//│ )
//│ Def(4, main, [], [],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%23[+X(C(False)C(True))]) = foo()
//│   in let* (x%24[+X(C(False)C(True))-T]) = bar()
//│     in x%24[+X(C(False)C(True))-T]
//│ )
//│ Def(10, odd$D%0, [], [],
//│ S: None,
//│ I: [],
//│ [Some(ICtor(False))], 1, 
//│ let x%1[+C(False)-T] = False()
//│   in x%1[+C(False)-T]
//│ )
//│ Def(12, @join j%2$C%0, [x%14[-TIS(s)]], [{ESelect(s)}],
//│ S: Some([Some(ICtor(S))]),
//│ I: [[Some(ICtor(S))]],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let x%30 = x%14[-S(s)].s
//│   in let* (x%15[+X(C(False)C(True))-T]) = odd$D%1$S%0(x%30[-TIS(s)])
//│     in x%15[+X(C(False)C(True))-T]
//│ )
//│ Def(13, @join j%2$C%1, [x%14[-TIS(s)]], [{}],
//│ S: Some([Some(ICtor(O))]),
//│ I: [[Some(ICtor(O))]],
//│ [Some(ICtor(False))], 1, 
//│ let* (x%15[+X(C(False)C(True))-T]) = odd$D%0()
//│   in x%15[+X(C(False)C(True))-T]
//│ )
//│ Def(14, odd$D%1$S%0, [x%0_s], [{EDirect,EIndirectDestruct,ESelect(s)}],
//│ S: None,
//│ I: [[Some(ICtor(O))]],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%3[+X(C(False)C(True))-T]) = even(x%0_s[-TIS(s)])
//│   in x%3[+X(C(False)C(True))-T]
//│ )
//│ },
//│ let* (x%25[+X(C(False)C(True))]) = main()
//│   in x%25[+X(C(False)C(True))])
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%0[-DTS(s)] of
//│   O => let x%1[+C(False)-T] = False()
//│     in x%1[+C(False)-T]
//│   S => let x%2[-TIS(s)] = x%0[-DTS(s)].s
//│     in let* (x%3[+C(True)-T]) = even(x%2[-TIS(s)])
//│       in x%3[+C(True)-T]
//│ )
//│ Def(1, even, [x%5[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%5[-DTS(s)] of
//│   O => let x%6[+C(True)-T] = True()
//│     in x%6[+C(True)-T]
//│   S => let x%7[-TIS(s)] = x%5[-DTS(s)].s
//│     in let* (x%8[+X(C(False)C(True))-T]) = odd(x%7[-TIS(s)])
//│       in x%8[+X(C(False)C(True))-T]
//│ )
//│ Def(2, foo, [], [],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let x%10[-DT] = >(10,0)
//│   in if x%10[-DT]
//│     true => let x%11[+C(O)-TIS(s)] = O()
//│       in jump j%2$C%0$S%0(x%11[+C(O)-TIS(s)])
//│     false => let x%13[+C(O)-TIS(s)] = O()
//│       in jump j%2$C%1(x%13[+C(O)-TIS(s)])
//│ )
//│ Def(3, bar, [], [],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let x%16[-DT] = >(10,0)
//│   in if x%16[-DT]
//│     true => let x%17[+C(O)-TIS(s)] = O()
//│       in let* (x%19[+C(True)-T]) = odd$D%1$S%0$C%0(x%17[+C(O)-TIS(s)])
//│         in x%19[+C(True)-T]
//│     false => let* (x%21[+C(False)-T]) = odd$D%0()
//│       in x%21[+C(False)-T]
//│ )
//│ Def(4, main, [], [],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%23[+X(C(False)C(True))]) = foo()
//│   in let* (x%24[+X(C(False)C(True))-T]) = bar()
//│     in x%24[+X(C(False)C(True))-T]
//│ )
//│ Def(10, odd$D%0, [], [],
//│ S: None,
//│ I: [],
//│ [Some(ICtor(False))], 1, 
//│ let x%1[+C(False)-T] = False()
//│   in x%1[+C(False)-T]
//│ )
//│ Def(13, @join j%2$C%1, [x%14[-TIS(s)]], [{}],
//│ S: Some([Some(ICtor(O))]),
//│ I: [[Some(ICtor(O))]],
//│ [Some(ICtor(False))], 1, 
//│ let* (x%15[+X(C(False)C(True))-T]) = odd$D%0()
//│   in x%15[+X(C(False)C(True))-T]
//│ )
//│ Def(14, odd$D%1$S%0, [x%0_s], [{EDirect,EIndirectDestruct,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%3[+C(True)-T]) = even(x%0_s[-TIS(s)])
//│   in x%3[+C(True)-T]
//│ )
//│ Def(16, even$D%0, [], [],
//│ S: None,
//│ I: [],
//│ [Some(ICtor(True))], 1, 
//│ let x%6[+C(True)-T] = True()
//│   in x%6[+C(True)-T]
//│ )
//│ Def(18, odd$D%1$S%0$C%0, [x%0_s], [{}],
//│ S: Some([Some(ICtor(O))]),
//│ I: [[Some(ICtor(O))]],
//│ [Some(ICtor(True))], 1, 
//│ let* (x%3[+C(True)-T]) = even$D%0()
//│   in x%3[+C(True)-T]
//│ )
//│ Def(19, @join j%2$C%0$S%0, [x%14_s], [{EDirect,EIndirectDestruct,ESelect(s)}],
//│ S: None,
//│ I: [[Some(ICtor(O))]],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%15[+X(C(False)C(True))-T]) = odd$D%1$S%0(x%14_s[-TIS(s)])
//│   in x%15[+X(C(False)C(True))-T]
//│ )
//│ },
//│ let* (x%25[+X(C(False)C(True))]) = main()
//│   in x%25[+X(C(False)C(True))])
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(0, odd, [x%0[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%0[-DTS(s)] of
//│   O => let x%1[+C(False)-T] = False()
//│     in x%1[+C(False)-T]
//│   S => let x%2[-TIS(s)] = x%0[-DTS(s)].s
//│     in let* (x%3[+C(True)-T]) = even(x%2[-TIS(s)])
//│       in x%3[+C(True)-T]
//│ )
//│ Def(1, even, [x%5[-DTS(s)]], [{EDestruct,EDirect,ESelect(s)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ case x%5[-DTS(s)] of
//│   O => let x%6[+C(True)-T] = True()
//│     in x%6[+C(True)-T]
//│   S => let x%7[-TIS(s)] = x%5[-DTS(s)].s
//│     in let* (x%8[+X(C(False)C(True))-T]) = odd(x%7[-TIS(s)])
//│       in x%8[+X(C(False)C(True))-T]
//│ )
//│ Def(2, foo, [], [],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let x%10[-DT] = >(10,0)
//│   in if x%10[-DT]
//│     true => let x%11[+C(O)-TIS(s)] = O()
//│       in jump j%2$C%0$S%0$C%0(x%11[+C(O)-TIS(s)])
//│     false => let x%13[+C(O)-TIS(s)] = O()
//│       in jump j%2$C%1(x%13[+C(O)-TIS(s)])
//│ )
//│ Def(3, bar, [], [],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let x%16[-DT] = >(10,0)
//│   in if x%16[-DT]
//│     true => let x%17[+C(O)-TIS(s)] = O()
//│       in let* (x%19[+C(True)-T]) = odd$D%1$S%0$C%0(x%17[+C(O)-TIS(s)])
//│         in x%19[+C(True)-T]
//│     false => let* (x%21[+C(False)-T]) = odd$D%0()
//│       in x%21[+C(False)-T]
//│ )
//│ Def(4, main, [], [],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%23[+X(C(False)C(True))]) = foo()
//│   in let* (x%24[+X(C(False)C(True))-T]) = bar()
//│     in x%24[+X(C(False)C(True))-T]
//│ )
//│ Def(10, odd$D%0, [], [],
//│ S: None,
//│ I: [],
//│ [Some(ICtor(False))], 1, 
//│ let x%1[+C(False)-T] = False()
//│   in x%1[+C(False)-T]
//│ )
//│ Def(13, @join j%2$C%1, [x%14[-TIS(s)]], [{}],
//│ S: Some([Some(ICtor(O))]),
//│ I: [[Some(ICtor(O))]],
//│ [Some(ICtor(False))], 1, 
//│ let* (x%15[+X(C(False)C(True))-T]) = odd$D%0()
//│   in x%15[+X(C(False)C(True))-T]
//│ )
//│ Def(14, odd$D%1$S%0, [x%0_s], [{EDirect,EIndirectDestruct,ESelect(s)}],
//│ S: None,
//│ I: [[Some(ICtor(O))]],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%3[+C(True)-T]) = even(x%0_s[-TIS(s)])
//│   in x%3[+C(True)-T]
//│ )
//│ Def(16, even$D%0, [], [],
//│ S: None,
//│ I: [],
//│ [Some(ICtor(True))], 1, 
//│ let x%6[+C(True)-T] = True()
//│   in x%6[+C(True)-T]
//│ )
//│ Def(18, odd$D%1$S%0$C%0, [x%0_s], [{}],
//│ S: Some([Some(ICtor(O))]),
//│ I: [[Some(ICtor(O))]],
//│ [Some(ICtor(True))], 1, 
//│ let* (x%3[+C(True)-T]) = even$D%0()
//│   in x%3[+C(True)-T]
//│ )
//│ Def(23, @join j%2$C%0$S%0$C%0, [x%14_s], [{EDirect,EIndirectDestruct,ESelect(s)}],
//│ S: Some([Some(ICtor(O))]),
//│ I: [[Some(ICtor(O))]],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%15[+X(C(False)C(True))-T]) = odd$D%1$S%0(x%14_s[-TIS(s)])
//│   in x%15[+X(C(False)C(True))-T]
//│ )
//│ },
//│ let* (x%25[+X(C(False)C(True))]) = main()
//│   in x%25[+X(C(False)C(True))])
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, S, [s]),ClassInfo(3, O, [])}, {
//│ Def(2, foo, [], [],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let x%10[-DT] = >(10,0)
//│   in if x%10[-DT]
//│     true => let x%11[+C(O)-TIS(s)] = O()
//│       in jump j%2$C%0$S%0$C%0$C%0(x%11[+C(O)-TIS(s)])
//│     false => let x%13[+C(O)-TIS(s)] = O()
//│       in jump j%2$C%1(x%13[+C(O)-TIS(s)])
//│ )
//│ Def(3, bar, [], [],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let x%16[-DT] = >(10,0)
//│   in if x%16[-DT]
//│     true => let x%17[+C(O)-TIS(s)] = O()
//│       in let* (x%19[+C(True)-T]) = odd$D%1$S%0$C%0(x%17[+C(O)-TIS(s)])
//│         in x%19[+C(True)-T]
//│     false => let* (x%21[+C(False)-T]) = odd$D%0()
//│       in x%21[+C(False)-T]
//│ )
//│ Def(4, main, [], [],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%23[+X(C(False)C(True))]) = foo()
//│   in let* (x%24[+X(C(False)C(True))-T]) = bar()
//│     in x%24[+X(C(False)C(True))-T]
//│ )
//│ Def(10, odd$D%0, [], [],
//│ S: None,
//│ I: [],
//│ [Some(ICtor(False))], 1, 
//│ let x%1[+C(False)-T] = False()
//│   in x%1[+C(False)-T]
//│ )
//│ Def(13, @join j%2$C%1, [x%14[-TIS(s)]], [{}],
//│ S: Some([Some(ICtor(O))]),
//│ I: [[Some(ICtor(O))]],
//│ [Some(ICtor(False))], 1, 
//│ let* (x%15[+C(False)-T]) = odd$D%0()
//│   in x%15[+C(False)-T]
//│ )
//│ Def(16, even$D%0, [], [],
//│ S: None,
//│ I: [],
//│ [Some(ICtor(True))], 1, 
//│ let x%6[+C(True)-T] = True()
//│   in x%6[+C(True)-T]
//│ )
//│ Def(18, odd$D%1$S%0$C%0, [x%0_s], [{}],
//│ S: Some([Some(ICtor(O))]),
//│ I: [[Some(ICtor(O))]],
//│ [Some(ICtor(True))], 1, 
//│ let* (x%3[+C(True)-T]) = even$D%0()
//│   in x%3[+C(True)-T]
//│ )
//│ Def(25, even$D%4, [], [],
//│ S: None,
//│ I: [],
//│ [Some(ICtor(True))], 1, 
//│ let x%6[+C(True)-T] = True()
//│   in x%6[+C(True)-T]
//│ )
//│ Def(27, odd$D%1$S%0$C%1, [x%0_s], [{}],
//│ S: Some([Some(ICtor(O))]),
//│ I: [[Some(ICtor(O))]],
//│ [Some(ICtor(True))], 1, 
//│ let* (x%3[+C(True)-T]) = even$D%4()
//│   in x%3[+C(True)-T]
//│ )
//│ Def(28, @join j%2$C%0$S%0$C%0$C%0, [x%14_s], [{EDirect}],
//│ S: Some([Some(ICtor(O))]),
//│ I: [[Some(ICtor(O))]],
//│ [Some(ICtor(True))], 1, 
//│ let* (x%15[+C(False)-T]) = odd$D%1$S%0$C%1(x%14_s[-TIS(s)])
//│   in x%15[+C(False)-T]
//│ )
//│ },
//│ let* (x%25[+X(C(False)C(True))]) = main()
//│   in x%25[+X(C(False)C(True))])
//│ 
//│ 
//│ Interpreted ------------------------------
//│ True()
//│ 
//│ 
//│ Fuel used: 5

:GraphInterp
:GraphOpt
class True
class False
class A()
class B(b)
fun aaa() =
  let m = 1
  let n = 2
  let p = 3
  let q = 4
  m + n - p + q
fun bbb() =
  let x = aaa()
  x * 100 + 4
fun not(x) =
  if x then False else True
fun foo(x) =
  if x then A else B(foo(not(x)))
fun main(flag) =
  let x = foo(flag)
  if x is
    A then aaa()
    B(b1) then bbb()
main(False)
//│ |#class| |True|↵|#class| |False|↵|#class| |A|(||)|↵|#class| |B|(|b|)|↵|#fun| |aaa|(||)| |#=|→|#let| |m| |#=| |1|↵|#let| |n| |#=| |2|↵|#let| |p| |#=| |3|↵|#let| |q| |#=| |4|↵|m| |+| |n| |-| |p| |+| |q|←|↵|#fun| |bbb|(||)| |#=|→|#let| |x| |#=| |aaa|(||)|↵|x| |*| |100| |+| |4|←|↵|#fun| |not|(|x|)| |#=|→|#if| |x| |#then| |False| |#else| |True|←|↵|#fun| |foo|(|x|)| |#=|→|#if| |x| |#then| |A| |#else| |B|(|foo|(|not|(|x|)|)|)|←|↵|#fun| |main|(|flag|)| |#=|→|#let| |x| |#=| |foo|(|flag|)|↵|#if| |x| |is|→|A| |#then| |aaa|(||)|↵|B|(|b1|)| |#then| |bbb|(||)|←|←|↵|main|(|False|)|
//│ Parsed: {class True {}; class False {}; class A() {}; class B(b,) {}; fun aaa = () => {let m = 1; let n = 2; let p = 3; let q = 4; +(-(+(m,)(n,),)(p,),)(q,)}; fun bbb = () => {let x = aaa(); +(*(x,)(100,),)(4,)}; fun not = (x,) => {if (x) then False else True}; fun foo = (x,) => {if (x) then A else B(foo(not(x,),),)}; fun main = (flag,) => {let x = foo(flag,); if x is ‹(A) then aaa(); (B(b1,)) then bbb()›}; main(False,)}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, True, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, False, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, A, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, B, (), Tup(_: Var(b)), (), None, None, TypingUnit()), NuFunDef(None, aaa, None, [], Lam(Tup(), Blk(...))), NuFunDef(None, bbb, None, [], Lam(Tup(), Blk(...))), NuFunDef(None, not, None, [], Lam(Tup(_: Var(x)), Blk(...))), NuFunDef(None, foo, None, [], Lam(Tup(_: Var(x)), Blk(...))), NuFunDef(None, main, None, [], Lam(Tup(_: Var(flag)), Blk(...))), App(Var(main), Tup(_: Var(False))))
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(0, aaa, [], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let x%0 = 1
//│   in let x%1 = 2
//│     in let x%2 = 3
//│       in let x%3 = 4
//│         in let x%4 = +(x%0,x%1)
//│           in let x%5 = -(x%4,x%2)
//│             in let x%6 = +(x%5,x%3)
//│               in x%6
//│ )
//│ Def(1, bbb, [], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let* (x%7) = aaa()
//│   in let x%8 = *(x%7,100)
//│     in let x%9 = +(x%8,4)
//│       in x%9
//│ )
//│ Def(2, not, [x%10], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let join j%0(x%13) = x%13
//│   in if x%10
//│     true => let x%11 = False()
//│       in jump j%0(x%11)
//│     false => let x%12 = True()
//│       in jump j%0(x%12)
//│ )
//│ Def(3, foo, [x%14], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let join j%1(x%19) = x%19
//│   in if x%14
//│     true => let x%15 = A()
//│       in jump j%1(x%15)
//│     false => let* (x%16) = not(x%14)
//│       in let* (x%17) = foo(x%16)
//│         in let x%18 = B(x%17)
//│           in jump j%1(x%18)
//│ )
//│ Def(4, main, [flag%0], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let* (x%20) = foo(flag%0)
//│   in let join j%2(x%24) = x%24
//│     in case x%20 of
//│       A => let* (x%21) = aaa()
//│         in jump j%2(x%21)
//│       B => let x%22 = x%20.b
//│         in let* (x%23) = bbb()
//│           in jump j%2(x%23)
//│ )
//│ },
//│ let x%25 = False()
//│   in let* (x%26) = main(x%25)
//│     in x%26)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(0, aaa, [], [],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let x%4[-T] = +(1,2)
//│   in let x%5[-T] = -(x%4[-T],3)
//│     in let x%6[-T] = +(x%5[-T],4)
//│       in x%6[-T]
//│ )
//│ Def(1, bbb, [], [],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let* (x%7[-T]) = aaa()
//│   in let x%8[-T] = *(x%7[-T],100)
//│     in let x%9[-T] = +(x%8[-T],4)
//│       in x%9[-T]
//│ )
//│ Def(2, not, [x%10[-DT]], [{EDestruct,EDirect}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ if x%10[-DT]
//│   true => let x%11[+C(False)-T] = False()
//│     in x%11[+C(False)-T]
//│   false => let x%12[+C(True)-T] = True()
//│     in x%12[+C(True)-T]
//│ )
//│ Def(3, foo, [x%14[-DTI]], [{EDestruct,EDirect,EIndirectDestruct}],
//│ S: None,
//│ I: [[Some(IMix(ICtor(False),ICtor(True)))]],
//│ [Some(IMix(ICtor(A),ICtor(B)))], 1, 
//│ if x%14[-DTI]
//│   true => let x%15[+C(A)-T] = A()
//│     in x%15[+C(A)-T]
//│   false => let* (x%16[+X(C(False)C(True))-TI]) = not(x%14[-DTI])
//│     in let* (x%17[+X(C(A)C(B))-T]) = foo(x%16[+X(C(False)C(True))-TI])
//│       in let x%18[+C(B)-T] = B(x%17[+X(C(A)C(B))-T])
//│         in x%18[+C(B)-T]
//│ )
//│ Def(4, main, [flag%0[-TI]], [{EDirect,EIndirectDestruct}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let* (x%20[+X(C(A)C(B))-DT]) = foo(flag%0[-TI])
//│   in case x%20[+X(C(A)C(B))-DT] of
//│     A => let* (x%21[-T]) = aaa()
//│       in x%21[-T]
//│     B => let* (x%23[-T]) = bbb()
//│       in x%23[-T]
//│ )
//│ },
//│ let x%25 = False()
//│   in let* (x%26) = main(x%25)
//│     in x%26)
//│ 
//│ Interpreted ------------------------------
//│ 404
//│ 
//│ 
//│ 
//│ Interpreted ------------------------------
//│ 404
//│ 
//│ 
//│ Fuel used: 1


:GraphInterp
:GraphOpt
class True
class False
class Cons(h, t)
class Nil
class Some(x)
class None
fun head_opt(l) =
  if l is
    Nil then None
    Cons(h, t) then Some(h)
fun is_empty(l) =
  if head_opt(l) is
    None then True
    Some(x) then False  
fun main() =
  is_empty(Cons(1, Cons(2, Nil)))
  is_empty(Nil)
main()
//│ |#class| |True|↵|#class| |False|↵|#class| |Cons|(|h|,| |t|)|↵|#class| |Nil|↵|#class| |Some|(|x|)|↵|#class| |None|↵|#fun| |head_opt|(|l|)| |#=|→|#if| |l| |is|→|Nil| |#then| |None|↵|Cons|(|h|,| |t|)| |#then| |Some|(|h|)|←|←|↵|#fun| |is_empty|(|l|)| |#=|→|#if| |head_opt|(|l|)| |is|→|None| |#then| |True|↵|Some|(|x|)| |#then| |False| |←|←|↵|#fun| |main|(||)| |#=|→|is_empty|(|Cons|(|1|,| |Cons|(|2|,| |Nil|)|)|)|↵|is_empty|(|Nil|)|←|↵|main|(||)|
//│ Parsed: {class True {}; class False {}; class Cons(h, t,) {}; class Nil {}; class Some(x,) {}; class None {}; fun head_opt = (l,) => {if l is ‹(Nil) then None; (Cons(h, t,)) then Some(h,)›}; fun is_empty = (l,) => {if head_opt(l,) is ‹(None) then True; (Some(x,)) then False›}; fun main = () => {is_empty(Cons(1, Cons(2, Nil,),),); is_empty(Nil,)}; main()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, True, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, False, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, Cons, (), Tup(_: Var(h), _: Var(t)), (), None, None, TypingUnit()), NuTypeDef(class, Nil, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, Some, (), Tup(_: Var(x)), (), None, None, TypingUnit()), NuTypeDef(class, None, (), Tup(), (), None, None, TypingUnit()), NuFunDef(None, head_opt, None, [], Lam(Tup(_: Var(l)), Blk(...))), NuFunDef(None, is_empty, None, [], Lam(Tup(_: Var(l)), Blk(...))), NuFunDef(None, main, None, [], Lam(Tup(), Blk(...))), App(Var(main), Tup()))
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(0, head_opt, [l%0], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let join j%0(x%4) = x%4
//│   in case l%0 of
//│     Nil => let x%0 = None()
//│       in jump j%0(x%0)
//│     Cons => let x%1 = l%0.t
//│       in let x%2 = l%0.h
//│         in let x%3 = Some(x%2)
//│           in jump j%0(x%3)
//│ )
//│ Def(1, is_empty, [l%1], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let* (x%5) = head_opt(l%1)
//│   in let join j%1(x%9) = x%9
//│     in case x%5 of
//│       None => let x%6 = True()
//│         in jump j%1(x%6)
//│       Some => let x%7 = x%5.x
//│         in let x%8 = False()
//│           in jump j%1(x%8)
//│ )
//│ Def(2, main, [], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let x%10 = Nil()
//│   in let x%11 = Cons(2,x%10)
//│     in let x%12 = Cons(1,x%11)
//│       in let* (x%13) = is_empty(x%12)
//│         in let x%14 = Nil()
//│           in let* (x%15) = is_empty(x%14)
//│             in x%15
//│ )
//│ },
//│ let* (x%16) = main()
//│   in x%16)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(0, head_opt, [l%0[-DTS(h)]], [{EDestruct,EDirect,ESelect(h)}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(None),ICtor(Some)))], 1, 
//│ case l%0[-DTS(h)] of
//│   Nil => let x%0[+C(None)-T] = None()
//│     in x%0[+C(None)-T]
//│   Cons => let x%2[-T] = l%0[-DTS(h)].h
//│     in let x%3[+C(Some)-T] = Some(x%2[-T])
//│       in x%3[+C(Some)-T]
//│ )
//│ Def(1, is_empty, [l%1[-TIS(h)]], [{EDirect,EIndirectDestruct,ESelect(h)}],
//│ S: None,
//│ I: [[Some(ICtor(Cons))],[Some(ICtor(Nil))]],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%5[+X(C(None)C(Some))-DT]) = head_opt(l%1[-TIS(h)])
//│   in case x%5[+X(C(None)C(Some))-DT] of
//│     None => let x%6[+C(True)-T] = True()
//│       in x%6[+C(True)-T]
//│     Some => let x%8[+C(False)-T] = False()
//│       in x%8[+C(False)-T]
//│ )
//│ Def(2, main, [], [],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let x%10[+C(Nil)-T] = Nil()
//│   in let x%11[+C(Cons)-T] = Cons(2,x%10[+C(Nil)-T])
//│     in let x%12[+C(Cons)-TIS(h)] = Cons(1,x%11[+C(Cons)-T])
//│       in let* (x%13[+X(C(False)C(True))]) = is_empty(x%12[+C(Cons)-TIS(h)])
//│         in let x%14[+C(Nil)-TIS(h)] = Nil()
//│           in let* (x%15[+X(C(False)C(True))-T]) = is_empty(x%14[+C(Nil)-TIS(h)])
//│             in x%15[+X(C(False)C(True))-T]
//│ )
//│ },
//│ let* (x%16) = main()
//│   in x%16)
//│ 
//│ Interpreted ------------------------------
//│ True()
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(2, main, [], [],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let x%10[+C(Nil)-T] = Nil()
//│   in let x%11[+C(Cons)-T] = Cons(2,x%10[+C(Nil)-T])
//│     in let x%12[+C(Cons)-TIS(h)] = Cons(1,x%11[+C(Cons)-T])
//│       in let* (x%13[+X(C(False)C(True))]) = is_empty$C%0(x%12[+C(Cons)-TIS(h)])
//│         in let x%14[+C(Nil)-TIS(h)] = Nil()
//│           in let* (x%15[+X(C(False)C(True))-T]) = is_empty$C%1(x%14[+C(Nil)-TIS(h)])
//│             in x%15[+X(C(False)C(True))-T]
//│ )
//│ Def(6, head_opt$D%0, [], [],
//│ S: None,
//│ I: [],
//│ [Some(ICtor(None))], 1, 
//│ let x%0[+C(None)-T] = None()
//│   in x%0[+C(None)-T]
//│ )
//│ Def(8, is_empty$C%0, [l%1[-TIS(h)]], [{ESelect(h)}],
//│ S: Some([Some(ICtor(Cons))]),
//│ I: [[Some(ICtor(Cons))]],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let x%19 = l%1[-S(h)].h
//│   in let* (x%5[+C(Some)-DT]) = head_opt$D%1$S%0(x%19[-T])
//│     in case x%5[+C(Some)-DT] of
//│       None => let x%6[+C(True)-T] = True()
//│         in x%6[+C(True)-T]
//│       Some => let x%8[+C(False)-T] = False()
//│         in x%8[+C(False)-T]
//│ )
//│ Def(9, is_empty$C%1, [l%1[-TIS(h)]], [{}],
//│ S: Some([Some(ICtor(Nil))]),
//│ I: [[Some(ICtor(Nil))]],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%5[+C(Some)-DT]) = head_opt$D%0()
//│   in case x%5[+C(Some)-DT] of
//│     None => let x%6[+C(True)-T] = True()
//│       in x%6[+C(True)-T]
//│     Some => let x%8[+C(False)-T] = False()
//│       in x%8[+C(False)-T]
//│ )
//│ Def(10, head_opt$D%1$S%0, [l%0_h], [{EDirect}],
//│ S: None,
//│ I: [],
//│ [Some(ICtor(Some))], 1, 
//│ let x%3[+C(Some)-T] = Some(l%0_h[-T])
//│   in x%3[+C(Some)-T]
//│ )
//│ },
//│ let* (x%16[+X(C(False)C(True))]) = main()
//│   in x%16[+X(C(False)C(True))])
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(2, main, [], [],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%13[+X(C(False)C(True))]) = is_empty$C%0$S%0(1)
//│   in let x%14[+C(Nil)-TIS(h)] = Nil()
//│     in let* (x%15[+X(C(False)C(True))-T]) = is_empty$C%1(x%14[+C(Nil)-TIS(h)])
//│       in x%15[+X(C(False)C(True))-T]
//│ )
//│ Def(6, head_opt$D%0, [], [],
//│ S: None,
//│ I: [],
//│ [Some(ICtor(None))], 1, 
//│ let x%0[+C(None)-T] = None()
//│   in x%0[+C(None)-T]
//│ )
//│ Def(9, is_empty$C%1, [l%1[-TIS(h)]], [{}],
//│ S: Some([Some(ICtor(Nil))]),
//│ I: [[Some(ICtor(Nil))]],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%5[+C(Some)-DT]) = head_opt$D%0()
//│   in case x%5[+C(Some)-DT] of
//│     None => let x%6[+C(True)-T] = True()
//│       in x%6[+C(True)-T]
//│     Some => let x%8[+C(False)-T] = False()
//│       in x%8[+C(False)-T]
//│ )
//│ Def(10, head_opt$D%1$S%0, [l%0_h], [{EDirect}],
//│ S: None,
//│ I: [],
//│ [Some(ICtor(Some))], 1, 
//│ let x%3[+C(Some)-T] = Some(l%0_h[-T])
//│   in x%3[+C(Some)-T]
//│ )
//│ Def(11, is_empty$C%0$S%0, [l%1_h], [{EDirect}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ let* (x%5[+C(Some)-DT]) = head_opt$D%1$S%0(l%1_h[-T])
//│   in case x%5[+C(Some)-DT] of
//│     None => let x%6[+C(True)-T] = True()
//│       in x%6[+C(True)-T]
//│     Some => let x%8[+C(False)-T] = False()
//│       in x%8[+C(False)-T]
//│ )
//│ },
//│ let* (x%16[+X(C(False)C(True))]) = main()
//│   in x%16[+X(C(False)C(True))])
//│ 
//│ 
//│ Interpreted ------------------------------
//│ True()
//│ 
//│ 
//│ Fuel used: 3

:GraphInterp
:GraphOpt
class True
class False
class Cons(h, t)
class Nil
class Some(x)
class None
fun mk_list(n) =
  if n == 0 then Nil else Cons(n, mk_list(n - 1))
fun head_opt() =
  if mk_list(10) is
    Nil then None
    Cons(h, t) then Some(h)
head_opt()
//│ |#class| |True|↵|#class| |False|↵|#class| |Cons|(|h|,| |t|)|↵|#class| |Nil|↵|#class| |Some|(|x|)|↵|#class| |None|↵|#fun| |mk_list|(|n|)| |#=|→|#if| |n| |==| |0| |#then| |Nil| |#else| |Cons|(|n|,| |mk_list|(|n| |-| |1|)|)|←|↵|#fun| |head_opt|(||)| |#=|→|#if| |mk_list|(|10|)| |is|→|Nil| |#then| |None|↵|Cons|(|h|,| |t|)| |#then| |Some|(|h|)|←|←|↵|head_opt|(||)|
//│ Parsed: {class True {}; class False {}; class Cons(h, t,) {}; class Nil {}; class Some(x,) {}; class None {}; fun mk_list = (n,) => {if (==(n,)(0,)) then Nil else Cons(n, mk_list(-(n,)(1,),),)}; fun head_opt = () => {if mk_list(10,) is ‹(Nil) then None; (Cons(h, t,)) then Some(h,)›}; head_opt()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, True, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, False, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, Cons, (), Tup(_: Var(h), _: Var(t)), (), None, None, TypingUnit()), NuTypeDef(class, Nil, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, Some, (), Tup(_: Var(x)), (), None, None, TypingUnit()), NuTypeDef(class, None, (), Tup(), (), None, None, TypingUnit()), NuFunDef(None, mk_list, None, [], Lam(Tup(_: Var(n)), Blk(...))), NuFunDef(None, head_opt, None, [], Lam(Tup(), Blk(...))), App(Var(head_opt), Tup()))
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(0, mk_list, [n%0], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let x%0 = ==(n%0,0)
//│   in let join j%0(x%5) = x%5
//│     in if x%0
//│       true => let x%1 = Nil()
//│         in jump j%0(x%1)
//│       false => let x%2 = -(n%0,1)
//│         in let* (x%3) = mk_list(x%2)
//│           in let x%4 = Cons(n%0,x%3)
//│             in jump j%0(x%4)
//│ )
//│ Def(1, head_opt, [], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let* (x%6) = mk_list(10)
//│   in let join j%1(x%11) = x%11
//│     in case x%6 of
//│       Nil => let x%7 = None()
//│         in jump j%1(x%7)
//│       Cons => let x%8 = x%6.t
//│         in let x%9 = x%6.h
//│           in let x%10 = Some(x%9)
//│             in jump j%1(x%10)
//│ )
//│ },
//│ let* (x%12) = head_opt()
//│   in x%12)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(0, mk_list, [n%0[-T]], [{EDirect}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(Cons),ICtor(Nil)))], 1, 
//│ let x%0[-DT] = ==(n%0[-T],0)
//│   in if x%0[-DT]
//│     true => let x%1[+C(Nil)-T] = Nil()
//│       in x%1[+C(Nil)-T]
//│     false => let x%2[-T] = -(n%0[-T],1)
//│       in let* (x%3[+X(C(Cons)C(Nil))-T]) = mk_list(x%2[-T])
//│         in let x%4[+C(Cons)-T] = Cons(n%0[-T],x%3[+X(C(Cons)C(Nil))-T])
//│           in x%4[+C(Cons)-T]
//│ )
//│ Def(1, head_opt, [], [],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(None),ICtor(Some)))], 1, 
//│ let* (x%6[+X(C(Cons)C(Nil))-DTS(h)]) = mk_list(10)
//│   in case x%6[+X(C(Cons)C(Nil))-DTS(h)] of
//│     Nil => let x%7[+C(None)-T] = None()
//│       in x%7[+C(None)-T]
//│     Cons => let x%9[-T] = x%6[+X(C(Cons)C(Nil))-DTS(h)].h
//│       in let x%10[+C(Some)-T] = Some(x%9[-T])
//│         in x%10[+C(Some)-T]
//│ )
//│ },
//│ let* (x%12) = head_opt()
//│   in x%12)
//│ 
//│ Interpreted ------------------------------
//│ Some(10)
//│ 
//│ 
//│ 
//│ Interpreted ------------------------------
//│ Some(10)
//│ 
//│ 
//│ Fuel used: 1
