:NewParser
:ParseOnly

:GraphInterp
:GraphOpt
class Pair(x, y)
fun mktup2(x, y) = mktup(x, y)
fun mktup(x, y) = Pair(x, y)
fun foo() =
  mktup2(1, 2)
foo()
//│ |#class| |Pair|(|x|,| |y|)|↵|#fun| |mktup2|(|x|,| |y|)| |#=| |mktup|(|x|,| |y|)|↵|#fun| |mktup|(|x|,| |y|)| |#=| |Pair|(|x|,| |y|)|↵|#fun| |foo|(||)| |#=|→|mktup2|(|1|,| |2|)|←|↵|foo|(||)|
//│ Parsed: {class Pair(x, y,) {}; fun mktup2 = (x, y,) => mktup(x, y,); fun mktup = (x, y,) => Pair(x, y,); fun foo = () => {mktup2(1, 2,)}; foo()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, mktup2, [x%0,y%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%1) = mktup(x%0,y%0) -- #7
//│   in x%1
//│ )
//│ Def(1, mktup, [x%2,y%1], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%3 = Pair(x%2,y%1) -- #14
//│   in x%3
//│ )
//│ Def(2, foo, [], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%4) = mktup2(1,2) -- #22
//│   in x%4
//│ )
//│ },
//│ let* (x%5) = foo() -- #26
//│   in x%5)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, mktup2, [x%0,y%0], [{<EDirect@mktup2:#29-let x%3 = ...>},{<EDirect@mktup2:#29-let x%3 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%3 = Pair(x%0,y%0) -- #29
//│   in let x%1 = x%3 -- #28
//│     in x%1
//│ )
//│ Def(2, foo, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%4) = mktup2(1,2) -- #22
//│   in x%4
//│ )
//│ },
//│ let* (x%5) = foo() -- #26
//│   in x%5)
//│ 
//│ Interpreted ------------------------------
//│ Pair(1,2)
//│ 
//│ 
//│ 
//│ Interpreted ------------------------------
//│ Pair(1,2)
//│ 
//│ 
//│ Fuel used: 1

:GraphInterp
:GraphOpt
class Pair(x, y)
fun foo(pair) =
  if pair is
    Pair(x, y) then Pair(x, y)
fun bar() =
  foo(Pair(1, 2))
bar()
//│ |#class| |Pair|(|x|,| |y|)|↵|#fun| |foo|(|pair|)| |#=|→|#if| |pair| |is|→|Pair|(|x|,| |y|)| |#then| |Pair|(|x|,| |y|)|←|←|↵|#fun| |bar|(||)| |#=|→|foo|(|Pair|(|1|,| |2|)|)|←|↵|bar|(||)|
//│ Parsed: {class Pair(x, y,) {}; fun foo = (pair,) => {if pair is ‹(Pair(x, y,)) then Pair(x, y,)›}; fun bar = () => {foo(Pair(1, 2,),)}; bar()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, foo, [pair%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case pair%0 of -- #16
//│   Pair => let x%0 = pair%0.y -- #14
//│     in let x%1 = pair%0.x -- #13
//│       in let x%2 = Pair(x%1,x%0) -- #12
//│         in jump j%0(x%2) -- #11
//│ )
//│ Def(1, @join j%0, [x%3], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%3
//│ )
//│ Def(2, bar, [], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%4 = Pair(1,2) -- #28
//│   in let* (x%5) = foo(x%4) -- #27
//│     in x%5
//│ )
//│ },
//│ let* (x%6) = bar() -- #32
//│   in x%6)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, foo, [pair%0], [{<EDestruct@foo:#16-case pair%0 of ...>,<EDirect@foo:#16-case pair%0 of ...>,<ESelect(x)@foo:#13-let x%1 = ...>,<ESelect(y)@foo:#14-let x%0 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(Pair))]],
//│ R: [Some(IMix(ICtor(Pair)))],
//│ Rec: None,
//│ 1, 
//│ case pair%0 of -- #16
//│   Pair => let x%0 = pair%0.y -- #14
//│     in let x%1 = pair%0.x -- #13
//│       in let x%2 = Pair(x%1,x%0) -- #12
//│         in x%2
//│ )
//│ Def(2, bar, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(Pair)))],
//│ Rec: None,
//│ 1, 
//│ let x%4 = Pair(1,2) -- #28
//│   in let* (x%5) = foo(x%4) -- #27
//│     in x%5
//│ )
//│ },
//│ let* (x%6) = bar() -- #32
//│   in x%6)
//│ 
//│ Interpreted ------------------------------
//│ Pair(1,2)
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(2, bar, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(Pair)))],
//│ Rec: None,
//│ 1, 
//│ let x%4 = Pair(1,2) -- #28
//│   in let x%7 = x%4 -- #39
//│     in case x%7 of -- #36
//│       Pair => let x%9 = x%7.y -- #41
//│         in let x%10 = x%7.x -- #40
//│           in let* (x%8) = foo$D%0$S%0(x%9,x%10) -- #35
//│             in x%8
//│ )
//│ Def(6, foo$D%0$S%0, [pair%0_y,pair%0_x], [{<EDirect@foo$D%0$S%0:#14-let x%0 = ...>},{<EDirect@foo$D%0$S%0:#13-let x%1 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(ICtor(Pair))],
//│ Rec: None,
//│ 1, 
//│ let x%0 = pair%0_y -- #14
//│   in let x%1 = pair%0_x -- #13
//│     in let x%2 = Pair(x%1,x%0) -- #12
//│       in x%2
//│ )
//│ },
//│ let* (x%6) = bar() -- #32
//│   in x%6)
//│ 
//│ 
//│ Interpreted ------------------------------
//│ Pair(1,2)
//│ 
//│ 
//│ Fuel used: 2



:GraphInterp
:GraphOpt
class Pair(x, y) {}
fun silly(pair) =
  let _ = 0
  let n = if pair is
    Pair(x1, x2) then
      if pair is
        Pair (x3, x4) then x3 + 1
  n + 1
fun foo() =
    let a = Pair(0, 1)
    let b = silly(a)
    b
foo()
//│ |#class| |Pair|(|x|,| |y|)| |{||}|↵|#fun| |silly|(|pair|)| |#=|→|#let| |_| |#=| |0|↵|#let| |n| |#=| |#if| |pair| |is|→|Pair|(|x1|,| |x2|)| |#then|→|#if| |pair| |is|→|Pair| |(|x3|,| |x4|)| |#then| |x3| |+| |1|←|←|←|↵|n| |+| |1|←|↵|#fun| |foo|(||)| |#=|→|#let| |a| |#=| |Pair|(|0|,| |1|)|↵|#let| |b| |#=| |silly|(|a|)|↵|b|←|↵|foo|(||)|
//│ Parsed: {class Pair(x, y,) {}; fun silly = (pair,) => {let _ = 0; let n = if pair is ‹(Pair(x1, x2,)) then {if pair is ‹(Pair(x3, x4,)) then +(x3,)(1,)›}›; +(n,)(1,)}; fun foo = () => {let a = Pair(0, 1,); let b = silly(a,); b}; foo()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, silly, [pair%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%0 = 0 -- #29
//│   in case pair%0 of -- #28
//│     Pair => let x%1 = pair%0.y -- #22
//│       in let x%2 = pair%0.x -- #21
//│         in case pair%0 of -- #20
//│           Pair => let x%3 = pair%0.y -- #17
//│             in let x%4 = pair%0.x -- #16
//│               in let x%5 = +(x%4,1) -- #15
//│                 in jump j%1(x%5) -- #14
//│ )
//│ Def(1, @join j%1, [x%6], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j%0(x%6) -- #19
//│ )
//│ Def(2, @join j%0, [x%7], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%8 = +(x%7,1) -- #27
//│   in x%8
//│ )
//│ Def(3, foo, [], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%9 = Pair(0,1) -- #43
//│   in let* (x%10) = silly(x%9) -- #42
//│     in x%10
//│ )
//│ },
//│ let* (x%11) = foo() -- #47
//│   in x%11)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, silly, [pair%0], [{<EDestruct@silly:#28-case pair%0 of ...>,<EDirect@silly:#28-case pair%0 of ...>,<ESelect(x)@silly:#16-let x%4 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(Pair))]],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case pair%0 of -- #28
//│   Pair => case pair%0 of -- #20
//│     Pair => let x%4 = pair%0.x -- #16
//│       in let x%5 = +(x%4,1) -- #15
//│         in let x%6 = x%5 -- #49
//│           in let x%8 = +(x%6,1) -- #51
//│             in x%8
//│ )
//│ Def(3, foo, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%9 = Pair(0,1) -- #43
//│   in let* (x%10) = silly(x%9) -- #42
//│     in x%10
//│ )
//│ },
//│ let* (x%11) = foo() -- #47
//│   in x%11)
//│ 
//│ Interpreted ------------------------------
//│ 2
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(3, foo, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%9 = Pair(0,1) -- #43
//│   in let x%12 = x%9 -- #57
//│     in case x%12 of -- #54
//│       Pair => let* (x%13) = silly$D%0(x%12) -- #53
//│         in x%13
//│ )
//│ Def(5, silly$D%0, [pair%0], [{<EDestruct@silly$D%0:#20-case pair%0 of ...>,<EDirect@silly$D%0:#20-case pair%0 of ...>,<ESelect(x)@silly$D%0:#16-let x%4 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(Pair))]],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case pair%0 of -- #20
//│   Pair => let x%4 = pair%0.x -- #16
//│     in let x%5 = +(x%4,1) -- #15
//│       in let x%6 = x%5 -- #49
//│         in let x%8 = +(x%6,1) -- #51
//│           in x%8
//│ )
//│ },
//│ let* (x%11) = foo() -- #47
//│   in x%11)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(3, foo, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%9 = Pair(0,1) -- #43
//│   in let x%12 = x%9 -- #57
//│     in case x%12 of -- #54
//│       Pair => let x%14 = x%12 -- #63
//│         in case x%14 of -- #60
//│           Pair => let x%16 = x%14.x -- #64
//│             in let* (x%15) = silly$D%0$D%0$S%0(x%16) -- #59
//│               in x%15
//│ )
//│ Def(10, silly$D%0$D%0$S%0, [pair%0_x], [{<EDirect@silly$D%0$D%0$S%0:#16-let x%4 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%4 = pair%0_x -- #16
//│   in let x%5 = +(x%4,1) -- #15
//│     in let x%6 = x%5 -- #49
//│       in let x%8 = +(x%6,1) -- #51
//│         in x%8
//│ )
//│ },
//│ let* (x%11) = foo() -- #47
//│   in x%11)
//│ 
//│ 
//│ Interpreted ------------------------------
//│ 2
//│ 
//│ 
//│ Fuel used: 3




:GraphInterp
:GraphOpt
class Pair(x, y)
fun inc_fst(pair) =
  let c = 2
  if pair is
    Pair(x1, x2) then x1 + c
fun foo() =
    let a = Pair(0, 1)
    let b = inc_fst(a)
    b
foo()
//│ |#class| |Pair|(|x|,| |y|)|↵|#fun| |inc_fst|(|pair|)| |#=|→|#let| |c| |#=| |2|↵|#if| |pair| |is|→|Pair|(|x1|,| |x2|)| |#then| |x1| |+| |c|←|←|↵|#fun| |foo|(||)| |#=|→|#let| |a| |#=| |Pair|(|0|,| |1|)|↵|#let| |b| |#=| |inc_fst|(|a|)|↵|b|←|↵|foo|(||)|
//│ Parsed: {class Pair(x, y,) {}; fun inc_fst = (pair,) => {let c = 2; if pair is ‹(Pair(x1, x2,)) then +(x1,)(c,)›}; fun foo = () => {let a = Pair(0, 1,); let b = inc_fst(a,); b}; foo()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, inc_fst, [pair%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%0 = 2 -- #15
//│   in case pair%0 of -- #14
//│     Pair => let x%1 = pair%0.y -- #12
//│       in let x%2 = pair%0.x -- #11
//│         in let x%3 = +(x%2,x%0) -- #10
//│           in jump j%0(x%3) -- #9
//│ )
//│ Def(1, @join j%0, [x%4], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%4
//│ )
//│ Def(2, foo, [], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%5 = Pair(0,1) -- #29
//│   in let* (x%6) = inc_fst(x%5) -- #28
//│     in x%6
//│ )
//│ },
//│ let* (x%7) = foo() -- #33
//│   in x%7)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, inc_fst, [pair%0], [{<EDestruct@inc_fst:#14-case pair%0 of ...>,<EDirect@inc_fst:#14-case pair%0 of ...>,<ESelect(x)@inc_fst:#11-let x%2 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(Pair))]],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%0 = 2 -- #15
//│   in case pair%0 of -- #14
//│     Pair => let x%2 = pair%0.x -- #11
//│       in let x%3 = +(x%2,x%0) -- #10
//│         in x%3
//│ )
//│ Def(2, foo, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%5 = Pair(0,1) -- #29
//│   in let* (x%6) = inc_fst(x%5) -- #28
//│     in x%6
//│ )
//│ },
//│ let* (x%7) = foo() -- #33
//│   in x%7)
//│ 
//│ Interpreted ------------------------------
//│ 2
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(2, foo, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%5 = Pair(0,1) -- #29
//│   in let* (x%8,x%9) = inc_fst$P%0(x%5) -- #38
//│     in case x%8 of -- #37
//│       Pair => let x%11 = x%8.x -- #40
//│         in let* (x%10) = inc_fst$D%0$S%0(x%9,x%11) -- #36
//│           in x%10
//│ )
//│ Def(3, inc_fst$P%0, [pair%0], [{<EDirect@inc_fst$P%0:#x-...>}],
//│ S: None,
//│ I: [[Some(ICtor(Pair))]],
//│ R: [None,None],
//│ Rec: None,
//│ 2, 
//│ let x%0 = 2 -- #15
//│   in pair%0,x%0
//│ )
//│ Def(6, inc_fst$D%0$S%0, [x%0,pair%0_x], [{<EDirect@inc_fst$D%0$S%0:#10-let x%3 = ...>},{<EDirect@inc_fst$D%0$S%0:#11-let x%2 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%2 = pair%0_x -- #11
//│   in let x%3 = +(x%2,x%0) -- #10
//│     in x%3
//│ )
//│ },
//│ let* (x%7) = foo() -- #33
//│   in x%7)
//│ 
//│ 
//│ Interpreted ------------------------------
//│ 2
//│ 
//│ 
//│ Fuel used: 2

:GraphInterp
:GraphOpt
class Pair(x, y)
fun inc_fst(pair) =
  let _ = 0
  if pair is
    Pair(x1, x2) then x2 + 1
fun foo() =
    let b = inc_fst(Pair(0, 1))
    b
foo()
//│ |#class| |Pair|(|x|,| |y|)|↵|#fun| |inc_fst|(|pair|)| |#=|→|#let| |_| |#=| |0|↵|#if| |pair| |is|→|Pair|(|x1|,| |x2|)| |#then| |x2| |+| |1|←|←|↵|#fun| |foo|(||)| |#=|→|#let| |b| |#=| |inc_fst|(|Pair|(|0|,| |1|)|)|↵|b|←|↵|foo|(||)|
//│ Parsed: {class Pair(x, y,) {}; fun inc_fst = (pair,) => {let _ = 0; if pair is ‹(Pair(x1, x2,)) then +(x2,)(1,)›}; fun foo = () => {let b = inc_fst(Pair(0, 1,),); b}; foo()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, inc_fst, [pair%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%0 = 0 -- #15
//│   in case pair%0 of -- #14
//│     Pair => let x%1 = pair%0.y -- #12
//│       in let x%2 = pair%0.x -- #11
//│         in let x%3 = +(x%1,1) -- #10
//│           in jump j%0(x%3) -- #9
//│ )
//│ Def(1, @join j%0, [x%4], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%4
//│ )
//│ Def(2, foo, [], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%5 = Pair(0,1) -- #28
//│   in let* (x%6) = inc_fst(x%5) -- #27
//│     in x%6
//│ )
//│ },
//│ let* (x%7) = foo() -- #32
//│   in x%7)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, inc_fst, [pair%0], [{<EDestruct@inc_fst:#14-case pair%0 of ...>,<EDirect@inc_fst:#14-case pair%0 of ...>,<ESelect(y)@inc_fst:#12-let x%1 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(Pair))]],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case pair%0 of -- #14
//│   Pair => let x%1 = pair%0.y -- #12
//│     in let x%3 = +(x%1,1) -- #10
//│       in x%3
//│ )
//│ Def(2, foo, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%5 = Pair(0,1) -- #28
//│   in let* (x%6) = inc_fst(x%5) -- #27
//│     in x%6
//│ )
//│ },
//│ let* (x%7) = foo() -- #32
//│   in x%7)
//│ 
//│ Interpreted ------------------------------
//│ 2
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(2, foo, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%5 = Pair(0,1) -- #28
//│   in let x%8 = x%5 -- #39
//│     in case x%8 of -- #36
//│       Pair => let x%10 = x%8.y -- #40
//│         in let* (x%9) = inc_fst$D%0$S%0(x%10) -- #35
//│           in x%9
//│ )
//│ Def(6, inc_fst$D%0$S%0, [pair%0_y], [{<EDirect@inc_fst$D%0$S%0:#12-let x%1 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%1 = pair%0_y -- #12
//│   in let x%3 = +(x%1,1) -- #10
//│     in x%3
//│ )
//│ },
//│ let* (x%7) = foo() -- #32
//│   in x%7)
//│ 
//│ 
//│ Interpreted ------------------------------
//│ 2
//│ 
//│ 
//│ Fuel used: 2

:GraphInterp
:GraphOpt
class Left(x)
class Right(y)
fun foo(a, b) =
  let t = if a is
    Left(x) then Left(x + 1)
    Right(y) then Right(b)
  if t is
    Left(x) then x
    Right(y) then y
fun bar() =
  foo(Right(2), 2)
bar()
//│ |#class| |Left|(|x|)|↵|#class| |Right|(|y|)|↵|#fun| |foo|(|a|,| |b|)| |#=|→|#let| |t| |#=| |#if| |a| |is|→|Left|(|x|)| |#then| |Left|(|x| |+| |1|)|↵|Right|(|y|)| |#then| |Right|(|b|)|←|↵|#if| |t| |is|→|Left|(|x|)| |#then| |x|↵|Right|(|y|)| |#then| |y|←|←|↵|#fun| |bar|(||)| |#=|→|foo|(|Right|(|2|)|,| |2|)|←|↵|bar|(||)|
//│ Parsed: {class Left(x,) {}; class Right(y,) {}; fun foo = (a, b,) => {let t = if a is ‹(Left(x,)) then Left(+(x,)(1,),); (Right(y,)) then Right(b,)›; if t is ‹(Left(x,)) then x; (Right(y,)) then y›}; fun bar = () => {foo(Right(2,), 2,)}; bar()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, Left, [x]),ClassInfo(1, Right, [y])}, {
//│ Def(0, foo, [a%0,b%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case a%0 of -- #36
//│   Left => let x%0 = a%0.x -- #12
//│     in let x%1 = +(x%0,1) -- #11
//│       in let x%2 = Left(x%1) -- #10
//│         in jump j%0(x%2) -- #9
//│   Right => let x%3 = a%0.y -- #21
//│     in let x%4 = Right(b%0) -- #20
//│       in jump j%0(x%4) -- #19
//│ )
//│ Def(1, @join j%0, [x%5], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x%5 of -- #35
//│   Left => let x%6 = x%5.x -- #28
//│     in jump j%1(x%6) -- #27
//│   Right => let x%7 = x%5.y -- #33
//│     in jump j%1(x%7) -- #32
//│ )
//│ Def(2, @join j%1, [x%8], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%8
//│ )
//│ Def(3, bar, [], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%9 = Right(2) -- #48
//│   in let* (x%10) = foo(x%9,2) -- #47
//│     in x%10
//│ )
//│ },
//│ let* (x%11) = bar() -- #52
//│   in x%11)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, Left, [x]),ClassInfo(1, Right, [y])}, {
//│ Def(0, foo, [a%0,b%0], [{<EDestruct@foo:#36-case a%0 of ...>,<EDirect@foo:#36-case a%0 of ...>,<ESelect(x)@foo:#12-let x%0 = ...>},{<EDirect@foo:#20-let x%4 = ...>}],
//│ S: None,
//│ I: [[None,Some(ICtor(Right))]],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case a%0 of -- #36
//│   Left => let x%0 = a%0.x -- #12
//│     in let x%1 = +(x%0,1) -- #11
//│       in let x%2 = Left(x%1) -- #10
//│         in jump j%0(x%2) -- #9
//│   Right => let x%4 = Right(b%0) -- #20
//│     in jump j%0(x%4) -- #19
//│ )
//│ Def(1, @join j%0, [x%5], [{<EDestruct@j%0:#35-case x%5 of ...>,<EDirect@j%0:#35-case x%5 of ...>,<ESelect(x)@j%0:#28-let x%6 = ...>,<ESelect(y)@j%0:#33-let x%7 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(Left))],[Some(ICtor(Right))]],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x%5 of -- #35
//│   Left => let x%6 = x%5.x -- #28
//│     in x%6
//│   Right => let x%7 = x%5.y -- #33
//│     in x%7
//│ )
//│ Def(3, bar, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%9 = Right(2) -- #48
//│   in let* (x%10) = foo(x%9,2) -- #47
//│     in x%10
//│ )
//│ },
//│ let* (x%11) = bar() -- #52
//│   in x%11)
//│ 
//│ Interpreted ------------------------------
//│ 2
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, Left, [x]),ClassInfo(1, Right, [y])}, {
//│ Def(1, @join j%0, [x%5], [{<EDestruct@j%0:#35-case x%5 of ...>,<EDirect@j%0:#35-case x%5 of ...>,<ESelect(x)@j%0:#28-let x%6 = ...>,<ESelect(y)@j%0:#33-let x%7 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(Right))],[Some(ICtor(Left))]],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x%5 of -- #35
//│   Left => let x%6 = x%5.x -- #28
//│     in x%6
//│   Right => let x%7 = x%5.y -- #33
//│     in x%7
//│ )
//│ Def(3, bar, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%9 = Right(2) -- #48
//│   in let x%14 = x%9 -- #78
//│     in let x%15 = 2 -- #77
//│       in case x%14 of -- #67
//│         Left => let x%18 = x%14.x -- #79
//│           in let* (x%16) = foo$D%0$S%0(x%18) -- #64
//│             in x%16
//│         Right => let* (x%17) = foo$D%1(x%15) -- #66
//│           in x%17
//│ )
//│ Def(9, foo$D%1, [b%0], [{<EDirect@foo$D%1:#20-let x%4 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%4 = Right(b%0) -- #20
//│   in jump j%0(x%4) -- #19
//│ )
//│ Def(11, foo$D%0$S%0, [a%0_x], [{<EDirect@foo$D%0$S%0:#12-let x%0 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%0 = a%0_x -- #12
//│   in let x%1 = +(x%0,1) -- #11
//│     in let x%2 = Left(x%1) -- #10
//│       in jump j%0(x%2) -- #9
//│ )
//│ },
//│ let* (x%11) = bar() -- #52
//│   in x%11)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, Left, [x]),ClassInfo(1, Right, [y])}, {
//│ Def(3, bar, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%9 = Right(2) -- #48
//│   in let x%14 = x%9 -- #78
//│     in let x%15 = 2 -- #77
//│       in case x%14 of -- #67
//│         Left => let x%18 = x%14.x -- #79
//│           in let* (x%16) = foo$D%0$S%0(x%18) -- #64
//│             in x%16
//│         Right => let* (x%17) = foo$D%1(x%15) -- #66
//│           in x%17
//│ )
//│ Def(9, foo$D%1, [b%0], [{<EDirect@foo$D%1:#20-let x%4 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%4 = Right(b%0) -- #20
//│   in let x%19 = x%4 -- #90
//│     in case x%19 of -- #82
//│       Left => let x%6 = x%19.x -- #88
//│         in x%6
//│       Right => let x%7 = x%19.y -- #89
//│         in x%7
//│ )
//│ Def(11, foo$D%0$S%0, [a%0_x], [{<EDirect@foo$D%0$S%0:#12-let x%0 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%0 = a%0_x -- #12
//│   in let x%1 = +(x%0,1) -- #11
//│     in let x%2 = Left(x%1) -- #10
//│       in let x%20 = x%2 -- #93
//│         in case x%20 of -- #86
//│           Left => let x%6 = x%20.x -- #91
//│             in x%6
//│           Right => let x%7 = x%20.y -- #92
//│             in x%7
//│ )
//│ },
//│ let* (x%11) = bar() -- #52
//│   in x%11)
//│ 
//│ 
//│ Interpreted ------------------------------
//│ 2
//│ 
//│ 
//│ Fuel used: 3

:GraphInterp
:GraphOpt
class True
class False
class Pair(x, y)
fun foo(a) = a.x + a.y
fun bar() =
  foo(Pair(1, 0))
bar()
//│ |#class| |True|↵|#class| |False|↵|#class| |Pair|(|x|,| |y|)|↵|#fun| |foo|(|a|)| |#=| |a|.x| |+| |a|.y|↵|#fun| |bar|(||)| |#=|→|foo|(|Pair|(|1|,| |0|)|)|←|↵|bar|(||)|
//│ Parsed: {class True {}; class False {}; class Pair(x, y,) {}; fun foo = (a,) => +((a).x,)((a).y,); fun bar = () => {foo(Pair(1, 0,),)}; bar()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Pair, [x,y])}, {
//│ Def(0, foo, [a%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%0 = a%0.x -- #7
//│   in let x%1 = a%0.y -- #6
//│     in let x%2 = +(x%0,x%1) -- #5
//│       in x%2
//│ )
//│ Def(1, bar, [], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%3 = Pair(1,0) -- #19
//│   in let* (x%4) = foo(x%3) -- #18
//│     in x%4
//│ )
//│ },
//│ let* (x%5) = bar() -- #23
//│   in x%5)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Pair, [x,y])}, {
//│ Def(0, foo, [a%0], [{<ESelect(x)@foo:#7-let x%0 = ...>,<ESelect(y)@foo:#6-let x%1 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(Pair))]],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%0 = a%0.x -- #7
//│   in let x%1 = a%0.y -- #6
//│     in let x%2 = +(x%0,x%1) -- #5
//│       in x%2
//│ )
//│ Def(1, bar, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%3 = Pair(1,0) -- #19
//│   in let* (x%4) = foo(x%3) -- #18
//│     in x%4
//│ )
//│ },
//│ let* (x%5) = bar() -- #23
//│   in x%5)
//│ 
//│ Interpreted ------------------------------
//│ 1
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Pair, [x,y])}, {
//│ Def(1, bar, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%6 = 0 -- #25
//│   in let x%7 = 1 -- #24
//│     in let* (x%4) = foo$S%0(x%6,x%7) -- #18
//│       in x%4
//│ )
//│ Def(2, foo$S%0, [a%0_y,a%0_x], [{<EDirect@foo$S%0:#6-let x%1 = ...>},{<EDirect@foo$S%0:#7-let x%0 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%0 = a%0_x -- #7
//│   in let x%1 = a%0_y -- #6
//│     in let x%2 = +(x%0,x%1) -- #5
//│       in x%2
//│ )
//│ },
//│ let* (x%5) = bar() -- #23
//│   in x%5)
//│ 
//│ 
//│ Interpreted ------------------------------
//│ 1
//│ 
//│ 
//│ Fuel used: 2


:GraphInterp
:GraphOpt
class C1(x, y)
class C2(z)
fun foo(a) = if a is
  C1(x, y) then x
  C2(z) then z
fun bar() =
  foo(C1(0, 1))
bar()
//│ |#class| |C1|(|x|,| |y|)|↵|#class| |C2|(|z|)|↵|#fun| |foo|(|a|)| |#=| |#if| |a| |is|→|C1|(|x|,| |y|)| |#then| |x|↵|C2|(|z|)| |#then| |z|←|↵|#fun| |bar|(||)| |#=|→|foo|(|C1|(|0|,| |1|)|)|←|↵|bar|(||)|
//│ Parsed: {class C1(x, y,) {}; class C2(z,) {}; fun foo = (a,) => if a is ‹(C1(x, y,)) then x; (C2(z,)) then z›; fun bar = () => {foo(C1(0, 1,),)}; bar()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, C1, [x,y]),ClassInfo(1, C2, [z])}, {
//│ Def(0, foo, [a%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case a%0 of -- #15
//│   C1 => let x%0 = a%0.y -- #8
//│     in let x%1 = a%0.x -- #7
//│       in jump j%0(x%1) -- #6
//│   C2 => let x%2 = a%0.z -- #13
//│     in jump j%0(x%2) -- #12
//│ )
//│ Def(1, @join j%0, [x%3], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%3
//│ )
//│ Def(2, bar, [], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%4 = C1(0,1) -- #27
//│   in let* (x%5) = foo(x%4) -- #26
//│     in x%5
//│ )
//│ },
//│ let* (x%6) = bar() -- #31
//│   in x%6)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, C1, [x,y]),ClassInfo(1, C2, [z])}, {
//│ Def(0, foo, [a%0], [{<EDestruct@foo:#15-case a%0 of ...>,<EDirect@foo:#15-case a%0 of ...>,<ESelect(x)@foo:#7-let x%1 = ...>,<ESelect(z)@foo:#13-let x%2 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(C1))]],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case a%0 of -- #15
//│   C1 => let x%1 = a%0.x -- #7
//│     in x%1
//│   C2 => let x%2 = a%0.z -- #13
//│     in x%2
//│ )
//│ Def(2, bar, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%4 = C1(0,1) -- #27
//│   in let* (x%5) = foo(x%4) -- #26
//│     in x%5
//│ )
//│ },
//│ let* (x%6) = bar() -- #31
//│   in x%6)
//│ 
//│ Interpreted ------------------------------
//│ 0
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, C1, [x,y]),ClassInfo(1, C2, [z])}, {
//│ Def(2, bar, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%4 = C1(0,1) -- #27
//│   in let x%7 = x%4 -- #48
//│     in case x%7 of -- #38
//│       C1 => let x%1 = x%7.x -- #43
//│         in let x%8 = x%1 -- #42
//│           in x%8
//│       C2 => let x%2 = x%7.z -- #47
//│         in let x%9 = x%2 -- #46
//│           in x%9
//│ )
//│ },
//│ let* (x%6) = bar() -- #31
//│   in x%6)
//│ 
//│ 
//│ Interpreted ------------------------------
//│ 0
//│ 
//│ 
//│ Fuel used: 2

:GraphInterp
:GraphOpt
class Pair(x, y)
fun foo(a, b) =
  let x1 = a.x
  let y1 = a.y
  let x2 = b.x
  let y2 = b.y
  x1 + y1 + x2 + y2
fun bar(c) =
  foo(Pair(0, 1), c)
  foo(c, Pair(2, 3))
  foo(Pair(0, 1), Pair(2, 3))
fun baz() =
  bar(Pair(4,5))
baz()
//│ |#class| |Pair|(|x|,| |y|)|↵|#fun| |foo|(|a|,| |b|)| |#=|→|#let| |x1| |#=| |a|.x|↵|#let| |y1| |#=| |a|.y|↵|#let| |x2| |#=| |b|.x|↵|#let| |y2| |#=| |b|.y|↵|x1| |+| |y1| |+| |x2| |+| |y2|←|↵|#fun| |bar|(|c|)| |#=|→|foo|(|Pair|(|0|,| |1|)|,| |c|)|↵|foo|(|c|,| |Pair|(|2|,| |3|)|)|↵|foo|(|Pair|(|0|,| |1|)|,| |Pair|(|2|,| |3|)|)|←|↵|#fun| |baz|(||)| |#=|→|bar|(|Pair|(|4|,|5|)|)|←|↵|baz|(||)|
//│ Parsed: {class Pair(x, y,) {}; fun foo = (a, b,) => {let x1 = (a).x; let y1 = (a).y; let x2 = (b).x; let y2 = (b).y; +(+(+(x1,)(y1,),)(x2,),)(y2,)}; fun bar = (c,) => {foo(Pair(0, 1,), c,); foo(c, Pair(2, 3,),); foo(Pair(0, 1,), Pair(2, 3,),)}; fun baz = () => {bar(Pair(4, 5,),)}; baz()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, foo, [a%0,b%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%0 = a%0.x -- #21
//│   in let x%1 = a%0.y -- #20
//│     in let x%2 = b%0.x -- #19
//│       in let x%3 = b%0.y -- #18
//│         in let x%4 = +(x%0,x%1) -- #17
//│           in let x%5 = +(x%4,x%2) -- #16
//│             in let x%6 = +(x%5,x%3) -- #15
//│               in x%6
//│ )
//│ Def(1, bar, [c%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%7 = Pair(0,1) -- #69
//│   in let* (x%8) = foo(x%7,c%0) -- #68
//│     in let x%9 = Pair(2,3) -- #67
//│       in let* (x%10) = foo(c%0,x%9) -- #66
//│         in let x%11 = Pair(0,1) -- #65
//│           in let x%12 = Pair(2,3) -- #64
//│             in let* (x%13) = foo(x%11,x%12) -- #63
//│               in x%13
//│ )
//│ Def(2, baz, [], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%14 = Pair(4,5) -- #81
//│   in let* (x%15) = bar(x%14) -- #80
//│     in x%15
//│ )
//│ },
//│ let* (x%16) = baz() -- #85
//│   in x%16)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, foo, [a%0,b%0], [{<ESelect(x)@foo:#21-let x%0 = ...>,<ESelect(y)@foo:#20-let x%1 = ...>},{<ESelect(x)@foo:#19-let x%2 = ...>,<ESelect(y)@foo:#18-let x%3 = ...>}],
//│ S: None,
//│ I: [[None,Some(ICtor(Pair))],[Some(ICtor(Pair)),Some(ICtor(Pair))]],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%0 = a%0.x -- #21
//│   in let x%1 = a%0.y -- #20
//│     in let x%2 = b%0.x -- #19
//│       in let x%3 = b%0.y -- #18
//│         in let x%4 = +(x%0,x%1) -- #17
//│           in let x%5 = +(x%4,x%2) -- #16
//│             in let x%6 = +(x%5,x%3) -- #15
//│               in x%6
//│ )
//│ Def(1, bar, [c%0], [{<EDirect@bar:#66-let* (x%10) = foo ...>,<EDirect@bar:#68-let* (x%8) = foo ...>,<ESelect(x)@foo:#19-let x%2 = ...>,<ESelect(x)@foo:#21-let x%0 = ...>,<ESelect(y)@foo:#18-let x%3 = ...>,<ESelect(y)@foo:#20-let x%1 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(Pair))]],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%7 = Pair(0,1) -- #69
//│   in let* (x%8) = foo(x%7,c%0) -- #68
//│     in let x%9 = Pair(2,3) -- #67
//│       in let* (x%10) = foo(c%0,x%9) -- #66
//│         in let x%11 = Pair(0,1) -- #65
//│           in let x%12 = Pair(2,3) -- #64
//│             in let* (x%13) = foo(x%11,x%12) -- #63
//│               in x%13
//│ )
//│ Def(2, baz, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%14 = Pair(4,5) -- #81
//│   in let* (x%15) = bar(x%14) -- #80
//│     in x%15
//│ )
//│ },
//│ let* (x%16) = baz() -- #85
//│   in x%16)
//│ 
//│ Interpreted ------------------------------
//│ 6
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(1, bar, [c%0], [{<ESelect(x)@bar:#90-let x%24 = ...>,<ESelect(x)@bar:#96-let x%18 = ...>,<ESelect(y)@bar:#91-let x%23 = ...>,<ESelect(y)@bar:#97-let x%17 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(Pair))]],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%17 = c%0.y -- #97
//│   in let x%18 = c%0.x -- #96
//│     in let x%19 = 1 -- #95
//│       in let x%20 = 0 -- #94
//│         in let* (x%8) = foo$S%0(x%17,x%18,x%19,x%20) -- #68
//│           in let x%21 = 3 -- #93
//│             in let x%22 = 2 -- #92
//│               in let x%23 = c%0.y -- #91
//│                 in let x%24 = c%0.x -- #90
//│                   in let* (x%10) = foo$S%0(x%21,x%22,x%23,x%24) -- #66
//│                     in let x%25 = 3 -- #89
//│                       in let x%26 = 2 -- #88
//│                         in let x%27 = 1 -- #87
//│                           in let x%28 = 0 -- #86
//│                             in let* (x%13) = foo$S%0(x%25,x%26,x%27,x%28) -- #63
//│                               in x%13
//│ )
//│ Def(2, baz, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%14 = Pair(4,5) -- #81
//│   in let* (x%15) = bar(x%14) -- #80
//│     in x%15
//│ )
//│ Def(3, foo$S%0, [b%0_y,b%0_x,a%0_y,a%0_x], [{<EDirect@foo$S%0:#18-let x%3 = ...>},{<EDirect@foo$S%0:#19-let x%2 = ...>},{<EDirect@foo$S%0:#20-let x%1 = ...>},{<EDirect@foo$S%0:#21-let x%0 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%0 = a%0_x -- #21
//│   in let x%1 = a%0_y -- #20
//│     in let x%2 = b%0_x -- #19
//│       in let x%3 = b%0_y -- #18
//│         in let x%4 = +(x%0,x%1) -- #17
//│           in let x%5 = +(x%4,x%2) -- #16
//│             in let x%6 = +(x%5,x%3) -- #15
//│               in x%6
//│ )
//│ },
//│ let* (x%16) = baz() -- #85
//│   in x%16)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(2, baz, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%29 = 5 -- #99
//│   in let x%30 = 4 -- #98
//│     in let* (x%15) = bar$S%0(x%29,x%30) -- #80
//│       in x%15
//│ )
//│ Def(3, foo$S%0, [b%0_y,b%0_x,a%0_y,a%0_x], [{<EDirect@foo$S%0:#18-let x%3 = ...>},{<EDirect@foo$S%0:#19-let x%2 = ...>},{<EDirect@foo$S%0:#20-let x%1 = ...>},{<EDirect@foo$S%0:#21-let x%0 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%0 = a%0_x -- #21
//│   in let x%1 = a%0_y -- #20
//│     in let x%2 = b%0_x -- #19
//│       in let x%3 = b%0_y -- #18
//│         in let x%4 = +(x%0,x%1) -- #17
//│           in let x%5 = +(x%4,x%2) -- #16
//│             in let x%6 = +(x%5,x%3) -- #15
//│               in x%6
//│ )
//│ Def(4, bar$S%0, [c%0_y,c%0_x], [{<EDirect@bar$S%0:#91-let x%23 = ...>,<EDirect@bar$S%0:#97-let x%17 = ...>},{<EDirect@bar$S%0:#90-let x%24 = ...>,<EDirect@bar$S%0:#96-let x%18 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%17 = c%0_y -- #97
//│   in let x%18 = c%0_x -- #96
//│     in let x%19 = 1 -- #95
//│       in let x%20 = 0 -- #94
//│         in let* (x%8) = foo$S%0(x%17,x%18,x%19,x%20) -- #68
//│           in let x%21 = 3 -- #93
//│             in let x%22 = 2 -- #92
//│               in let x%23 = c%0_y -- #91
//│                 in let x%24 = c%0_x -- #90
//│                   in let* (x%10) = foo$S%0(x%21,x%22,x%23,x%24) -- #66
//│                     in let x%25 = 3 -- #89
//│                       in let x%26 = 2 -- #88
//│                         in let x%27 = 1 -- #87
//│                           in let x%28 = 0 -- #86
//│                             in let* (x%13) = foo$S%0(x%25,x%26,x%27,x%28) -- #63
//│                               in x%13
//│ )
//│ },
//│ let* (x%16) = baz() -- #85
//│   in x%16)
//│ 
//│ 
//│ Interpreted ------------------------------
//│ 6
//│ 
//│ 
//│ Fuel used: 3

:GraphInterp
:GraphOpt
class Pair(x, y)
fun foo() =
  let p = Pair(0, 1)
  let b = p.x
  b
foo()
//│ |#class| |Pair|(|x|,| |y|)|↵|#fun| |foo|(||)| |#=|→|#let| |p| |#=| |Pair|(|0|,| |1|)|↵|#let| |b| |#=| |p|.x|↵|b|←|↵|foo|(||)|
//│ Parsed: {class Pair(x, y,) {}; fun foo = () => {let p = Pair(0, 1,); let b = (p).x; b}; foo()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, foo, [], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%0 = Pair(0,1) -- #10
//│   in let x%1 = x%0.x -- #9
//│     in x%1
//│ )
//│ },
//│ let* (x%2) = foo() -- #14
//│   in x%2)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, foo, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%1 = 0 -- #9
//│   in x%1
//│ )
//│ },
//│ let* (x%2) = foo() -- #14
//│   in x%2)
//│ 
//│ Interpreted ------------------------------
//│ 0
//│ 
//│ 
//│ 
//│ Interpreted ------------------------------
//│ 0
//│ 
//│ 
//│ Fuel used: 1

:GraphInterp
:GraphOpt
class S(s)
class O
fun foo() =
  bar(S(O))
fun bar(x) =
  baz(x)
fun baz(x) =
  if x is
    S(s) then s
    O then x
foo()
//│ |#class| |S|(|s|)|↵|#class| |O|↵|#fun| |foo|(||)| |#=|→|bar|(|S|(|O|)|)|←|↵|#fun| |bar|(|x|)| |#=|→|baz|(|x|)|←|↵|#fun| |baz|(|x|)| |#=|→|#if| |x| |is|→|S|(|s|)| |#then| |s|↵|O| |#then| |x|←|←|↵|foo|(||)|
//│ Parsed: {class S(s,) {}; class O {}; fun foo = () => {bar(S(O,),)}; fun bar = (x,) => {baz(x,)}; fun baz = (x,) => {if x is ‹(S(s,)) then s; (O) then x›}; foo()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, S, [s]),ClassInfo(1, O, [])}, {
//│ Def(0, foo, [], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%0 = O() -- #10
//│   in let x%1 = S(x%0) -- #9
//│     in let* (x%2) = bar(x%1) -- #8
//│       in x%2
//│ )
//│ Def(1, bar, [x%3], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%4) = baz(x%3) -- #16
//│   in x%4
//│ )
//│ Def(2, baz, [x%5], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x%5 of -- #26
//│   S => let x%6 = x%5.s -- #22
//│     in jump j%0(x%6) -- #21
//│   O => jump j%0(x%5) -- #24
//│ )
//│ Def(3, @join j%0, [x%7], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%7
//│ )
//│ },
//│ let* (x%8) = foo() -- #30
//│   in x%8)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, S, [s]),ClassInfo(1, O, [])}, {
//│ Def(0, foo, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(O)))],
//│ Rec: None,
//│ 1, 
//│ let x%0 = O() -- #10
//│   in let x%1 = S(x%0) -- #9
//│     in let* (x%2) = bar(x%1) -- #8
//│       in x%2
//│ )
//│ Def(1, bar, [x%3], [{<EDirect@bar:#16-let* (x%4) = baz ...>,<EIndirectDestruct@bar:#16-let* (x%4) = baz ...>,<ESelect(s)@baz:#22-let x%6 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(S))]],
//│ R: [Some(IMix(ICtor(O)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%4) = baz(x%3) -- #16
//│   in x%4
//│ )
//│ Def(2, baz, [x%5], [{<EDestruct@baz:#26-case x%5 of ...>,<EDirect@baz:#26-case x%5 of ...>,<EDirect@baz:#32-...>,<ESelect(s)@baz:#22-let x%6 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(O)))],
//│ Rec: None,
//│ 1, 
//│ case x%5 of -- #26
//│   S => let x%6 = x%5.s -- #22
//│     in x%6
//│   O => x%5
//│ )
//│ },
//│ let* (x%8) = foo() -- #30
//│   in x%8)
//│ 
//│ Interpreted ------------------------------
//│ O()
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, S, [s]),ClassInfo(1, O, [])}, {
//│ Def(0, foo, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%0 = O() -- #10
//│   in let x%1 = S(x%0) -- #9
//│     in let* (x%2) = bar(x%1) -- #8
//│       in x%2
//│ )
//│ Def(1, bar, [x%3], [{<EDirect@bar:#45-let x%9 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(S))]],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%9 = x%3 -- #45
//│   in case x%9 of -- #37
//│     S => let x%6 = x%9.s -- #42
//│       in let x%10 = x%6 -- #41
//│         in x%10
//│     O => let x%11 = x%9 -- #44
//│       in x%11
//│ )
//│ },
//│ let* (x%8) = foo() -- #30
//│   in x%8)
//│ 
//│ 
//│ Interpreted ------------------------------
//│ O()
//│ 
//│ 
//│ Fuel used: 2
