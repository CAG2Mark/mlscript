:NewParser
:ParseOnly

:GOInterp
:GraphOpt
class True
class False
class A()
class B(b)
fun aaa() =
  let m = 1
  let n = 2
  let p = 3
  let q = 4
  m + n - p + q
fun bbb() =
  let x = aaa()
  x * 100 + 4
fun not(x) =
  if x then False else True
fun foo(x) =
  if x then A
       else B(foo(not(x)))
fun main(flag) =
  let x = foo(flag)
  if x is
    A then aaa()
    B(b1) then bbb()
main(False)
//│ |#class| |True|↵|#class| |False|↵|#class| |A|(||)|↵|#class| |B|(|b|)|↵|#fun| |aaa|(||)| |#=|→|#let| |m| |#=| |1|↵|#let| |n| |#=| |2|↵|#let| |p| |#=| |3|↵|#let| |q| |#=| |4|↵|m| |+| |n| |-| |p| |+| |q|←|↵|#fun| |bbb|(||)| |#=|→|#let| |x| |#=| |aaa|(||)|↵|x| |*| |100| |+| |4|←|↵|#fun| |not|(|x|)| |#=|→|#if| |x| |#then| |False| |#else| |True|←|↵|#fun| |foo|(|x|)| |#=|→|#if| |x| |#then| |A|→|#else| |B|(|foo|(|not|(|x|)|)|)|←|←|↵|#fun| |main|(|flag|)| |#=|→|#let| |x| |#=| |foo|(|flag|)|↵|#if| |x| |is|→|A| |#then| |aaa|(||)|↵|B|(|b1|)| |#then| |bbb|(||)|←|←|↵|main|(|False|)|
//│ Parsed: {class True {}; class False {}; class A() {}; class B(b,) {}; fun aaa = () => {let m = 1; let n = 2; let p = 3; let q = 4; +(-(+(m,)(n,),)(p,),)(q,)}; fun bbb = () => {let x = aaa(); +(*(x,)(100,),)(4,)}; fun not = (x,) => {if (x) then False else True}; fun foo = (x,) => {if (x) then A else B(foo(not(x,),),)}; fun main = (flag,) => {let x = foo(flag,); if x is ‹(A) then aaa(); (B(b1,)) then bbb()›}; main(False,)}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, True, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, False, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, A, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, B, (), Tup(_: Var(b)), (), None, None, TypingUnit()), NuFunDef(None, aaa, None, [], Lam(Tup(), Blk(...))), NuFunDef(None, bbb, None, [], Lam(Tup(), Blk(...))), NuFunDef(None, not, None, [], Lam(Tup(_: Var(x)), Blk(...))), NuFunDef(None, foo, None, [], Lam(Tup(_: Var(x)), Blk(...))), NuFunDef(None, main, None, [], Lam(Tup(_: Var(flag)), Blk(...))), App(Var(main), Tup(_: Var(False))))
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(0, aaa, [], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let x%0 = 1
//│   in let x%1 = 2
//│     in let x%2 = 3
//│       in let x%3 = 4
//│         in let x%4 = +(x%0,x%1)
//│           in let x%5 = -(x%4,x%2)
//│             in let x%6 = +(x%5,x%3)
//│               in x%6
//│ )
//│ Def(1, bbb, [], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let* (x%7) = aaa()
//│   in let x%8 = *(x%7,100)
//│     in let x%9 = +(x%8,4)
//│       in x%9
//│ )
//│ Def(2, not, [x%10], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let join j%0(x%13) = x%13
//│   in if x%10
//│     true => let x%11 = False()
//│       in jump j%0(x%11)
//│     false => let x%12 = True()
//│       in jump j%0(x%12)
//│ )
//│ Def(3, foo, [x%14], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let join j%1(x%19) = x%19
//│   in if x%14
//│     true => let x%15 = A()
//│       in jump j%1(x%15)
//│     false => let* (x%16) = not(x%14)
//│       in let* (x%17) = foo(x%16)
//│         in let x%18 = B(x%17)
//│           in jump j%1(x%18)
//│ )
//│ Def(4, main, [flag%0], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let* (x%20) = foo(flag%0)
//│   in let join j%2(x%24) = x%24
//│     in case x%20 of
//│       A => let* (x%21) = aaa()
//│         in jump j%2(x%21)
//│       B => let x%22 = x%20.b
//│         in let* (x%23) = bbb()
//│           in jump j%2(x%23)
//│ )
//│ },
//│ let x%25 = False()
//│   in let* (x%26) = main(x%25)
//│     in x%26)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(0, aaa, [], [],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let x%4 = +(1,2)
//│   in let x%5 = -(x%4,3)
//│     in let x%6 = +(x%5,4)
//│       in x%6
//│ )
//│ Def(1, bbb, [], [],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let* (x%7) = aaa()
//│   in let x%8 = *(x%7,100)
//│     in let x%9 = +(x%8,4)
//│       in x%9
//│ )
//│ Def(2, not, [x%10], [{EDestruct,EDirect}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ if x%10
//│   true => let x%11 = False()
//│     in x%11
//│   false => let x%12 = True()
//│     in x%12
//│ )
//│ Def(3, foo, [x%14], [{EDestruct,EDirect,EIndirectDestruct}],
//│ S: None,
//│ I: [[Some(IMix(ICtor(False),ICtor(True)))]],
//│ [Some(IMix(ICtor(A),ICtor(B)))], 1, 
//│ if x%14
//│   true => let x%15 = A()
//│     in x%15
//│   false => let* (x%16) = not(x%14)
//│     in let* (x%17) = foo(x%16)
//│       in let x%18 = B(x%17)
//│         in x%18
//│ )
//│ Def(4, main, [flag%0], [{EDirect,EIndirectDestruct}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let* (x%20) = foo(flag%0)
//│   in case x%20 of
//│     A => let* (x%21) = aaa()
//│       in x%21
//│     B => let* (x%23) = bbb()
//│       in x%23
//│ )
//│ },
//│ let x%25 = False()
//│   in let* (x%26) = main(x%25)
//│     in x%26)
//│ 
//│ Interpreted ------------------------------
//│ 404
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(0, aaa, [], [],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let x%4 = +(1,2)
//│   in let x%5 = -(x%4,3)
//│     in let x%6 = +(x%5,4)
//│       in x%6
//│ )
//│ Def(1, bbb, [], [],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let* (x%7) = aaa()
//│   in let x%8 = *(x%7,100)
//│     in let x%9 = +(x%8,4)
//│       in x%9
//│ )
//│ Def(2, not, [x%10], [{EDestruct,EDirect}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ if x%10
//│   true => let x%11 = False()
//│     in x%11
//│   false => let x%12 = True()
//│     in x%12
//│ )
//│ Def(3, foo, [x%14], [{EDestruct,EDirect,EIndirectDestruct}],
//│ S: None,
//│ I: [[Some(IMix(ICtor(False),ICtor(True)))]],
//│ [Some(IMix(ICtor(A),ICtor(B)))], 1, 
//│ if x%14
//│   true => let x%15 = A()
//│     in x%15
//│   false => let* (x%16) = not(x%14)
//│     in let* (x%17) = foo(x%16)
//│       in let x%18 = B(x%17)
//│         in x%18
//│ )
//│ Def(4, main, [flag%0], [{EDestruct,EDirect,EIndirectDestruct}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ if flag%0
//│   true => let* (x%28) = foo$D%0()
//│     in jump main$Q%0(x%28)
//│   false => let* (x%29) = foo$D%1(flag%0)
//│     in jump main$Q%0(x%29)
//│ )
//│ Def(9, foo$D%0, [], [],
//│ S: None,
//│ I: [],
//│ [Some(ICtor(A))], 1, 
//│ let x%15 = A()
//│   in x%15
//│ )
//│ Def(10, foo$D%1, [x%14], [{EDirect,EIndirectDestruct}],
//│ S: None,
//│ I: [],
//│ [Some(ICtor(B))], 1, 
//│ let* (x%16) = not(x%14)
//│   in let* (x%17) = foo(x%16)
//│     in let x%18 = B(x%17)
//│       in x%18
//│ )
//│ Def(11, @join main$Q%0, [x%20], [{EDestruct,EDirect}],
//│ S: None,
//│ I: [[Some(ICtor(A))],[Some(ICtor(B))]],
//│ [None], 1, 
//│ case x%20 of
//│   A => let* (x%21) = aaa()
//│     in x%21
//│   B => let* (x%23) = bbb()
//│     in x%23
//│ )
//│ },
//│ let x%25 = False()
//│   in let* (x%26) = main(x%25)
//│     in x%26)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, []),ClassInfo(3, B, [b])}, {
//│ Def(0, aaa, [], [],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let x%4 = +(1,2)
//│   in let x%5 = -(x%4,3)
//│     in let x%6 = +(x%5,4)
//│       in x%6
//│ )
//│ Def(1, bbb, [], [],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let* (x%7) = aaa()
//│   in let x%8 = *(x%7,100)
//│     in let x%9 = +(x%8,4)
//│       in x%9
//│ )
//│ Def(2, not, [x%10], [{EDestruct,EDirect}],
//│ S: None,
//│ I: [],
//│ [Some(IMix(ICtor(False),ICtor(True)))], 1, 
//│ if x%10
//│   true => let x%11 = False()
//│     in x%11
//│   false => let x%12 = True()
//│     in x%12
//│ )
//│ Def(3, foo, [x%14], [{EDestruct,EDirect,EIndirectDestruct}],
//│ S: None,
//│ I: [[Some(IMix(ICtor(False),ICtor(True)))]],
//│ [Some(IMix(ICtor(A),ICtor(B)))], 1, 
//│ if x%14
//│   true => let x%15 = A()
//│     in x%15
//│   false => let* (x%16) = not(x%14)
//│     in let* (x%17) = foo(x%16)
//│       in let x%18 = B(x%17)
//│         in x%18
//│ )
//│ Def(4, main, [flag%0], [{EDestruct,EDirect,EIndirectDestruct}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ if flag%0
//│   true => let* (x%28) = foo$D%0()
//│     in jump main$Q%0$D%0()
//│   false => let* (x%29) = foo$D%1(flag%0)
//│     in jump main$Q%0$D%1()
//│ )
//│ Def(9, foo$D%0, [], [],
//│ S: None,
//│ I: [],
//│ [Some(ICtor(A))], 1, 
//│ let x%15 = A()
//│   in x%15
//│ )
//│ Def(10, foo$D%1, [x%14], [{EDirect,EIndirectDestruct}],
//│ S: None,
//│ I: [],
//│ [Some(ICtor(B))], 1, 
//│ let* (x%16) = not(x%14)
//│   in let* (x%17) = foo(x%16)
//│     in let x%18 = B(x%17)
//│       in x%18
//│ )
//│ Def(13, main$Q%0$D%0, [], [],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let* (x%21) = aaa()
//│   in x%21
//│ )
//│ Def(14, main$Q%0$D%1, [], [],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let* (x%23) = bbb()
//│   in x%23
//│ )
//│ },
//│ let x%25 = False()
//│   in let* (x%26) = main(x%25)
//│     in x%26)
//│ 
//│ 
//│ Interpreted ------------------------------
//│ 404
//│ 
//│ 
//│ Fuel used: 3
