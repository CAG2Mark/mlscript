:NewParser
:ParseOnly


:GraphInterp
:GraphOpt
class A(w, x)
class B(y)
class C(z)
fun complex_foo(t) =
  let a = 1 + 2 // 3
  let b = 1 * 2 // 2
  let x = if t is // x = A(9, B(10))
    A(x, y) then y
    B(x) then B(x + b)
    C(x) then C(0)
  let z = A(5, x) // z = A(5, A(9, B(10))
  let v = B(6) // v = B(6)
  let y = if x is // 14
    A(x, y) then
      let m = x + a + b // 9 + 3 + 2 = 14
      if y is
        A(x, y) then x
        B(x) then m // 14
        C(x) then 0
    B(x) then 2
    C(x) then 3
  if z is // 5
    A(x, y) then x
    B(x) then 4
    C(x) then
      if v is
        A(x, y) then x
        B(x) then 7
        C(x) then 8
fun bar() =
  complex_foo(A(10, A(9, B(10))))
bar()
//│ |#class| |A|(|w|,| |x|)|↵|#class| |B|(|y|)|↵|#class| |C|(|z|)|↵|#fun| |complex_foo|(|t|)| |#=|→|#let| |a| |#=| |1| |+| |2| |/* 3*/|↵|#let| |b| |#=| |1| |*| |2| |/* 2*/|↵|#let| |x| |#=| |#if| |t| |is| |/* x = A(9, B(10))*/|→|A|(|x|,| |y|)| |#then| |y|↵|B|(|x|)| |#then| |B|(|x| |+| |b|)|↵|C|(|x|)| |#then| |C|(|0|)|←|↵|#let| |z| |#=| |A|(|5|,| |x|)| |/* z = A(5, A(9, B(10))*/|↵|#let| |v| |#=| |B|(|6|)| |/* v = B(6)*/|↵|#let| |y| |#=| |#if| |x| |is| |/* 14*/|→|A|(|x|,| |y|)| |#then|→|#let| |m| |#=| |x| |+| |a| |+| |b| |/* 9 + 3 + 2 = 14*/|↵|#if| |y| |is|→|A|(|x|,| |y|)| |#then| |x|↵|B|(|x|)| |#then| |m| |/* 14*/|↵|C|(|x|)| |#then| |0|←|←|↵|B|(|x|)| |#then| |2|↵|C|(|x|)| |#then| |3|←|↵|#if| |z| |is| |/* 5*/|→|A|(|x|,| |y|)| |#then| |x|↵|B|(|x|)| |#then| |4|↵|C|(|x|)| |#then|→|#if| |v| |is|→|A|(|x|,| |y|)| |#then| |x|↵|B|(|x|)| |#then| |7|↵|C|(|x|)| |#then| |8|←|←|←|←|↵|#fun| |bar|(||)| |#=|→|complex_foo|(|A|(|10|,| |A|(|9|,| |B|(|10|)|)|)|)|←|↵|bar|(||)|
//│ Parsed: {class A(w, x,) {}; class B(y,) {}; class C(z,) {}; fun complex_foo = (t,) => {let a = +(1,)(2,); let b = *(1,)(2,); let x = if t is ‹(A(x, y,)) then y; (B(x,)) then B(+(x,)(b,),); (C(x,)) then C(0,)›; let z = A(5, x,); let v = B(6,); let y = if x is ‹(A(x, y,)) then {let m = +(+(x,)(a,),)(b,); if y is ‹(A(x, y,)) then x; (B(x,)) then m; (C(x,)) then 0›}; (B(x,)) then 2; (C(x,)) then 3›; if z is ‹(A(x, y,)) then x; (B(x,)) then 4; (C(x,)) then {if v is ‹(A(x, y,)) then x; (B(x,)) then 7; (C(x,)) then 8›}›}; fun bar = () => {complex_foo(A(10, A(9, B(10,),),),)}; bar()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, A, (), Tup(_: Var(w), _: Var(x)), (), None, None, TypingUnit()), NuTypeDef(class, B, (), Tup(_: Var(y)), (), None, None, TypingUnit()), NuTypeDef(class, C, (), Tup(_: Var(z)), (), None, None, TypingUnit()), NuFunDef(None, complex_foo, None, [], Lam(Tup(_: Var(t)), Blk(...))), NuFunDef(None, bar, None, [], Lam(Tup(), Blk(...))), App(Var(bar), Tup()))
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, A, [w,x]),ClassInfo(1, B, [y]),ClassInfo(2, C, [z])}, {
//│ Def(0, complex_foo, [t%0], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let x%0 = +(1,2)
//│   in let x%1 = *(1,2)
//│     in case t%0 of
//│       A => let x%2 = t%0.x
//│         in let x%3 = t%0.w
//│           in jump j%0(x%2)
//│       B => let x%4 = t%0.y
//│         in let x%5 = +(x%4,x%1)
//│           in let x%6 = B(x%5)
//│             in jump j%0(x%6)
//│       C => let x%7 = t%0.z
//│         in let x%8 = C(0)
//│           in jump j%0(x%8)
//│ )
//│ Def(1, @join j%0, [x%9], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let x%10 = A(5,x%9)
//│   in let x%11 = B(6)
//│     in case x%9 of
//│       A => let x%12 = x%9.x
//│         in let x%13 = x%9.w
//│           in let x%14 = +(x%13,x%0)
//│             in let x%15 = +(x%14,x%1)
//│               in case x%12 of
//│                 A => let x%16 = x%12.x
//│                   in let x%17 = x%12.w
//│                     in jump j%2(x%17)
//│                 B => let x%18 = x%12.y
//│                   in jump j%2(x%15)
//│                 C => let x%19 = x%12.z
//│                   in jump j%2(0)
//│       B => let x%21 = x%9.y
//│         in jump j%1(2)
//│       C => let x%22 = x%9.z
//│         in jump j%1(3)
//│ )
//│ Def(2, @join j%2, [x%20], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ jump j%1(x%20)
//│ )
//│ Def(3, @join j%1, [x%23], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ case x%10 of
//│   A => let x%24 = x%10.x
//│     in let x%25 = x%10.w
//│       in jump j%3(x%25)
//│   B => let x%26 = x%10.y
//│     in jump j%3(4)
//│   C => let x%27 = x%10.z
//│     in case x%11 of
//│       A => let x%28 = x%11.x
//│         in let x%29 = x%11.w
//│           in jump j%4(x%29)
//│       B => let x%30 = x%11.y
//│         in jump j%4(7)
//│       C => let x%31 = x%11.z
//│         in jump j%4(8)
//│ )
//│ Def(4, @join j%4, [x%32], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ jump j%3(x%32)
//│ )
//│ Def(5, @join j%3, [x%33], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ x%33
//│ )
//│ Def(6, bar, [], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let x%34 = B(10)
//│   in let x%35 = A(9,x%34)
//│     in let x%36 = A(10,x%35)
//│       in let* (x%37) = complex_foo(x%36)
//│         in x%37
//│ )
//│ },
//│ let* (x%38) = bar()
//│   in x%38)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, A, [w,x]),ClassInfo(1, B, [y]),ClassInfo(2, C, [z])}, {
//│ Def(0, complex_foo, [t%0], [{EDestruct,EDirect,ESelect(x),ESelect(y)}],
//│ S: None,
//│ I: [[Some(ICtor(A))]],
//│ [None], 1, 
//│ let x%0 = +(1,2)
//│   in let x%1 = *(1,2)
//│     in case t%0 of
//│       A => let x%2 = t%0.x
//│         in jump j%0(x%2)
//│       B => let x%4 = t%0.y
//│         in let x%5 = +(x%4,x%1)
//│           in let x%6 = B(x%5)
//│             in jump j%0(x%6)
//│       C => let x%8 = C(0)
//│         in jump j%0(x%8)
//│ )
//│ Def(1, @join j%0, [x%9], [{EDestruct,EDirect,ESelect(w),ESelect(x)}],
//│ S: None,
//│ I: [[Some(ICtor(B))],[Some(ICtor(C))]],
//│ [None], 1, 
//│ let x%10 = A(5,x%9)
//│   in let x%11 = B(6)
//│     in case x%9 of
//│       A => let x%12 = x%9.x
//│         in let x%13 = x%9.w
//│           in let x%14 = +(x%13,x%0)
//│             in let x%15 = +(x%14,x%1)
//│               in case x%12 of
//│                 A => let x%17 = x%12.w
//│                   in jump j%1(x%17)
//│                 B => jump j%1(x%15)
//│                 C => jump j%1(0)
//│       B => jump j%1(2)
//│       C => jump j%1(3)
//│ )
//│ Def(3, @join j%1, [x%23], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ case x%10 of
//│   A => let x%25 = x%10.w
//│     in x%25
//│   B => 4
//│   C => case x%11 of
//│     A => let x%29 = x%11.w
//│       in x%29
//│     B => 7
//│     C => 8
//│ )
//│ Def(6, bar, [], [],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let x%34 = B(10)
//│   in let x%35 = A(9,x%34)
//│     in let x%36 = A(10,x%35)
//│       in let* (x%37) = complex_foo(x%36)
//│         in x%37
//│ )
//│ },
//│ let* (x%38) = bar()
//│   in x%38)
//│ 
//│ Interpreted ------------------------------
//│ 5
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, A, [w,x]),ClassInfo(1, B, [y]),ClassInfo(2, C, [z])}, {
//│ Def(1, @join j%0, [x%9], [{EDestruct,EDirect,ESelect(w),ESelect(x)}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let x%10 = A(5,x%9)
//│   in let x%11 = B(6)
//│     in case x%9 of
//│       A => let x%12 = x%9.x
//│         in let x%13 = x%9.w
//│           in let x%14 = +(x%13,x%0)
//│             in let x%15 = +(x%14,x%1)
//│               in case x%12 of
//│                 A => let x%17 = x%12.w
//│                   in jump j%1(x%17)
//│                 B => jump j%1(x%15)
//│                 C => jump j%1(0)
//│       B => jump j%1(2)
//│       C => jump j%1(3)
//│ )
//│ Def(3, @join j%1, [x%23], [{}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ case x%10 of
//│   A => let x%25 = x%10.w
//│     in x%25
//│   B => 4
//│   C => case x%11 of
//│     A => let x%29 = x%11.w
//│       in x%29
//│     B => 7
//│     C => 8
//│ )
//│ Def(6, bar, [], [],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let x%34 = B(10)
//│   in let x%35 = A(9,x%34)
//│     in let x%36 = A(10,x%35)
//│       in let* (x%54,x%55,x%56) = complex_foo$P%0(x%36)
//│         in let* (x%37) = complex_foo$D%0(x%54,x%55,x%56)
//│           in x%37
//│ )
//│ Def(11, complex_foo$P%0, [t%0], [{EDirect}],
//│ S: None,
//│ I: [[Some(ICtor(A))]],
//│ [None,None,None], 3, 
//│ let x%0 = +(1,2)
//│   in let x%1 = *(1,2)
//│     in t%0,x%0,x%1
//│ )
//│ Def(12, complex_foo$D%0, [t%0,x%0,x%1], [{ESelect(x)},{EDirect},{EDirect}],
//│ S: None,
//│ I: [],
//│ [None], 1, 
//│ let x%2 = t%0.x
//│   in jump j%0(x%2)
//│ )
//│ },
//│ let* (x%38) = bar()
//│   in x%38)
//│ 
//│ 
//│ Interpreted ------------------------------
//│ 5
//│ 
//│ 
//│ Fuel used: 2
