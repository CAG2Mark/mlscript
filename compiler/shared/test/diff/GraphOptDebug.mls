:NewParser
:ParseOnly


:GraphInterp
:GraphOpt
class True
class False
class Cons(h, t)
class Nil
class Some(x)
class None
fun mk_list(n) =
  if n == 0 then Nil else Cons(n, mk_list(n - 1))
fun head_opt(l) =
  if l is
    Nil then None
    Cons(h, t) then Some(h)
fun is_none(o) =
  if o is
    None then True
    Some(x) then False
fun is_empty(l) =
  is_none(head_opt(l))
fun main() =
  is_empty(mk_list(10))
main()
//│ |#class| |True|↵|#class| |False|↵|#class| |Cons|(|h|,| |t|)|↵|#class| |Nil|↵|#class| |Some|(|x|)|↵|#class| |None|↵|#fun| |mk_list|(|n|)| |#=|→|#if| |n| |==| |0| |#then| |Nil| |#else| |Cons|(|n|,| |mk_list|(|n| |-| |1|)|)|←|↵|#fun| |head_opt|(|l|)| |#=|→|#if| |l| |is|→|Nil| |#then| |None|↵|Cons|(|h|,| |t|)| |#then| |Some|(|h|)|←|←|↵|#fun| |is_none|(|o|)| |#=|→|#if| |o| |is|→|None| |#then| |True|↵|Some|(|x|)| |#then| |False|←|←|↵|#fun| |is_empty|(|l|)| |#=|→|is_none|(|head_opt|(|l|)|)|←|↵|#fun| |main|(||)| |#=|→|is_empty|(|mk_list|(|10|)|)|←|↵|main|(||)|
//│ Parsed: {class True {}; class False {}; class Cons(h, t,) {}; class Nil {}; class Some(x,) {}; class None {}; fun mk_list = (n,) => {if (==(n,)(0,)) then Nil else Cons(n, mk_list(-(n,)(1,),),)}; fun head_opt = (l,) => {if l is ‹(Nil) then None; (Cons(h, t,)) then Some(h,)›}; fun is_none = (o,) => {if o is ‹(None) then True; (Some(x,)) then False›}; fun is_empty = (l,) => {is_none(head_opt(l,),)}; fun main = () => {is_empty(mk_list(10,),)}; main()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(0, mk_list, [n%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%0 = ==(n%0,0) -- #24
//│   in if x%0 -- #23
//│     true => let x%2 = Nil() -- #6
//│       in jump j%0(x%2) -- #5
//│     false => let x%3 = -(n%0,1) -- #22
//│       in let* (x%4) = mk_list(x%3) -- #21
//│         in let x%5 = Cons(n%0,x%4) -- #20
//│           in jump j%0(x%5) -- #19
//│ )
//│ Def(1, @join j%0, [x%1], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%1 -- #3
//│ )
//│ Def(2, head_opt, [l%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case l%0 of -- #42
//│   Nil => let x%7 = None() -- #29
//│     in jump j%1(x%7) -- #28
//│   Cons => let x%8 = l%0.t -- #41
//│     in let x%9 = l%0.h -- #40
//│       in let x%10 = Some(x%9) -- #39
//│         in jump j%1(x%10) -- #38
//│ )
//│ Def(3, @join j%1, [x%6], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%6 -- #26
//│ )
//│ Def(4, is_none, [o%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case o%0 of -- #54
//│   None => let x%12 = True() -- #47
//│     in jump j%2(x%12) -- #46
//│   Some => let x%13 = o%0.x -- #53
//│     in let x%14 = False() -- #52
//│       in jump j%2(x%14) -- #51
//│ )
//│ Def(5, @join j%2, [x%11], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%11 -- #44
//│ )
//│ Def(6, is_empty, [l%1], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%15) = head_opt(l%1) -- #65
//│   in let* (x%16) = is_none(x%15) -- #64
//│     in x%16 -- #63
//│ )
//│ Def(7, main, [], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%17) = mk_list(10) -- #76
//│   in let* (x%18) = is_empty(x%17) -- #75
//│     in x%18 -- #74
//│ )
//│ },
//│ let* (x%19) = main() -- #80
//│   in x%19 -- #79)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(0, mk_list, [n%0], [{<EDirect@mk_list:#22-let x%3 = ...>,<EDirect@mk_list:#24-let x%0 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(Cons),ICtor(Nil)))],
//│ Rec: Some(4),
//│ 1, 
//│ let x%0 = ==(n%0,0) -- #24
//│   in if x%0 -- #23
//│     true => let x%2 = Nil() -- #6
//│       in x%2 -- #81
//│     false => let x%3 = -(n%0,1) -- #22
//│       in let* (x%4) = mk_list(x%3) -- #21
//│         in let x%5 = Cons(n%0,x%4) -- #20
//│           in x%5 -- #82
//│ )
//│ Def(2, head_opt, [l%0], [{<EDestruct@head_opt:#42-case l%0 of ...>,<EDirect@head_opt:#42-case l%0 of ...>,<ESelect(h)@head_opt:#40-let x%9 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(None),ICtor(Some)))],
//│ Rec: None,
//│ 1, 
//│ case l%0 of -- #42
//│   Nil => let x%7 = None() -- #29
//│     in x%7 -- #83
//│   Cons => let x%9 = l%0.h -- #40
//│     in let x%10 = Some(x%9) -- #39
//│       in x%10 -- #84
//│ )
//│ Def(4, is_none, [o%0], [{<EDestruct@is_none:#54-case o%0 of ...>,<EDirect@is_none:#54-case o%0 of ...>}],
//│ S: None,
//│ I: [[Some(IMix(ICtor(None),ICtor(Some)))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ case o%0 of -- #54
//│   None => let x%12 = True() -- #47
//│     in x%12 -- #85
//│   Some => let x%14 = False() -- #52
//│     in x%14 -- #86
//│ )
//│ Def(6, is_empty, [l%1], [{<EDirect@is_empty:#65-let* (x%15) = head_opt ...>,<EIndirectDestruct@is_empty:#65-let* (x%15) = head_opt ...>,<ESelect(h)@head_opt:#40-let x%9 = ...>}],
//│ S: None,
//│ I: [[Some(IMix(ICtor(Cons),ICtor(Nil)))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%15) = head_opt(l%1) -- #65
//│   in let* (x%16) = is_none(x%15) -- #64
//│     in x%16 -- #63
//│ )
//│ Def(7, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%17) = mk_list(10) -- #76
//│   in let* (x%18) = is_empty(x%17) -- #75
//│     in x%18 -- #74
//│ )
//│ },
//│ let* (x%19) = main() -- #80
//│   in x%19 -- #79)
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(0, mk_list, [n%0], [{<EDirect@mk_list:#22-let x%3 = ...>,<EDirect@mk_list:#24-let x%0 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(Cons),ICtor(Nil)))],
//│ Rec: Some(4),
//│ 1, 
//│ let x%0 = ==(n%0,0) -- #24
//│   in if x%0 -- #23
//│     true => let x%2 = Nil() -- #6
//│       in x%2 -- #81
//│     false => let x%3 = -(n%0,1) -- #22
//│       in let* (x%4) = mk_list(x%3) -- #21
//│         in let x%5 = Cons(n%0,x%4) -- #20
//│           in x%5 -- #82
//│ )
//│ Def(4, is_none, [o%0], [{<EDestruct@is_none:#54-case o%0 of ...>,<EDirect@is_none:#54-case o%0 of ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ case o%0 of -- #54
//│   None => let x%12 = True() -- #47
//│     in x%12 -- #85
//│   Some => let x%14 = False() -- #52
//│     in x%14 -- #86
//│ )
//│ Def(6, is_empty, [l%1], [{<EDestruct@is_empty:#92-case l%1 of ...>,<EDirect@is_empty:#92-case l%1 of ...>,<ESelect(h)@is_empty:#98-let x%23 = ...>}],
//│ S: None,
//│ I: [[Some(IMix(ICtor(Cons),ICtor(Nil)))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ case l%1 of -- #92
//│   Cons => let x%23 = l%1.h -- #98
//│     in let x%10 = Some(x%23) -- #101
//│       in jump is_empty$M%0(x%10) -- #88
//│   Nil => let x%7 = None() -- #96
//│     in jump is_empty$M%0(x%7) -- #90
//│ )
//│ Def(7, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%17) = mk_list(10) -- #76
//│   in let* (x%18) = is_empty(x%17) -- #75
//│     in x%18 -- #74
//│ )
//│ Def(11, @join is_empty$M%0, [x%15], [{<EDirect@is_empty$M%0:#64-let* (x%16) = is_none ...>,<EIndirectDestruct@is_empty$M%0:#64-let* (x%16) = is_none ...>}],
//│ S: None,
//│ I: [[Some(ICtor(Some))],[Some(ICtor(None))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%16) = is_none(x%15) -- #64
//│   in x%16 -- #63
//│ )
//│ },
//│ let* (x%19) = main() -- #80
//│   in x%19 -- #79)
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(0, mk_list, [n%0], [{<EDirect@mk_list:#22-let x%3 = ...>,<EDirect@mk_list:#24-let x%0 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(Cons),ICtor(Nil)))],
//│ Rec: Some(2),
//│ 1, 
//│ let x%0 = ==(n%0,0) -- #24
//│   in if x%0 -- #23
//│     true => let x%2 = Nil() -- #6
//│       in x%2 -- #81
//│     false => let x%3 = -(n%0,1) -- #22
//│       in let* (x%4) = mk_list(x%3) -- #21
//│         in let x%5 = Cons(n%0,x%4) -- #20
//│           in x%5 -- #82
//│ )
//│ Def(4, is_none, [o%0], [{<EDestruct@is_none:#54-case o%0 of ...>,<EDirect@is_none:#54-case o%0 of ...>}],
//│ S: None,
//│ I: [[Some(ICtor(Some))],[Some(ICtor(None))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ case o%0 of -- #54
//│   None => let x%12 = True() -- #47
//│     in x%12 -- #85
//│   Some => let x%14 = False() -- #52
//│     in x%14 -- #86
//│ )
//│ Def(6, is_empty, [l%1], [{<EDestruct@is_empty:#92-case l%1 of ...>,<EDirect@is_empty:#92-case l%1 of ...>,<ESelect(h)@is_empty:#98-let x%23 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ case l%1 of -- #92
//│   Cons => let x%23 = l%1.h -- #98
//│     in let x%10 = Some(x%23) -- #101
//│       in jump is_empty$M%0$C%1(x%10) -- #108
//│   Nil => let x%7 = None() -- #96
//│     in jump is_empty$M%0$C%0(x%7) -- #109
//│ )
//│ Def(7, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%24,x%25) = mk_list$P%0(10) -- #115
//│   in if x%25 -- #114
//│     true => let x%2 = Nil() -- #124
//│       in jump main$M%0(x%2) -- #110
//│     false => let* (x%27) = mk_list$D%1(x%24) -- #113
//│       in jump main$M%0(x%27) -- #112
//│ )
//│ Def(13, mk_list$P%0, [n%0], [{<EDirect@mk_list$P%0:#102-...>,<EDirect@mk_list$P%0:#24-let x%0 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None,None],
//│ Rec: None,
//│ 2, 
//│ let x%0 = ==(n%0,0) -- #24
//│   in n%0,x%0 -- #102
//│ )
//│ Def(15, mk_list$D%1, [n%0], [{<EDirect@mk_list$D%1:#22-let x%3 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(ICtor(Cons))],
//│ Rec: None,
//│ 1, 
//│ let x%3 = -(n%0,1) -- #22
//│   in let* (x%4) = mk_list(x%3) -- #21
//│     in let x%5 = Cons(n%0,x%4) -- #20
//│       in x%5 -- #82
//│ )
//│ Def(19, @join is_empty$M%0$C%0, [x%15], [{<EDirect@is_empty$M%0$C%0:#105-let* (x%16) = is_none ...>,<EIndirectDestruct@is_empty$M%0$C%0:#105-let* (x%16) = is_none ...>}],
//│ S: Some([Some(ICtor(None))]),
//│ I: [[Some(ICtor(None))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%16) = is_none(x%15) -- #105
//│   in x%16 -- #104
//│ )
//│ Def(20, @join is_empty$M%0$C%1, [x%15], [{<EDirect@is_empty$M%0$C%1:#107-let* (x%16) = is_none ...>,<EIndirectDestruct@is_empty$M%0$C%1:#107-let* (x%16) = is_none ...>}],
//│ S: Some([Some(ICtor(Some))]),
//│ I: [[Some(ICtor(Some))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%16) = is_none(x%15) -- #107
//│   in x%16 -- #106
//│ )
//│ Def(21, @join main$M%0, [x%17], [{<EDirect@main$M%0:#75-let* (x%18) = is_empty ...>,<EIndirectDestruct@main$M%0:#75-let* (x%18) = is_empty ...>,<ESelect(h)@is_empty:#98-let x%23 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(Nil))],[Some(ICtor(Cons))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%18) = is_empty(x%17) -- #75
//│   in x%18 -- #74
//│ )
//│ },
//│ let* (x%19) = main() -- #80
//│   in x%19 -- #79)
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(0, mk_list, [n%0], [{<EDirect@mk_list:#22-let x%3 = ...>,<EDirect@mk_list:#24-let x%0 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(Cons),ICtor(Nil)))],
//│ Rec: Some(3),
//│ 1, 
//│ let x%0 = ==(n%0,0) -- #24
//│   in if x%0 -- #23
//│     true => let x%2 = Nil() -- #6
//│       in x%2 -- #81
//│     false => let x%3 = -(n%0,1) -- #22
//│       in let* (x%4) = mk_list(x%3) -- #21
//│         in let x%5 = Cons(n%0,x%4) -- #20
//│           in x%5 -- #82
//│ )
//│ Def(6, is_empty, [l%1], [{<EDestruct@is_empty:#92-case l%1 of ...>,<EDirect@is_empty:#92-case l%1 of ...>,<ESelect(h)@is_empty:#98-let x%23 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(Cons))],[Some(ICtor(Nil))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ case l%1 of -- #92
//│   Cons => let x%23 = l%1.h -- #98
//│     in let x%10 = Some(x%23) -- #101
//│       in jump is_empty$M%0$C%1(x%10) -- #108
//│   Nil => let x%7 = None() -- #96
//│     in jump is_empty$M%0$C%0(x%7) -- #109
//│ )
//│ Def(7, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%24,x%25) = mk_list$P%0(10) -- #115
//│   in if x%25 -- #114
//│     true => let x%2 = Nil() -- #124
//│       in jump main$M%0$C%1(x%2) -- #140
//│     false => let* (x%27) = mk_list$D%1(x%24) -- #113
//│       in jump main$M%0$C%0(x%27) -- #141
//│ )
//│ Def(13, mk_list$P%0, [n%0], [{<EDirect@mk_list$P%0:#102-...>,<EDirect@mk_list$P%0:#24-let x%0 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None,None],
//│ Rec: None,
//│ 2, 
//│ let x%0 = ==(n%0,0) -- #24
//│   in n%0,x%0 -- #102
//│ )
//│ Def(15, mk_list$D%1, [n%0], [{<EDirect@mk_list$D%1:#22-let x%3 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(ICtor(Cons))],
//│ Rec: None,
//│ 1, 
//│ let x%3 = -(n%0,1) -- #22
//│   in let* (x%4) = mk_list(x%3) -- #21
//│     in let x%5 = Cons(n%0,x%4) -- #20
//│       in x%5 -- #82
//│ )
//│ Def(19, @join is_empty$M%0$C%0, [x%15], [{<EDestruct@is_empty$M%0$C%0:#158-case x%15 of ...>,<EDirect@is_empty$M%0$C%0:#158-case x%15 of ...>}],
//│ S: Some([Some(ICtor(None))]),
//│ I: [[Some(ICtor(None))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ case x%15 of -- #158
//│   Some => let x%14 = False() -- #175
//│     in x%14 -- #173
//│   None => let x%12 = True() -- #179
//│     in x%12 -- #177
//│ )
//│ Def(20, @join is_empty$M%0$C%1, [x%15], [{<EDestruct@is_empty$M%0$C%1:#146-case x%15 of ...>,<EDirect@is_empty$M%0$C%1:#146-case x%15 of ...>}],
//│ S: Some([Some(ICtor(Some))]),
//│ I: [[Some(ICtor(Some))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ case x%15 of -- #146
//│   Some => let x%14 = False() -- #163
//│     in x%14 -- #161
//│   None => let x%12 = True() -- #167
//│     in x%12 -- #165
//│ )
//│ Def(29, @join main$M%0$C%0, [x%17], [{<EDirect@main$M%0$C%0:#137-let* (x%18) = is_empty ...>,<EIndirectDestruct@main$M%0$C%0:#137-let* (x%18) = is_empty ...>,<ESelect(h)@is_empty:#98-let x%23 = ...>}],
//│ S: Some([Some(ICtor(Cons))]),
//│ I: [[Some(ICtor(Cons))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%18) = is_empty(x%17) -- #137
//│   in x%18 -- #136
//│ )
//│ Def(30, @join main$M%0$C%1, [x%17], [{<EDirect@main$M%0$C%1:#139-let* (x%18) = is_empty ...>,<EIndirectDestruct@main$M%0$C%1:#139-let* (x%18) = is_empty ...>,<ESelect(h)@is_empty:#98-let x%23 = ...>}],
//│ S: Some([Some(ICtor(Nil))]),
//│ I: [[Some(ICtor(Nil))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%18) = is_empty(x%17) -- #139
//│   in x%18 -- #138
//│ )
//│ },
//│ let* (x%19) = main() -- #80
//│   in x%19 -- #79)
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(0, mk_list, [n%0], [{<EDirect@mk_list:#22-let x%3 = ...>,<EDirect@mk_list:#24-let x%0 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(Cons),ICtor(Nil)))],
//│ Rec: Some(3),
//│ 1, 
//│ let x%0 = ==(n%0,0) -- #24
//│   in if x%0 -- #23
//│     true => let x%2 = Nil() -- #6
//│       in x%2 -- #81
//│     false => let x%3 = -(n%0,1) -- #22
//│       in let* (x%4) = mk_list(x%3) -- #21
//│         in let x%5 = Cons(n%0,x%4) -- #20
//│           in x%5 -- #82
//│ )
//│ Def(7, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%24,x%25) = mk_list$P%0(10) -- #115
//│   in if x%25 -- #114
//│     true => let x%2 = Nil() -- #124
//│       in jump main$M%0$C%1(x%2) -- #140
//│     false => let* (x%27) = mk_list$D%1(x%24) -- #113
//│       in jump main$M%0$C%0(x%27) -- #141
//│ )
//│ Def(13, mk_list$P%0, [n%0], [{<EDirect@mk_list$P%0:#102-...>,<EDirect@mk_list$P%0:#24-let x%0 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None,None],
//│ Rec: None,
//│ 2, 
//│ let x%0 = ==(n%0,0) -- #24
//│   in n%0,x%0 -- #102
//│ )
//│ Def(15, mk_list$D%1, [n%0], [{<EDirect@mk_list$D%1:#22-let x%3 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(ICtor(Cons))],
//│ Rec: None,
//│ 1, 
//│ let x%3 = -(n%0,1) -- #22
//│   in let* (x%4) = mk_list(x%3) -- #21
//│     in let x%5 = Cons(n%0,x%4) -- #20
//│       in x%5 -- #82
//│ )
//│ Def(19, @join is_empty$M%0$C%0, [x%15], [{<EDestruct@is_empty$M%0$C%0:#158-case x%15 of ...>,<EDirect@is_empty$M%0$C%0:#158-case x%15 of ...>}],
//│ S: Some([Some(ICtor(None))]),
//│ I: [[Some(ICtor(None))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ case x%15 of -- #158
//│   Some => let x%14 = False() -- #175
//│     in x%14 -- #173
//│   None => let x%12 = True() -- #179
//│     in x%12 -- #177
//│ )
//│ Def(20, @join is_empty$M%0$C%1, [x%15], [{<EDestruct@is_empty$M%0$C%1:#146-case x%15 of ...>,<EDirect@is_empty$M%0$C%1:#146-case x%15 of ...>}],
//│ S: Some([Some(ICtor(Some))]),
//│ I: [[Some(ICtor(Some))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ case x%15 of -- #146
//│   Some => let x%14 = False() -- #163
//│     in x%14 -- #161
//│   None => let x%12 = True() -- #167
//│     in x%12 -- #165
//│ )
//│ Def(29, @join main$M%0$C%0, [x%17], [{<EDestruct@main$M%0$C%0:#192-case x%17 of ...>,<EDirect@main$M%0$C%0:#192-case x%17 of ...>,<ESelect(h)@main$M%0$C%0:#210-let x%48 = ...>}],
//│ S: Some([Some(ICtor(Cons))]),
//│ I: [[Some(ICtor(Cons))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ case x%17 of -- #192
//│   Cons => let x%48 = x%17.h -- #210
//│     in let* (x%43) = is_empty$D%2$S%0(x%48) -- #189
//│       in x%43 -- #204
//│   Nil => let* (x%44) = is_empty$D%3() -- #191
//│     in x%44 -- #205
//│ )
//│ Def(30, @join main$M%0$C%1, [x%17], [{<EDestruct@main$M%0$C%1:#198-case x%17 of ...>,<EDirect@main$M%0$C%1:#198-case x%17 of ...>,<ESelect(h)@main$M%0$C%1:#211-let x%49 = ...>}],
//│ S: Some([Some(ICtor(Nil))]),
//│ I: [[Some(ICtor(Nil))]],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ case x%17 of -- #198
//│   Cons => let x%49 = x%17.h -- #211
//│     in let* (x%46) = is_empty$D%2$S%0(x%49) -- #195
//│       in x%46 -- #207
//│   Nil => let* (x%47) = is_empty$D%3() -- #197
//│     in x%47 -- #208
//│ )
//│ Def(36, is_empty$D%3, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let x%7 = None() -- #96
//│   in jump is_empty$M%0$C%0(x%7) -- #109
//│ )
//│ Def(45, is_empty$D%2$S%0, [l%1_h], [{<EDirect@is_empty$D%2$S%0:#101-let x%10 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let x%10 = Some(l%1_h) -- #101
//│   in jump is_empty$M%0$C%1(x%10) -- #108
//│ )
//│ },
//│ let* (x%19) = main() -- #80
//│   in x%19 -- #79)
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, [])}, {
//│ Def(0, mk_list, [n%0], [{<EDirect@mk_list:#22-let x%3 = ...>,<EDirect@mk_list:#24-let x%0 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(Cons),ICtor(Nil)))],
//│ Rec: Some(2),
//│ 1, 
//│ let x%0 = ==(n%0,0) -- #24
//│   in if x%0 -- #23
//│     true => let x%2 = Nil() -- #6
//│       in x%2 -- #81
//│     false => let x%3 = -(n%0,1) -- #22
//│       in let* (x%4) = mk_list(x%3) -- #21
//│         in let x%5 = Cons(n%0,x%4) -- #20
//│           in x%5 -- #82
//│ )
//│ Def(7, main, [], [],
//│ S: None,
//│ I: [],
//│ R: [Some(IMix(ICtor(False),ICtor(True)))],
//│ Rec: None,
//│ 1, 
//│ let* (x%24,x%25) = mk_list$P%0(10) -- #115
//│   in if x%25 -- #114
//│     true => let x%12 = True() -- #240
//│       in x%12 -- #208
//│     false => let* (x%27) = mk_list$D%1(x%24) -- #113
//│       in let x%14 = False() -- #241
//│         in x%14 -- #204
//│ )
//│ Def(13, mk_list$P%0, [n%0], [{<EDirect@mk_list$P%0:#102-...>,<EDirect@mk_list$P%0:#24-let x%0 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None,None],
//│ Rec: None,
//│ 2, 
//│ let x%0 = ==(n%0,0) -- #24
//│   in n%0,x%0 -- #102
//│ )
//│ Def(15, mk_list$D%1, [n%0], [{<EDirect@mk_list$D%1:#22-let x%3 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [Some(ICtor(Cons))],
//│ Rec: None,
//│ 1, 
//│ let x%3 = -(n%0,1) -- #22
//│   in let* (x%4) = mk_list(x%3) -- #21
//│     in let x%5 = Cons(n%0,x%4) -- #20
//│       in x%5 -- #82
//│ )
//│ },
//│ let* (x%19) = main() -- #80
//│   in x%19 -- #79)
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ Interpreted ------------------------------
//│ False()
//│ 
//│ 
//│ 
//│ Fuel used: 6

