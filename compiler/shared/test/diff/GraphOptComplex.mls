:NewParser
:ParseOnly

:GraphInterp
:GraphOpt
class A(x, y, z)
class B(m, n)
fun complex_foo(t) =
  let r = if t is
    A(x, y, z) then x + y * z
    B(m, n) then m - n
  let s = B(1, 2)
  let u = if s is
    A(x, y, z) then 3
    B(m, n) then 4
  r + u
fun bar() =
  complex_foo(A(6, 7, 8))
  complex_foo(B(9, 10))
bar()
//│ |#class| |A|(|x|,| |y|,| |z|)|↵|#class| |B|(|m|,| |n|)|↵|#fun| |complex_foo|(|t|)| |#=|→|#let| |r| |#=| |#if| |t| |is|→|A|(|x|,| |y|,| |z|)| |#then| |x| |+| |y| |*| |z|↵|B|(|m|,| |n|)| |#then| |m| |-| |n|←|↵|#let| |s| |#=| |B|(|1|,| |2|)|↵|#let| |u| |#=| |#if| |s| |is|→|A|(|x|,| |y|,| |z|)| |#then| |3|↵|B|(|m|,| |n|)| |#then| |4|←|↵|r| |+| |u|←|↵|#fun| |bar|(||)| |#=|→|complex_foo|(|A|(|6|,| |7|,| |8|)|)|↵|complex_foo|(|B|(|9|,| |10|)|)|←|↵|bar|(||)|
//│ Parsed: {class A(x, y, z,) {}; class B(m, n,) {}; fun complex_foo = (t,) => {let r = if t is ‹(A(x, y, z,)) then +(x,)(*(y,)(z,),); (B(m, n,)) then -(m,)(n,)›; let s = B(1, 2,); let u = if s is ‹(A(x, y, z,)) then 3; (B(m, n,)) then 4›; +(r,)(u,)}; fun bar = () => {complex_foo(A(6, 7, 8,),); complex_foo(B(9, 10,),)}; bar()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, A, [x,y,z]),ClassInfo(1, B, [m,n])}, {
//│ Def(0, complex_foo, [t%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case t%0 of -- #63
//│   A => let x%0 = t%0.z -- #17
//│     in let x%1 = t%0.y -- #16
//│       in let x%2 = t%0.x -- #15
//│         in let x%3 = *(x%1,x%0) -- #14
//│           in let x%4 = +(x%2,x%3) -- #13
//│             in jump j%0(x%4) -- #12
//│   B => let x%5 = t%0.n -- #28
//│     in let x%6 = t%0.m -- #27
//│       in let x%7 = -(x%6,x%5) -- #26
//│         in jump j%0(x%7) -- #25
//│ )
//│ Def(1, @join j%0, [x%8], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%9 = B(1,2) -- #62
//│   in case x%9 of -- #61
//│     A => let x%10 = x%9.z -- #47
//│       in let x%11 = x%9.y -- #46
//│         in let x%12 = x%9.x -- #45
//│           in jump j%1(3) -- #44
//│     B => let x%13 = x%9.n -- #55
//│       in let x%14 = x%9.m -- #54
//│         in jump j%1(4) -- #53
//│ )
//│ Def(2, @join j%1, [x%15], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%16 = +(x%8,x%15) -- #60
//│   in x%16
//│ )
//│ Def(3, bar, [], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%17 = A(6,7,8) -- #89
//│   in let* (x%18) = complex_foo(x%17) -- #88
//│     in let x%19 = B(9,10) -- #87
//│       in let* (x%20) = complex_foo(x%19) -- #86
//│         in x%20
//│ )
//│ },
//│ let* (x%21) = bar() -- #93
//│   in x%21)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, A, [x,y,z]),ClassInfo(1, B, [m,n])}, {
//│ Def(0, complex_foo, [t%0], [{<EDestruct@complex_foo:case t%0 of ...>,<EDirect@complex_foo:case t%0 of ...>,<ESelect(m)@complex_foo:let x%6 = ...>,<ESelect(n)@complex_foo:let x%5 = ...>,<ESelect(x)@complex_foo:let x%2 = ...>,<ESelect(y)@complex_foo:let x%1 = ...>,<ESelect(z)@complex_foo:let x%0 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(A))],[Some(ICtor(B))]],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case t%0 of -- #63
//│   A => let x%0 = t%0.z -- #17
//│     in let x%1 = t%0.y -- #16
//│       in let x%2 = t%0.x -- #15
//│         in let x%3 = *(x%1,x%0) -- #14
//│           in let x%4 = +(x%2,x%3) -- #13
//│             in let x%16 = +(x%4,4) -- #96
//│               in x%16
//│   B => let x%5 = t%0.n -- #28
//│     in let x%6 = t%0.m -- #27
//│       in let x%7 = -(x%6,x%5) -- #26
//│         in let x%16 = +(x%7,4) -- #97
//│           in x%16
//│ )
//│ Def(3, bar, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%17 = A(6,7,8) -- #89
//│   in let* (x%18) = complex_foo(x%17) -- #x
//│     in let x%19 = B(9,10) -- #87
//│       in let* (x%20) = complex_foo(x%19) -- #x
//│         in x%20
//│ )
//│ },
//│ let* (x%21) = bar() -- #93
//│   in x%21)
//│ 
//│ Interpreted ------------------------------
//│ 3
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, A, [x,y,z]),ClassInfo(1, B, [m,n])}, {
//│ Def(3, bar, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x%18) = complex_foo$D%0$S%0(8,7,6) -- #x
//│   in let* (x%20) = complex_foo$D%1$S%0(9,10) -- #x
//│     in x%20
//│ )
//│ Def(7, complex_foo$D%1$S%0, [t%0_m,t%0_n], [{<EDirect@complex_foo$D%1$S%0:let x%7 = ...>},{<EDirect@complex_foo$D%1$S%0:let x%7 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%7 = -(t%0_m,t%0_n) -- #x
//│   in let x%16 = +(x%7,4) -- #x
//│     in x%16
//│ )
//│ Def(8, complex_foo$D%0$S%0, [t%0_z,t%0_y,t%0_x], [{<EDirect@complex_foo$D%0$S%0:let x%3 = ...>},{<EDirect@complex_foo$D%0$S%0:let x%3 = ...>},{<EDirect@complex_foo$D%0$S%0:let x%4 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%3 = *(t%0_y,t%0_z) -- #x
//│   in let x%4 = +(t%0_x,x%3) -- #x
//│     in let x%16 = +(x%4,4) -- #x
//│       in x%16
//│ )
//│ },
//│ let* (x%21) = bar() -- #x
//│   in x%21)
//│ 
//│ 
//│ Interpreted ------------------------------
//│ 3
//│ 
//│ 
//│ Fuel used: 2

:GraphInterp
:GraphOpt
class A(w, x)
class B(y)
class C(z)
fun complex_foo(t) =
  let a = 1 + 2
  let b = 1 * 2
  let x = if t is
    A(x, y) then y
    B(x) then B(x + b)
    C(x) then C(0)
  let z = A(5, x)
  let v = B(6)
  let y = if x is
    A(x, y) then
      let m = x + a + b
      if y is
        A(x, y) then x
        B(x) then m
        C(x) then 0
    B(x) then 2
    C(x) then 3
  if z is
    A(x, y) then x
    B(x) then 4
    C(x) then
      if v is
        A(x, y) then x
        B(x) then 7
        C(x) then 8
fun bar() =
  complex_foo(A(10, A(9, B(10))))
bar()
//│ |#class| |A|(|w|,| |x|)|↵|#class| |B|(|y|)|↵|#class| |C|(|z|)|↵|#fun| |complex_foo|(|t|)| |#=|→|#let| |a| |#=| |1| |+| |2|↵|#let| |b| |#=| |1| |*| |2|↵|#let| |x| |#=| |#if| |t| |is|→|A|(|x|,| |y|)| |#then| |y|↵|B|(|x|)| |#then| |B|(|x| |+| |b|)|↵|C|(|x|)| |#then| |C|(|0|)|←|↵|#let| |z| |#=| |A|(|5|,| |x|)|↵|#let| |v| |#=| |B|(|6|)|↵|#let| |y| |#=| |#if| |x| |is|→|A|(|x|,| |y|)| |#then|→|#let| |m| |#=| |x| |+| |a| |+| |b|↵|#if| |y| |is|→|A|(|x|,| |y|)| |#then| |x|↵|B|(|x|)| |#then| |m|↵|C|(|x|)| |#then| |0|←|←|↵|B|(|x|)| |#then| |2|↵|C|(|x|)| |#then| |3|←|↵|#if| |z| |is|→|A|(|x|,| |y|)| |#then| |x|↵|B|(|x|)| |#then| |4|↵|C|(|x|)| |#then|→|#if| |v| |is|→|A|(|x|,| |y|)| |#then| |x|↵|B|(|x|)| |#then| |7|↵|C|(|x|)| |#then| |8|←|←|←|←|↵|#fun| |bar|(||)| |#=|→|complex_foo|(|A|(|10|,| |A|(|9|,| |B|(|10|)|)|)|)|←|↵|bar|(||)|
//│ Parsed: {class A(w, x,) {}; class B(y,) {}; class C(z,) {}; fun complex_foo = (t,) => {let a = +(1,)(2,); let b = *(1,)(2,); let x = if t is ‹(A(x, y,)) then y; (B(x,)) then B(+(x,)(b,),); (C(x,)) then C(0,)›; let z = A(5, x,); let v = B(6,); let y = if x is ‹(A(x, y,)) then {let m = +(+(x,)(a,),)(b,); if y is ‹(A(x, y,)) then x; (B(x,)) then m; (C(x,)) then 0›}; (B(x,)) then 2; (C(x,)) then 3›; if z is ‹(A(x, y,)) then x; (B(x,)) then 4; (C(x,)) then {if v is ‹(A(x, y,)) then x; (B(x,)) then 7; (C(x,)) then 8›}›}; fun bar = () => {complex_foo(A(10, A(9, B(10,),),),)}; bar()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, A, [w,x]),ClassInfo(1, B, [y]),ClassInfo(2, C, [z])}, {
//│ Def(0, complex_foo, [t%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%0 = +(1,2) -- #140
//│   in let x%1 = *(1,2) -- #139
//│     in case t%0 of -- #138
//│       A => let x%2 = t%0.x -- #14
//│         in let x%3 = t%0.w -- #13
//│           in jump j%0(x%2) -- #12
//│       B => let x%4 = t%0.y -- #26
//│         in let x%5 = +(x%4,x%1) -- #25
//│           in let x%6 = B(x%5) -- #24
//│             in jump j%0(x%6) -- #23
//│       C => let x%7 = t%0.z -- #35
//│         in let x%8 = C(0) -- #34
//│           in jump j%0(x%8) -- #33
//│ )
//│ Def(1, @join j%0, [x%9], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%10 = A(5,x%9) -- #137
//│   in let x%11 = B(6) -- #136
//│     in case x%9 of -- #135
//│       A => let x%12 = x%9.x -- #82
//│         in let x%13 = x%9.w -- #81
//│           in let x%14 = +(x%13,x%0) -- #80
//│             in let x%15 = +(x%14,x%1) -- #79
//│               in case x%12 of -- #78
//│                 A => let x%16 = x%12.x -- #65
//│                   in let x%17 = x%12.w -- #64
//│                     in jump j%2(x%17) -- #63
//│                 B => let x%18 = x%12.y -- #70
//│                   in jump j%2(x%15) -- #69
//│                 C => let x%19 = x%12.z -- #75
//│                   in jump j%2(0) -- #74
//│       B => let x%21 = x%9.y -- #87
//│         in jump j%1(2) -- #86
//│       C => let x%22 = x%9.z -- #92
//│         in jump j%1(3) -- #91
//│ )
//│ Def(2, @join j%2, [x%20], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j%1(x%20) -- #77
//│ )
//│ Def(3, @join j%1, [x%23], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x%10 of -- #134
//│   A => let x%24 = x%10.x -- #102
//│     in let x%25 = x%10.w -- #101
//│       in jump j%3(x%25) -- #100
//│   B => let x%26 = x%10.y -- #107
//│     in jump j%3(4) -- #106
//│   C => let x%27 = x%10.z -- #132
//│     in case x%11 of -- #131
//│       A => let x%28 = x%11.x -- #118
//│         in let x%29 = x%11.w -- #117
//│           in jump j%4(x%29) -- #116
//│       B => let x%30 = x%11.y -- #123
//│         in jump j%4(7) -- #122
//│       C => let x%31 = x%11.z -- #128
//│         in jump j%4(8) -- #127
//│ )
//│ Def(4, @join j%4, [x%32], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j%3(x%32) -- #130
//│ )
//│ Def(5, @join j%3, [x%33], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%33
//│ )
//│ Def(6, bar, [], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%34 = B(10) -- #162
//│   in let x%35 = A(9,x%34) -- #161
//│     in let x%36 = A(10,x%35) -- #160
//│       in let* (x%37) = complex_foo(x%36) -- #159
//│         in x%37
//│ )
//│ },
//│ let* (x%38) = bar() -- #166
//│   in x%38)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, A, [w,x]),ClassInfo(1, B, [y]),ClassInfo(2, C, [z])}, {
//│ Def(0, complex_foo, [t%0], [{<EDestruct@complex_foo:case t%0 of ...>,<EDirect@complex_foo:case t%0 of ...>,<ESelect(x)@complex_foo:let x%2 = ...>,<ESelect(y)@complex_foo:let x%4 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(A))]],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%0 = +(1,2) -- #140
//│   in let x%1 = *(1,2) -- #139
//│     in case t%0 of -- #138
//│       A => let x%2 = t%0.x -- #14
//│         in jump j%0(x%2) -- #12
//│       B => let x%4 = t%0.y -- #26
//│         in let x%5 = +(x%4,x%1) -- #25
//│           in let x%6 = B(x%5) -- #24
//│             in jump j%0(x%6) -- #23
//│       C => let x%8 = C(0) -- #34
//│         in jump j%0(x%8) -- #33
//│ )
//│ Def(1, @join j%0, [x%9], [{<EDestruct@j%0:case x%9 of ...>,<EDirect@j%0:case x%9 of ...>,<EDirect@j%0:let x%10 = ...>,<ESelect(w)@j%0:let x%13 = ...>,<ESelect(x)@j%0:let x%12 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(B))],[Some(ICtor(C))]],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%10 = A(5,x%9) -- #137
//│   in let x%11 = B(6) -- #136
//│     in case x%9 of -- #135
//│       A => let x%12 = x%9.x -- #82
//│         in let x%13 = x%9.w -- #81
//│           in let x%14 = +(x%13,x%0) -- #80
//│             in let x%15 = +(x%14,x%1) -- #79
//│               in case x%12 of -- #78
//│                 A => let x%17 = x%12.w -- #64
//│                   in jump j%1(x%17) -- #167
//│                 B => jump j%1(x%15) -- #168
//│                 C => jump j%1(0) -- #169
//│       B => jump j%1(2) -- #86
//│       C => jump j%1(3) -- #91
//│ )
//│ Def(3, @join j%1, [x%23], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x%10 of -- #134
//│   A => let x%25 = x%10.w -- #101
//│     in x%25
//│   B => 4
//│   C => case x%11 of -- #131
//│     A => let x%29 = x%11.w -- #117
//│       in x%29
//│     B => 7
//│     C => 8
//│ )
//│ Def(6, bar, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%34 = B(10) -- #162
//│   in let x%35 = A(9,x%34) -- #161
//│     in let x%36 = A(10,x%35) -- #160
//│       in let* (x%37) = complex_foo(x%36) -- #x
//│         in x%37
//│ )
//│ },
//│ let* (x%38) = bar() -- #166
//│   in x%38)
//│ 
//│ Interpreted ------------------------------
//│ 5
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, A, [w,x]),ClassInfo(1, B, [y]),ClassInfo(2, C, [z])}, {
//│ Def(1, @join j%0, [x%9], [{<EDestruct@j%0:case x%9 of ...>,<EDirect@j%0:case x%9 of ...>,<EDirect@j%0:let x%10 = ...>,<ESelect(w)@j%0:let x%13 = ...>,<ESelect(x)@j%0:let x%12 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%10 = A(5,x%9) -- #x
//│   in let x%11 = B(6) -- #x
//│     in case x%9 of -- #x
//│       A => let x%12 = x%9.x -- #x
//│         in let x%13 = x%9.w -- #x
//│           in let x%14 = +(x%13,x%0) -- #x
//│             in let x%15 = +(x%14,x%1) -- #x
//│               in case x%12 of -- #x
//│                 A => let x%17 = x%12.w -- #x
//│                   in jump j%1(x%17) -- #x
//│                 B => jump j%1(x%15) -- #x
//│                 C => jump j%1(0) -- #x
//│       B => jump j%1(2) -- #x
//│       C => jump j%1(3) -- #x
//│ )
//│ Def(3, @join j%1, [x%23], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x%10 of -- #x
//│   A => let x%25 = x%10.w -- #x
//│     in x%25
//│   B => 4
//│   C => case x%11 of -- #x
//│     A => let x%29 = x%11.w -- #x
//│       in x%29
//│     B => 7
//│     C => 8
//│ )
//│ Def(6, bar, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%34 = B(10) -- #x
//│   in let x%35 = A(9,x%34) -- #x
//│     in let x%36 = A(10,x%35) -- #x
//│       in let* (x%54,x%55,x%56) = complex_foo$P%0(x%36) -- #x
//│         in let* (x%37) = complex_foo$D%0(x%54,x%55,x%56) -- #x
//│           in x%37
//│ )
//│ Def(7, complex_foo$P%0, [t%0], [{<EDirect@complex_foo$P%0:...>}],
//│ S: None,
//│ I: [[Some(ICtor(A))]],
//│ R: [None,None,None],
//│ Rec: None,
//│ 3, 
//│ let x%0 = +(1,2) -- #x
//│   in let x%1 = *(1,2) -- #x
//│     in t%0,x%0,x%1
//│ )
//│ Def(8, complex_foo$D%0, [t%0,x%0,x%1], [{<ESelect(x)@complex_foo$D%0:let x%2 = ...>},{<EDirect@j%0:let x%14 = ...>},{<EDirect@j%0:let x%15 = ...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%2 = t%0.x -- #x
//│   in jump j%0(x%2) -- #x
//│ )
//│ },
//│ let* (x%38) = bar() -- #x
//│   in x%38)
//│ 
//│ 
//│ Interpreted ------------------------------
//│ 5
//│ 
//│ 
//│ Fuel used: 2

:GraphInterp
:GraphOpt
class A(w, x)
class B(y)
class C(z)
fun complex_foo(t) =
  let a = 1 + 2
  let b = 1 * 2
  let x = if t is
    A(x, y) then A(x, C(0))
    B(x) then B(x + b)
    C(x) then C(0)
  let z = A(5, x)
  let v = B(6)
  let y = if x is
    A(x, y) then
      let m = x + a + b
      if y is
        A(x, y) then x
        B(x) then m
        C(x) then 0
    B(x) then 2
    C(x) then 3
  if z is
    A(x, y) then x
    B(x) then 4
    C(x) then
      if v is
        A(x, y) then x
        B(x) then 7
        C(x) then 8
fun bar() =
  complex_foo(A(10, A(9, B(10))))
bar()
//│ |#class| |A|(|w|,| |x|)|↵|#class| |B|(|y|)|↵|#class| |C|(|z|)|↵|#fun| |complex_foo|(|t|)| |#=|→|#let| |a| |#=| |1| |+| |2|↵|#let| |b| |#=| |1| |*| |2|↵|#let| |x| |#=| |#if| |t| |is|→|A|(|x|,| |y|)| |#then| |A|(|x|,| |C|(|0|)|)|↵|B|(|x|)| |#then| |B|(|x| |+| |b|)|↵|C|(|x|)| |#then| |C|(|0|)|←|↵|#let| |z| |#=| |A|(|5|,| |x|)|↵|#let| |v| |#=| |B|(|6|)|↵|#let| |y| |#=| |#if| |x| |is|→|A|(|x|,| |y|)| |#then|→|#let| |m| |#=| |x| |+| |a| |+| |b|↵|#if| |y| |is|→|A|(|x|,| |y|)| |#then| |x|↵|B|(|x|)| |#then| |m|↵|C|(|x|)| |#then| |0|←|←|↵|B|(|x|)| |#then| |2|↵|C|(|x|)| |#then| |3|←|↵|#if| |z| |is|→|A|(|x|,| |y|)| |#then| |x|↵|B|(|x|)| |#then| |4|↵|C|(|x|)| |#then|→|#if| |v| |is|→|A|(|x|,| |y|)| |#then| |x|↵|B|(|x|)| |#then| |7|↵|C|(|x|)| |#then| |8|←|←|←|←|↵|#fun| |bar|(||)| |#=|→|complex_foo|(|A|(|10|,| |A|(|9|,| |B|(|10|)|)|)|)|←|↵|bar|(||)|
//│ Parsed: {class A(w, x,) {}; class B(y,) {}; class C(z,) {}; fun complex_foo = (t,) => {let a = +(1,)(2,); let b = *(1,)(2,); let x = if t is ‹(A(x, y,)) then A(x, C(0,),); (B(x,)) then B(+(x,)(b,),); (C(x,)) then C(0,)›; let z = A(5, x,); let v = B(6,); let y = if x is ‹(A(x, y,)) then {let m = +(+(x,)(a,),)(b,); if y is ‹(A(x, y,)) then x; (B(x,)) then m; (C(x,)) then 0›}; (B(x,)) then 2; (C(x,)) then 3›; if z is ‹(A(x, y,)) then x; (B(x,)) then 4; (C(x,)) then {if v is ‹(A(x, y,)) then x; (B(x,)) then 7; (C(x,)) then 8›}›}; fun bar = () => {complex_foo(A(10, A(9, B(10,),),),)}; bar()}
//│ 
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, A, [w,x]),ClassInfo(1, B, [y]),ClassInfo(2, C, [z])}, {
//│ Def(0, complex_foo, [t%0], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%0 = +(1,2) -- #150
//│   in let x%1 = *(1,2) -- #149
//│     in case t%0 of -- #148
//│       A => let x%2 = t%0.x -- #24
//│         in let x%3 = t%0.w -- #23
//│           in let x%4 = C(0) -- #22
//│             in let x%5 = A(x%3,x%4) -- #21
//│               in jump j%0(x%5) -- #20
//│       B => let x%6 = t%0.y -- #36
//│         in let x%7 = +(x%6,x%1) -- #35
//│           in let x%8 = B(x%7) -- #34
//│             in jump j%0(x%8) -- #33
//│       C => let x%9 = t%0.z -- #45
//│         in let x%10 = C(0) -- #44
//│           in jump j%0(x%10) -- #43
//│ )
//│ Def(1, @join j%0, [x%11], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%12 = A(5,x%11) -- #147
//│   in let x%13 = B(6) -- #146
//│     in case x%11 of -- #145
//│       A => let x%14 = x%11.x -- #92
//│         in let x%15 = x%11.w -- #91
//│           in let x%16 = +(x%15,x%0) -- #90
//│             in let x%17 = +(x%16,x%1) -- #89
//│               in case x%14 of -- #88
//│                 A => let x%18 = x%14.x -- #75
//│                   in let x%19 = x%14.w -- #74
//│                     in jump j%2(x%19) -- #73
//│                 B => let x%20 = x%14.y -- #80
//│                   in jump j%2(x%17) -- #79
//│                 C => let x%21 = x%14.z -- #85
//│                   in jump j%2(0) -- #84
//│       B => let x%23 = x%11.y -- #97
//│         in jump j%1(2) -- #96
//│       C => let x%24 = x%11.z -- #102
//│         in jump j%1(3) -- #101
//│ )
//│ Def(2, @join j%2, [x%22], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j%1(x%22) -- #87
//│ )
//│ Def(3, @join j%1, [x%25], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x%12 of -- #144
//│   A => let x%26 = x%12.x -- #112
//│     in let x%27 = x%12.w -- #111
//│       in jump j%3(x%27) -- #110
//│   B => let x%28 = x%12.y -- #117
//│     in jump j%3(4) -- #116
//│   C => let x%29 = x%12.z -- #142
//│     in case x%13 of -- #141
//│       A => let x%30 = x%13.x -- #128
//│         in let x%31 = x%13.w -- #127
//│           in jump j%4(x%31) -- #126
//│       B => let x%32 = x%13.y -- #133
//│         in jump j%4(7) -- #132
//│       C => let x%33 = x%13.z -- #138
//│         in jump j%4(8) -- #137
//│ )
//│ Def(4, @join j%4, [x%34], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j%3(x%34) -- #140
//│ )
//│ Def(5, @join j%3, [x%35], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x%35
//│ )
//│ Def(6, bar, [], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%36 = B(10) -- #172
//│   in let x%37 = A(9,x%36) -- #171
//│     in let x%38 = A(10,x%37) -- #170
//│       in let* (x%39) = complex_foo(x%38) -- #169
//│         in x%39
//│ )
//│ },
//│ let* (x%40) = bar() -- #176
//│   in x%40)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, A, [w,x]),ClassInfo(1, B, [y]),ClassInfo(2, C, [z])}, {
//│ Def(0, complex_foo, [t%0], [{<EDestruct@complex_foo:case t%0 of ...>,<EDirect@complex_foo:case t%0 of ...>,<ESelect(w)@complex_foo:let x%3 = ...>,<ESelect(y)@complex_foo:let x%6 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(A))]],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%0 = +(1,2) -- #150
//│   in let x%1 = *(1,2) -- #149
//│     in case t%0 of -- #148
//│       A => let x%3 = t%0.w -- #23
//│         in let x%4 = C(0) -- #22
//│           in let x%5 = A(x%3,x%4) -- #21
//│             in jump j%0(x%5) -- #20
//│       B => let x%6 = t%0.y -- #36
//│         in let x%7 = +(x%6,x%1) -- #35
//│           in let x%8 = B(x%7) -- #34
//│             in jump j%0(x%8) -- #33
//│       C => let x%10 = C(0) -- #44
//│         in jump j%0(x%10) -- #43
//│ )
//│ Def(1, @join j%0, [x%11], [{<EDestruct@j%0:case x%11 of ...>,<EDirect@j%0:case x%11 of ...>,<EDirect@j%0:let x%12 = ...>,<ESelect(w)@j%0:let x%15 = ...>,<ESelect(x)@j%0:let x%14 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(A))],[Some(ICtor(B))],[Some(ICtor(C))]],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%12 = A(5,x%11) -- #147
//│   in let x%13 = B(6) -- #146
//│     in case x%11 of -- #145
//│       A => let x%14 = x%11.x -- #92
//│         in let x%15 = x%11.w -- #91
//│           in let x%16 = +(x%15,x%0) -- #90
//│             in let x%17 = +(x%16,x%1) -- #89
//│               in case x%14 of -- #88
//│                 A => let x%19 = x%14.w -- #74
//│                   in jump j%1(x%19) -- #177
//│                 B => jump j%1(x%17) -- #178
//│                 C => jump j%1(0) -- #179
//│       B => jump j%1(2) -- #96
//│       C => jump j%1(3) -- #101
//│ )
//│ Def(3, @join j%1, [x%25], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x%12 of -- #144
//│   A => let x%27 = x%12.w -- #111
//│     in x%27
//│   B => 4
//│   C => case x%13 of -- #141
//│     A => let x%31 = x%13.w -- #127
//│       in x%31
//│     B => 7
//│     C => 8
//│ )
//│ Def(6, bar, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%36 = B(10) -- #172
//│   in let x%37 = A(9,x%36) -- #171
//│     in let x%38 = A(10,x%37) -- #170
//│       in let* (x%39) = complex_foo(x%38) -- #x
//│         in x%39
//│ )
//│ },
//│ let* (x%40) = bar() -- #176
//│   in x%40)
//│ 
//│ Interpreted ------------------------------
//│ 5
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, A, [w,x]),ClassInfo(1, B, [y]),ClassInfo(2, C, [z])}, {
//│ Def(3, @join j%1, [x%25], [{}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x%12 of -- #x
//│   A => let x%27 = x%12.w -- #x
//│     in x%27
//│   B => 4
//│   C => case x%13 of -- #x
//│     A => let x%31 = x%13.w -- #x
//│       in x%31
//│     B => 7
//│     C => 8
//│ )
//│ Def(6, bar, [], [],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%36 = B(10) -- #x
//│   in let x%37 = A(9,x%36) -- #x
//│     in let x%38 = A(10,x%37) -- #x
//│       in let* (x%61,x%62,x%63) = complex_foo$P%0(x%38) -- #x
//│         in let* (x%39) = complex_foo$D%0(x%61,x%62,x%63) -- #x
//│           in x%39
//│ )
//│ Def(7, complex_foo$P%0, [t%0], [{<EDirect@complex_foo$P%0:...>}],
//│ S: None,
//│ I: [[Some(ICtor(A))]],
//│ R: [None,None,None],
//│ Rec: None,
//│ 3, 
//│ let x%0 = +(1,2) -- #x
//│   in let x%1 = *(1,2) -- #x
//│     in t%0,x%0,x%1
//│ )
//│ Def(8, complex_foo$D%0, [t%0,x%0,x%1], [{<ESelect(w)@complex_foo$D%0:let x%3 = ...>},{<EDirect@j%0$D%0:let x%16 = ...>,<EDirect@j%0$P%0:...>},{<EDirect@j%0$D%0:let x%17 = ...>,<EDirect@j%0$P%0:...>}],
//│ S: None,
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%3 = t%0.w -- #x
//│   in let x%4 = C(0) -- #x
//│     in let x%5 = A(x%3,x%4) -- #x
//│       in let* (x%69,x%70,x%71,x%72,x%73) = j%0$P%0(x%5) -- #x
//│         in jump j%0$D%0(x%69,x%70,x%71,x%72,x%73) -- #x
//│ )
//│ Def(11, j%0$P%0, [x%11], [{<EDirect@j%0$P%0:...>,<EDirect@j%0$P%0:let x%12 = ...>}],
//│ S: None,
//│ I: [[Some(ICtor(A))]],
//│ R: [Some(ICtor(A)),None,None,Some(ICtor(B)),None],
//│ Rec: None,
//│ 5, 
//│ let x%12 = A(5,x%11) -- #x
//│   in let x%13 = B(6) -- #x
//│     in x%12,x%1,x%0,x%13,x%11
//│ )
//│ Def(12, j%0$D%0, [x%12,x%1,x%0,x%13,x%11], [{<EDestruct@j%1:case x%12 of ...>,<EDirect@j%1:case x%12 of ...>,<ESelect(w)@j%1:let x%27 = ...>},{<EDirect@j%0$D%0:let x%17 = ...>},{<EDirect@j%0$D%0:let x%16 = ...>},{<EDestruct@j%1:case x%13 of ...>,<EDirect@j%1:case x%13 of ...>,<ESelect(w)@j%1:let x%31 = ...>},{<ESelect(w)@j%0$D%0:let x%15 = ...>,<ESelect(x)@j%0$D%0:let x%14 = ...>}],
//│ S: None,
//│ I: [[None,None,None,Some(ICtor(A)),Some(ICtor(B))]],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x%14 = x%11.x -- #x
//│   in let x%15 = x%11.w -- #x
//│     in let x%16 = +(x%15,x%0) -- #x
//│       in let x%17 = +(x%16,x%1) -- #x
//│         in case x%14 of -- #x
//│           A => let x%19 = x%14.w -- #x
//│             in jump j%1(x%19) -- #x
//│           B => jump j%1(x%17) -- #x
//│           C => jump j%1(0) -- #x
//│ )
//│ },
//│ let* (x%40) = bar() -- #x
//│   in x%40)
//│ 
//│ 
//│ Interpreted ------------------------------
//│ 5
//│ 
//│ 
//│ Fuel used: 2
